<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <link rel="icon" href="data:image/svg+xml,<svg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 100 100'><text y='80' font-size='80'>ü§ñ</text></svg>" />
  <title>GitHub Copilot Agents - In a Nutshell</title>
  <meta name="description" content="A comprehensive guide to GitHub Copilot Agents and AI-assisted coding.">
  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    :root{
      --bg: #ffffff;
      --fg: #0f172a;
      --muted: #64748b;
      --accent: #3b82f6;
      --accent-light: #dbeafe;
      --border: #e2e8f0;
      --sidebar-bg: #ffffff;
      --sidebar-fg: #0f172a;
      --code-bg: linear-gradient(90deg, rgba(59, 130, 246, 0.08) 0%, rgba(59, 130, 246, 0.12) 100%);
      --focus: #10b981;
      --shadow-sm: 0 1px 3px rgba(0,0,0,0.08);
      --shadow-md: 0 4px 6px rgba(0,0,0,0.1), 0 2px 4px rgba(0,0,0,0.06);
      --shadow-lg: 0 10px 20px rgba(0,0,0,0.12), 0 6px 6px rgba(0,0,0,0.08);
      --gradient: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
    }
    
    /* Bootstrap Gradient Utility Classes */
    .bg-gradient-blue { background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%) !important; }
    .bg-gradient-green { background: linear-gradient(135deg, #dcfce7 0%, #bbf7d0 100%) !important; }
    .bg-gradient-yellow { background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%) !important; }
    .bg-gradient-pink { background: linear-gradient(135deg, #fce7f3 0%, #fbcfe8 100%) !important; }
    .bg-gradient-purple { background: linear-gradient(135deg, #e9d5ff 0%, #d8b4fe 100%) !important; }
    .bg-gradient-teal { background: linear-gradient(135deg, #ccfbf1 0%, #99f6e4 100%) !important; }
    .bg-gradient-blue-dark { background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%) !important; }
    .bg-gradient-gray { background: linear-gradient(135deg, #64748b 0%, #475569 100%) !important; }
    .bg-gradient-purple-dark { background: linear-gradient(135deg, #a855f7 0%, #9333ea 100%) !important; }
    .bg-gradient-teal-dark { background: linear-gradient(135deg, #14b8a6 0%, #0d9488 100%) !important; }
    .bg-gradient-green-dark { background: linear-gradient(135deg, #10b981 0%, #059669 100%) !important; }
    .bg-gradient-red { background: linear-gradient(135deg, #fee2e2 0%, #fecaca 100%) !important; }
    .bg-gradient-green-light { background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%) !important; }
    .bg-gradient-blue-sky { background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%) !important; }
    .bg-gradient-red-dark { background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%) !important; }
    .bg-gradient-indigo { background: linear-gradient(135deg, #4f46e5 0%, #4338ca 100%) !important; }
    .bg-gradient-green-medium { background: linear-gradient(135deg, #10b981 0%, #059669 100%) !important; }
    .bg-gradient-orange { background: linear-gradient(135deg, #f97316 0%, #ea580c 100%) !important; }
    .bg-gradient-violet { background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%) !important; }
    .bg-gradient-lime { background: linear-gradient(135deg, #84cc16 0%, #65a30d 100%) !important; }
    .bg-gradient-sky { background: linear-gradient(135deg, #0284c7 0%, #0369a1 100%) !important; }
    
    /* Apply theme colors to Bootstrap elements */
    body { background-color: var(--bg); color: var(--fg); overflow: hidden; }
    .navbar { background-color: var(--fg) !important; border-bottom: none !important; box-shadow: var(--shadow-md) !important; }
    .navbar-brand { cursor: pointer; color: var(--bg) !important; font-weight: 600; letter-spacing: 0px; }
    .navbar-toggler-icon { 
      filter: invert(1);
      background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 30 30'%3e%3cpath stroke='rgba%2896, 165, 250, 0.9%29' stroke-linecap='round' stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/%3e%3c/svg%3e");
    }
    
    .btn-outline-secondary { border-color: var(--border) !important; color: var(--fg) !important; }
    .btn-outline-secondary:hover { background-color: var(--accent-light) !important; border-color: var(--accent) !important; color: var(--accent) !important; }
    
    /* Sidebar - Modern Design */
    nav.sidebar { 
      background: linear-gradient(180deg, #f3f4f6 0%, #e5e7eb 100%); 
      border-right: 1px solid rgba(0, 0, 0, 0.05) !important;  
      overflow-y: auto; 
      box-shadow: 4px 0 16px rgba(0, 0, 0, 0.06);
      padding-top: 0;
    }
    
    .menu-header {  
      background: linear-gradient(135deg, rgba(0, 0, 0, 0.15), rgba(0, 0, 0, 0.1) 100%);
      font-weight: bold; 
      padding: 1.25rem 1.25rem; 
      letter-spacing: 0px; 
      font-size: 1.1rem;
      position: relative;
      overflow: hidden;
      border: none;
      border-bottom: 2px solid #a5aab3;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.12);
      color: #0c346c;
      text-shadow: none;
      margin: 0;
      text-transform: none;
    }
    .menu-header::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.15), transparent);
      transition: left 0.6s ease;
    }
    .menu-header:hover::before {
      left: 100%;
    }
    .menu-header::after {
      content: 'üìã';
      position: absolute;
      right: 1.5rem;
      top: 50%;
      transform: translateY(-50%);
      font-size: 1.3rem;
      opacity: 0.9;
      filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.2));
    }
    
    .toc { 
      list-style: none; 
      padding: 0rem 0; 
      margin: 0; 
      background: transparent;
    }
    .toc li { 
      margin: 0; 
    }
    
    /* Section grouping */
    .toc li[data-group="overview"] { margin-bottom: 0.75rem; }
    .toc li[data-group="solid"]:first-of-type { 
      margin-top: 1rem; 
      border-top: 2px solid rgba(59, 130, 246, 0.15);
      padding-top: 1rem;
    }
    .toc li[data-group="other-principles"]:first-of-type { 
      margin-top: 1rem; 
      border-top: 2px solid rgba(16, 185, 129, 0.15);
      padding-top: 1rem;
    }
    .toc li[data-group="resources"] { 
      margin-top: 1rem; 
      border-top: 2px solid rgba(100, 116, 139, 0.15);
      padding-top: 1rem;
    }
    
    .list-group-item { 
      background: transparent; 
      border-color: transparent; 
      padding: 0; 
      margin: 0.25rem 0.75rem; 
      border-radius: 0rem;
      transition: all 0.2s ease;
    }
    .list-group-item a { 
      color: #1f2937; 
      text-decoration: none; 
      display: flex; 
      flex-direction: column; 
      align-items: flex-start; 
      gap: 0.4rem; 
      border-left: 3px solid transparent; 
      padding: 0.85rem 1.25rem; 
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); 
      font-weight: 500; 
      border-radius: 0rem;
      font-size: 0.95rem;
      position: relative;
      overflow: hidden;
      background: linear-gradient(90deg, rgba(255, 255, 255, 0.4) 0%, rgba(255, 255, 255, 0.1) 100%);
      border: 1px solid rgba(0, 0, 0, 0.06);
      -webkit-backdrop-filter: blur(10px);
      backdrop-filter: blur(10px);
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
    }
    .list-group-item a::before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      width: 4px;
      background: linear-gradient(180deg, #3b82f6 0%, #2563eb 100%);
      transform: scaleY(0);
      transition: transform 0.3s ease;
      border-radius: 0 0px 0px 0;
    }
    .list-group-item a::after {
      content: '‚ñ∂';
      position: absolute;
      right: 1rem;
      top: 50%;
      transform: translateY(-50%) scale(0.7);
      font-size: 0.7rem;
      color: #9ca3af;
      opacity: 0;
      transition: all 0.3s ease;
    }
    .list-group-item a:hover { 
      background: linear-gradient(90deg, rgba(59, 130, 246, 0.15) 0%, rgba(59, 130, 246, 0.08) 100%); 
      border-left-color: transparent;
      color: #1e40af;
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.2), 0 2px 4px rgba(0, 0, 0, 0.08);
      border-color: rgba(59, 130, 246, 0.2);
      text-decoration: none;
    }
    .list-group-item a:hover::before {
      transform: scaleY(1);
    }
    .list-group-item a:hover::after {
      opacity: 1;
      transform: translateY(-50%) scale(1);
      color: #3b82f6;
    }
    .list-group-item a.active { 
      background: linear-gradient(90deg, rgba(59, 130, 246, 0.22) 0%, rgba(59, 130, 246, 0.12) 100%); 
      color: #1e40af; 
      font-weight: 600; 
      border-left-color: transparent;
      box-shadow: 0 4px 16px rgba(59, 130, 246, 0.25), inset 0 1px 0 rgba(255, 255, 255, 0.3);
      border-color: rgba(59, 130, 246, 0.3);
    }
    .list-group-item a.active::before {
      transform: scaleY(1);
      background: linear-gradient(180deg, #3b82f6 0%, #2563eb 100%);
      width: 5px;
      box-shadow: 0 0 8px rgba(59, 130, 246, 0.5);
    }
    .list-group-item a.active::after {
      opacity: 1;
      color: #2563eb;
      transform: translateY(-50%) scale(1);
    }
    .list-group-item a.active:hover { 
      background: linear-gradient(90deg, rgba(59, 130, 246, 0.28) 0%, rgba(59, 130, 246, 0.16) 100%); 
      box-shadow: 0 6px 20px rgba(59, 130, 246, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.4);
    }
    
    /* Sub-items tree connectors */
    .list-group-sub-item a::before { 
      content: '‚îú‚îÄ';
      font-size: 0.85rem;
      margin-right: 0.5rem;
      color: #6b7280;
      z-index: 1;
      position: relative;
    }
    
    /* Sub-items styling - similar to main items but smaller and indented */
    .list-group-sub-item {
      background: transparent; 
      border-color: transparent; 
      padding: 0px; 
      margin: 0.2rem 0.75rem 0.2rem 1.5rem;
      border-radius: 0rem;
      transition: all 0.2s ease;
      position: relative;
      list-style-type: none;
    }
    .list-group-sub-item::before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      width: 4px;
      background: linear-gradient(180deg, #3b82f6 0%, #2563eb 100%);
      transform: scaleY(0);
      transition: transform 0.3s ease;
      border-radius: 0 0px 0px 0;
      z-index: 1;
    }
    .list-group-sub-item a {
      color: #1f2937; 
      text-decoration: none; 
      display: block;
      border-left: 3px solid transparent; 
      padding: 0.65rem 1rem 0.65rem 2.00rem;
      transition: all 0.2s ease; 
      font-weight: 500; 
      border-radius: 0rem;
      font-size: 0.8125rem;
      line-height: 1.4;
      position: relative;
      overflow: hidden;
      background: rgba(255, 255, 255, 0.5);
      border: 1px solid rgba(0, 0, 0, 0.04);
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.04);
    }
    
    /* Sub-items hover and active states - same as main items */
    .list-group-sub-item a::after {
      content: '‚ñ∂';
      position: absolute;
      right: 1rem;
      top: 50%;
      transform: translateY(-50%) scale(0.7);
      font-size: 0.7rem;
      color: #9ca3af;
      opacity: 0;
      transition: all 0.3s ease;
    }
    
    .list-group-sub-item:hover::before {
      transform: scaleY(1);
    }
    .list-group-sub-item a:hover { 
      background: linear-gradient(90deg, rgba(59, 130, 246, 0.15) 0%, rgba(59, 130, 246, 0.08) 100%); 
      border-left-color: transparent;
      color: #1e40af;
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.2), 0 2px 4px rgba(0, 0, 0, 0.08);
      border-color: rgba(59, 130, 246, 0.2);
      text-decoration: none;
    }
    .list-group-sub-item a:hover::after {
      opacity: 1;
      transform: translateY(-50%) scale(1);
      color: #3b82f6;
    }
    
    .list-group-sub-item.active::before {
      transform: scaleY(1);
      width: 5px;
      box-shadow: 0 0 8px rgba(59, 130, 246, 0.5);
    }
    .list-group-sub-item a.active { 
      background: linear-gradient(90deg, rgba(59, 130, 246, 0.22) 0%, rgba(59, 130, 246, 0.12) 100%); 
      color: #1e40af; 
      font-weight: 600; 
      border-left-color: transparent;
      box-shadow: 0 4px 16px rgba(59, 130, 246, 0.25), inset 0 1px 0 rgba(255, 255, 255, 0.3);
      border-color: rgba(59, 130, 246, 0.3);
    }
    .list-group-sub-item a.active::after {
      opacity: 1;
      color: #2563eb;
      transform: translateY(-50%) scale(1);
    }
    .list-group-sub-item a.active:hover { 
      background: linear-gradient(90deg, rgba(59, 130, 246, 0.28) 0%, rgba(59, 130, 246, 0.16) 100%); 
      box-shadow: 0 6px 20px rgba(59, 130, 246, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.4);
    }
    
    .list-group-item a::after {
      content: '‚ñ∂';
      position: absolute;
      right: 1rem;
      top: 50%;
      transform: translateY(-50%) scale(0.7);
      font-size: 0.7rem;
      color: #9ca3af;
      opacity: 0;
      transition: all 0.3s ease;
    }
    
    .list-group-item a:hover { 
      background: linear-gradient(90deg, rgba(59, 130, 246, 0.15) 0%, rgba(59, 130, 246, 0.08) 100%); 
      border-left-color: transparent;
      color: #1e40af;
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.2), 0 2px 4px rgba(0, 0, 0, 0.08);
      border-color: rgba(59, 130, 246, 0.2);
      text-decoration: none;
    }
    .list-group-item a:hover::before {
      transform: scaleY(1);
    }
    .list-group-item a:hover::after {
      opacity: 1;
      transform: translateY(-50%) scale(1);
      color: #3b82f6;
    }
    .list-group-item a.active { 
      background: linear-gradient(90deg, rgba(59, 130, 246, 0.22) 0%, rgba(59, 130, 246, 0.12) 100%); 
      color: #1e40af; 
      font-weight: 600; 
      border-left-color: transparent;
      box-shadow: 0 4px 16px rgba(59, 130, 246, 0.25), inset 0 1px 0 rgba(255, 255, 255, 0.3);
      border-color: rgba(59, 130, 246, 0.3);
    }
    .list-group-item a.active::after {
      opacity: 1;
      color: #2563eb;
      transform: translateY(-50%) scale(1);
    }
    .list-group-item a.active:hover { 
      background: linear-gradient(90deg, rgba(59, 130, 246, 0.28) 0%, rgba(59, 130, 246, 0.16) 100%); 
      box-shadow: 0 6px 20px rgba(59, 130, 246, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.4);
    }
    
    /* Badge styling */
    .badge { font-size: 0.8rem; padding: 0.15rem 0.4rem; background: var(--accent-light); color: var(--accent); border: 1px solid var(--accent); font-weight: 600; border-radius: 0.25rem; font-style: normal; line-height: 1.2; opacity: 0.9; }
    .badge { background: var(--accent); color: white; border: none; font-size: 0.6rem; padding: 0.25rem 0.5rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; display: inline-block; margin-top: 0.5rem; margin-right: 0.35rem; }
    .list-group-item a:hover .badge { opacity: 1; background: var(--accent); color: white; }
    .list-group-item a.active .badge { background: rgba(255, 255, 255, 0.3); color: white; border-color: rgba(255, 255, 255, 0.6); font-weight: 600; opacity: 1; }
        
    /* Content */
    .content { width: 100%; max-width: 100%; margin: 0 auto; background: #ffffff; padding: 2rem; border-radius: 0.75rem; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08); }
    section { display: none !important; margin-bottom: 2rem; }
    section.active { display: block !important; }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    
    h1 { font-size: 2rem; font-weight: 700; margin: 1rem 0 0.25rem 0; letter-spacing: -0.5px; color: var(--fg); display: block; border: none; }
    h2 { font-size: 1.5rem; font-weight: 600; margin: 1.5rem 0 0.75rem 0; color: var(--fg); border-bottom: 2px solid var(--accent-light); padding-bottom: 0.5rem; }
    h3 { font-size: 1.1rem; color: var(--accent); font-weight: 600; margin: 1rem 0 0.5rem 0; }
    h4 { font-size: 0.8rem; color: var(--fg); font-weight: 600; margin: 0.75rem 0 0.4rem 0; }
    p { margin: 1rem 0; line-height: 1.65; color: var(--fg); }
    ul, ol { margin: 1rem 0; padding-left: 2rem; }
    li { margin: 0.5rem 0; color: var(--fg); }
    
    code { background: var(--code-bg); border: 1px solid var(--border); padding: 0.2rem 0.5rem; font-family: ui-monospace, 'Cascadia Code', 'Source Code Pro', monospace; font-size: 0.9em; color: var(--accent); border-radius: 0.5rem; }
    pre { background: var(--code-bg); border: 0px solid var(--border); padding: 1rem; border-radius: 0.5rem; overflow: auto; box-shadow: var(--shadow-sm); margin: 1rem 0; }
    pre code { padding: 0; background: transparent; border: none; color: var(--fg); }
    
    .callout { border-left: 5px solid var(--accent); background: var(--accent-light); padding: 1rem 1.2rem; margin: 1.5rem 0; border-radius: 0.5rem; box-shadow: var(--shadow-sm); font-weight: 500; color: var(--fg); }
    
    /* Table styling */
    .table { color: var(--fg); }
    .table thead th { background: var(--accent-light); color: var(--accent); border-color: var(--border); font-weight: 600; }
    .table tbody td { border-color: var(--border); }
    .table-striped tbody tr:nth-of-type(odd) { background-color: rgba(0,0,0,0.02); }
    .table-striped tbody tr:hover { background-color: var(--accent-light); }
    
    /* Controls/Pagination */
    .controls { opacity: 0.5; position: fixed; bottom: 0.25rem; right: 1rem; width: auto; z-index: 1000; background: transparent; display: flex; align-items: center; justify-content: center; gap: 0rem; padding: 0; min-height: 40px; }
    @media (max-width: 991px) {
      .controls { bottom: 0.25rem; right: 1rem; }
      .menu-header { color: var(--focus); }
    }
    .controls:hover { opacity: 1; }
    
    .page-indicator { color: var(--accent); font-weight: 600; font-size: 0.875rem; }
    .btn-group .btn { margin: 0px 2px; padding: 0.2rem 0.5rem; background: var(--accent); color: white; border-color: var(--accent); font-size: 1rem; font-weight: bold; }
    .btn-group .btn:hover { background: var(--accent); }
    .btn-group .btn + .btn { margin-left: -1px; }
    
    /* Mobile/Offcanvas */
    .offcanvas { background: var(--bg) !important; }
    .offcanvas-header { border-bottom: 1px solid var(--border); }
    .offcanvas-title { color: var(--fg); font-weight: 600; }
    .btn-close { color: var(--fg); }
    
    /* Scrollbar */
    nav.sidebar::-webkit-scrollbar { width: 6px; }
    nav.sidebar::-webkit-scrollbar-track { background: rgba(0, 0, 0, 0.05); }
    nav.sidebar::-webkit-scrollbar-thumb { background: rgba(0, 0, 0, 0.2); border-radius: 0px; }
    nav.sidebar::-webkit-scrollbar-thumb:hover { background: rgba(0, 0, 0, 0.3); }
    
    /* Mermaid Diagrams */
    .mermaid {
      background: #ffffff;
      border: 1px solid #e2e8f0;
      border-radius: 0.5rem;
      padding: 2rem;
      margin: 1.5rem 0;
      min-height: 400px;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: visible;
      position: relative;
    }
    .mermaid.rendered {
      min-height: 0;
    }
    .mermaid svg {
      max-width: 100%;
      height: auto;
      min-height: 300px;
      transition: transform 0.3s ease;
      transform-origin: center center;
    }
    .mermaid.zoomed {
      overflow: auto;
      cursor: grab;
    }
    .mermaid.zoomed:active {
      cursor: grabbing;
    }
    .mermaid svg text {
      font-size: 14px !important;
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif !important;
    }
    
    /* Mermaid title styling */
    .mermaid svg text, .diagram-modal-content svg text {
      font-size: 1rem !important;
      font-weight: bold !important;
      fill: var(--fg) !important;
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif !important;
    }

    .mermaid svg *
    {
        color: #333;
    }

    .mermaid[data-processed="true"] {
      min-height: 0;
    }
    
    .mermaid svg {
      max-width: 100%;
      height: auto;
      display: inline-block;
    }
    
    /* Zoom controls */
    .zoom-controls {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 10;
      opacity: 0.5;
      transition: opacity 0.3s ease;
    }
    .mermaid:hover .zoom-controls {
      opacity: 1;
    }
    .zoom-btn {
      background: var(--accent);
      color: white;
      border: none;
      border-radius: 0.25rem;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 16px;
      font-weight: bold;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      transition: all 0.2s ease;
    }
    .zoom-btn:hover {
      background: #2563eb;
      transform: scale(1.1);
    }

    /* Modal for diagram zoom */
    .diagram-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.95);
      z-index: 9999;
      align-items: center;
      justify-content: center;
      padding: 0;
    }
    .diagram-modal.active {
      display: flex;
    }
    .diagram-modal-content {
      position: relative;
      width: 100%;
      height: 100%;
      background: white;
      border-radius: 0;
      padding: 3rem 3rem 3rem 3rem;
      overflow: auto;
      display: flex;
      align-items: flex-start;
      justify-content: center;
    }
    .diagram-modal-content svg {
      max-width: 100%;
      height: auto;
    }
    .modal-close {
      position: fixed;
      top: 1.5rem;
      right: 1.5rem;
      background: #ef4444;
      color: white;
      border: none;
      border-radius: 50%;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 16px;
      font-weight: bold;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
      transition: all 0.2s ease;
      z-index: 10000;
    }
    .modal-close:hover {
      background: #dc2626;
      transform: scale(1.1);
    }
    .modal-zoom-controls {
      position: fixed;
      bottom: 1.5rem;
      right: 1.5rem;
      display: flex;
      gap: 0.5rem;
      z-index: 10000;
      padding: 0rem;
      border-radius: 0.4rem;
    }
    .modal-zoom-btn {
      background: var(--accent);
      color: white;
      border: none;
      border-radius: 0.25rem;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 16px;
      font-weight: bold;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      transition: all 0.2s ease;
    }
    .modal-zoom-btn:hover {
      background: #2563eb;
      transform: scale(1.1);
    }
    
    /* Utilities */
    .search { height: 0; overflow: hidden; padding: 0 !important; }
    .search input { display: none; }
    .min-vh-100 { min-height: 100vh; }
    .skip-link { position: absolute; left: -9999px; top: auto; width: 1px; height: 1px; overflow: hidden; }
    .skip-link:focus { position: static; width: auto; height: auto; padding: 0.4rem 0.6rem; background: var(--accent); color: white; border-radius: 0.4rem; }
    
    /* Override Bootstrap defaults for theme */
    a { color: var(--accent); }
    a:hover { color: var(--accent); text-decoration: underline; }
    
    /* Responsive - keep sidebar visible on desktop, offcanvas on mobile */
    @media (max-width: 991px) {
      nav.sidebar { display: none; }
      #main { width: 100%; }
      .row { --bs-gutter-x: 0; }
    }
    
    /* Layout - prevent unnecessary scrolling */
    html, body { height: 100%; margin: 0; }
    #appContainer { display: flex; flex-direction: column; height: calc(100vh - 50px); }
    #mainRow { flex: 1; overflow: hidden; display: flex; }
    nav.sidebar { overflow-y: auto; max-height: 100%; position: relative; padding-bottom: 0px; }
    #main { overflow: hidden; display: flex; flex-direction: column; height: 100%; -webkit-tap-highlight-color: transparent; outline: none; border: none; }
    #main:focus { outline: none; }
    .content { overflow-y: auto; flex: 1; width: 100%; min-height: 0; padding: 0rem 1.5rem 0rem 1.5rem; }
    
    /* Contact Info */
    .contact-info {
      font-weight: 400 !important;
      padding: 0.5rem 0.75rem;
      font-size: 0.75rem;
      color: var(--accent-light);
      margin: 0;
      opacity: 0.5;
      white-space: nowrap;
      cursor: pointer;
    }
    .contact-info:hover {
      opacity: 0.9;
      text-decoration: none;
    }
    @media (max-width: 991px) {
      .navbar-brand {
        font-size: 1rem !important;
        flex: 1;
      }
      .contact-info {
        font-size: 0.7rem;
        padding: 0.25rem 0.5rem;
      }
    }
    @media (max-width: 576px) {
      .navbar-brand {
        font-size: 0.9rem !important;
      }
      .contact-info {
        font-size: 0.65rem;
        padding: 0.2rem 0.4rem;
      }
    }

    .list-style-none {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    /* JSON Syntax Highlighting */
    pre code.language-json {
      display: block;
      white-space: pre;
      font-family: 'Cascadia Code', 'Consolas', 'Monaco', 'Courier New', monospace;
    }

    pre code.language-json .json-key {
      color: #0451a5;
      font-weight: 500;
    }

    pre code.language-json .json-string {
      color: #a31515;
    }

    pre code.language-json .json-number {
      color: #098658;
    }

    pre code.language-json .json-boolean {
      color: #0000ff;
      font-weight: 600;
    }

    pre code.language-json .json-null {
      color: #0000ff;
      font-weight: 600;
    }

    pre code.language-json .json-punctuation {
      color: #333;
    }

    /* SQL Syntax Highlighting */
    pre code.language-sql {
      display: block;
      white-space: pre;
      font-family: 'Cascadia Code', 'Consolas', 'Monaco', 'Courier New', monospace;
    }

    pre code.language-sql .sql-keyword {
      color: #0000ff;
      font-weight: 600;
      text-transform: uppercase;
    }

    pre code.language-sql .sql-string {
      color: #a31515;
    }

    pre code.language-sql .sql-number {
      color: #098658;
    }

    pre code.language-sql .sql-comment {
      color: #008000;
      font-style: italic;
    }

    pre code.language-sql .sql-function {
      color: #795e26;
      font-weight: 500;
    }

    pre code.language-sql .sql-operator {
      color: #666;
      font-weight: 500;
    }

    /* Language Label for Code Blocks */
    pre[data-language]::before {
      content: attr(data-language);
      position: absolute;
      top: 8px;
      right: 12px;
      font-size: 0.75em;
      color: #6a737d;
      text-transform: uppercase;
      font-weight: 600;
      letter-spacing: 0.5px;
      background: var(--bg);
      padding: 0.2rem 0.5rem;
      border-radius: 0.25rem;
      border: 1px solid var(--border);
    }

    /* Enhanced pre/code styling for syntax highlighted blocks */
    pre.syntax-highlighted {
      position: relative;
      background: var(--code-bg);
      border: 1px solid var(--border);
      padding: 1.5rem 1rem 1rem 1rem;
      border-radius: 0.5rem;
      overflow-x: auto;
      box-shadow: var(--shadow-sm);
      margin: 1rem 0;
    }

    pre.syntax-highlighted code {
      background: transparent;
      padding: 0;
      border: none;
      color: var(--fg);
      font-size: 0.875rem;
      line-height: 1.6;
    }

    ul
    {
        list-style-type: none;
    }
  /* Document Footer */
    .document-footer {
      text-align: center;
      padding: 20px;
      background-color: #f8f9fa;
      border-radius: 8px;
      margin-top: 20px;
    }
    .document-footer p {
      margin: 0;
      font-size: 14px;
      color: #6c757d;
      line-height: 1.6;
    }
    .document-footer strong {
      color: #495057;
    }

    /* Collapsible Code Block Styles */
    .code-block-container {
      position: relative;
      margin: 1rem 0;
      border: 1px solid var(--border);
      border-radius: 0.5rem;
      overflow: hidden;
      background: var(--code-bg);
      box-shadow: var(--shadow-sm);
    }

    .code-block-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 0.75rem 1rem;
      background: linear-gradient(135deg, rgba(59, 130, 246, 0.1) 0%, rgba(59, 130, 246, 0.05) 100%);
      border-bottom: 1px solid var(--border);
      cursor: pointer;
      user-select: none;
      transition: background 0.2s ease;
    }

    .code-block-header:hover {
      background: linear-gradient(135deg, rgba(59, 130, 246, 0.15) 0%, rgba(59, 130, 246, 0.08) 100%);
    }

    .code-block-title {
      font-size: 0.875rem;
      font-weight: 600;
      color: var(--accent);
      display: flex;
      align-items: center;
      gap: 0.5rem;
    }

    .code-block-toggle {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      font-size: 0.75rem;
      color: var(--muted);
      font-weight: 500;
    }

    .code-block-toggle-icon {
      width: 20px;
      height: 20px;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--accent);
      color: white;
      border-radius: 0.25rem;
      font-size: 14px;
      transition: transform 0.3s ease;
    }

    .code-block-container.collapsed .code-block-toggle-icon {
      transform: rotate(-90deg);
    }

    .code-block-content {
      max-height: 0;
      overflow: hidden;
      transition: max-height 0.3s ease;
    }

    .code-block-container:not(.collapsed) .code-block-content {
      max-height: 5000px;
    }

    .code-block-container pre {
      margin: 0;
      border: none;
      border-radius: 0;
    }

    .code-block-container pre code {
      display: block;
      padding: 1rem;
    }
  </style>
  <!-- Mermaid.js for diagrams -->
  <script src="https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.min.js"></script>
  <script>
    // Initialize Mermaid with proper configuration
    document.addEventListener('DOMContentLoaded', function() {

      mermaid.initialize({
        startOnLoad: false,
        theme: 'base',
        securityLevel: 'loose',
        logLevel: 'error',
        fontFamily: 'Segoe UI Semibold',
        flowchart: {
          useMaxWidth: true,
          htmlLabels: true,
          curve: 'basis',
        },
        sequence: {
          useMaxWidth: false,
          htmlLabels: true,
          diagramMarginX: 50,
          diagramMarginY: 10
        }
      });
      
      // Render all diagrams
      renderMermaidDiagrams();
    });
    
    async function renderMermaidDiagrams() {
      const diagrams = document.querySelectorAll('.mermaid');
      
      for (let i = 0; i < diagrams.length; i++) {
        const diagram = diagrams[i];
        const code = diagram.textContent.trim();
        
        // Store original code
        if (!diagram.hasAttribute('data-original-code')) {
          diagram.setAttribute('data-original-code', code);
        }
        
        try {
          const { svg } = await mermaid.render('mermaid-diagram-' + i, code);
          diagram.innerHTML = svg;
          diagram.setAttribute('data-processed', 'true');
          
          // Add zoom controls
          addZoomControls(diagram);
        } catch (error) {
          console.error('Mermaid rendering error for diagram ' + i + ':', error);
          diagram.innerHTML = '<div class="text-danger p-3 border border-danger border-2 rounded">Error rendering diagram: ' + error.message + '</div>';
        }
      }
    }
    
    // Add zoom controls to mermaid diagrams
    function addZoomControls(diagram) {
      const controls = document.createElement('div');
      controls.className = 'zoom-controls';
      controls.innerHTML = `
        <button class="zoom-btn" data-action="expand" title="Expand View">‚õ∂</button>
      `;
      
      diagram.style.position = 'relative';
      diagram.insertBefore(controls, diagram.firstChild);
      
      // Expand to modal
      controls.addEventListener('click', (e) => {
        const btn = e.target.closest('.zoom-btn');
        if (!btn) return;
        
        openDiagramModal(diagram);
      });
    }

    // Open diagram in modal
    function openDiagramModal(diagram) {
      // Create modal if it doesn't exist
      let modal = document.getElementById('diagram-modal');
      if (!modal) {
        modal = document.createElement('div');
        modal.id = 'diagram-modal';
        modal.className = 'diagram-modal';
        modal.innerHTML = `
          <button class="modal-close" id="modal-close">√ó</button>
          <div class="diagram-modal-content" id="modal-diagram-content"></div>
          <div class="modal-zoom-controls">
            <button class="modal-zoom-btn" data-action="zoom-in" title="Zoom In">+</button>
            <button class="modal-zoom-btn" data-action="zoom-out" title="Zoom Out">‚àí</button>
            <button class="modal-zoom-btn" data-action="reset" title="Reset Zoom">‚ü≤</button>
          </div>
        `;
        document.body.appendChild(modal);
        
        // Close modal handlers
        modal.querySelector('#modal-close').addEventListener('click', closeDiagramModal);
        modal.addEventListener('click', (e) => {
          if (e.target === modal) closeDiagramModal();
        });
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape' && modal.classList.contains('active')) {
            closeDiagramModal();
          }
        });
        
        // Zoom controls in modal
        let scale = 1;
        let translateX = 0;
        let translateY = 0;
        
        modal.querySelector('.modal-zoom-controls').addEventListener('click', (e) => {
          const btn = e.target.closest('.modal-zoom-btn');
          if (!btn) return;
          
          const action = btn.dataset.action;
          const svg = modal.querySelector('svg');
          if (!svg) return;
          
          if (action === 'zoom-in') {
            scale = Math.min(scale + 0.1, 5);
          } else if (action === 'zoom-out') {
            scale = Math.max(scale - 0.1, 0.5);
          } else if (action === 'reset') {
            scale = 1;
            translateX = 0;
            translateY = 0;
          }
          
          svg.style.transform = `scale(${scale}) translate(${translateX / scale}px, ${translateY / scale}px)`;
        });
      }
      
      // Clone diagram content
      const svg = diagram.querySelector('svg');
      if (svg) {
        const content = modal.querySelector('#modal-diagram-content');
        content.innerHTML = '';
        const clonedSvg = svg.cloneNode(true);
        clonedSvg.style.transform = 'scale(1)';
        clonedSvg.style.maxWidth = '100%';
        clonedSvg.style.height = 'auto';
        content.appendChild(clonedSvg);
      }
      
      modal.classList.add('active');
      document.body.style.overflow = 'hidden';
    }

    function closeDiagramModal() {
      const modal = document.getElementById('diagram-modal');
      if (modal) {
        modal.classList.remove('active');
        document.body.style.overflow = '';
      }
    }
    
    // Re-render on theme change
    window.rerenderMermaid = async function() {
      const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
      
      mermaid.initialize({
        startOnLoad: false,
        theme: isDark ? 'base' : 'base',
        securityLevel: 'loose',
        flowchart: {
          useMaxWidth: true,
          htmlLabels: true,
          curve: 'basis',
        },
        sequence: {
          useMaxWidth: false,
          htmlLabels: true,
          diagramMarginX: 50,
          diagramMarginY: 10
        }
      });
      
      const diagrams = document.querySelectorAll('.mermaid[data-processed="true"]');
      for (let i = 0; i < diagrams.length; i++) {
        const diagram = diagrams[i];
        const code = diagram.getAttribute('data-original-code');
        
        if (code) {
          try {
            const { svg } = await mermaid.render('mermaid-diagram-rerender-' + i + '-' + Date.now(), code);
            diagram.innerHTML = svg;
          } catch (error) {
            console.error('Mermaid re-rendering error:', error);
          }
        }
      }
    };

    // Make all code blocks collapsible
    function initializeCollapsibleCodeBlocks() {
      // Find all pre>code blocks that aren't already wrapped
      const codeBlocks = document.querySelectorAll('pre:has(code):not(.wrapped)');
      
      codeBlocks.forEach((pre, index) => {
        // Mark as wrapped to avoid double-wrapping
        pre.classList.add('wrapped');
        
        // Detect language from code class or pre data attribute
        const code = pre.querySelector('code');
        let language = 'Code';
        
        if (code.className) {
          const match = code.className.match(/language-(\w+)/);
          if (match) language = match[1].toUpperCase();
        } else if (pre.dataset.language) {
          language = pre.dataset.language.toUpperCase();
        } else {
          // Try to detect from content
          const content = code.textContent.trim();
          if (content.startsWith('---\n') || (content.includes('---\n') && content.includes('name:') && content.includes('description:'))) {
            language = 'Markdown';
          } else if (content.includes('name:') && content.includes('description:') && (content.includes('user-invokable:') || content.includes('model:'))) {
            language = 'YAML';
          } else if (content.startsWith('# ') || content.includes('\n## ') || content.includes('\n### ')) {
            language = 'Markdown';
          } else if (content.includes('```') || content.includes('**') || content.includes('##')) {
            language = 'Markdown';
          } else if (content.startsWith('{') || content.startsWith('[')) {
            language = 'JSON';
          } else if (content.includes('SELECT') || content.includes('FROM') || content.includes('CREATE TABLE')) {
            language = 'SQL';
          } else if (content.includes('function') && content.includes('{') && content.includes('}')) {
            language = 'JavaScript';
          } else if (content.includes('=>') || content.includes('const ') || content.includes('let ')) {
            language = 'JavaScript';
          } else if (content.includes('interface ') && content.includes(':')) {
            language = 'TypeScript';
          } else if (content.includes('class') && content.includes('public') && content.includes(';')) {
            language = 'C#';
          } else if (content.includes('namespace') || content.includes('using ')) {
            language = 'C#';
          } else if (content.includes('def ') || content.includes('import ') || content.includes('class ') && content.includes(':')) {
            language = 'Python';
          } else if (content.includes('FROM ') && content.includes('AS ')) {
            language = 'Dockerfile';
          } else if (content.includes('services:') || content.includes('version:') && content.includes('volumes:')) {
            language = 'YAML';
          } else if (content.includes('<') && content.includes('>') && content.includes('</')) {
            language = 'HTML/XML';
          } else if (content.includes('server {') || content.includes('location ')) {
            language = 'Nginx';
          } else if (content.startsWith('#!/bin/bash') || content.startsWith('#!/bin/sh')) {
            language = 'Bash';
          }
        }
        
        // Create wrapper
        const container = document.createElement('div');
        container.className = 'code-block-container collapsed';
        
        // Create header
        const header = document.createElement('div');
        header.className = 'code-block-header';
        
        const title = document.createElement('div');
        title.className = 'code-block-title';
        title.innerHTML = `<span>üìù</span> ${language} Example`;
        
        const toggle = document.createElement('div');
        toggle.className = 'code-block-toggle';
        toggle.innerHTML = `
          <span class="toggle-text">Click to expand</span>
          <span class="code-block-toggle-icon">‚ñº</span>
        `;
        
        header.appendChild(title);
        header.appendChild(toggle);
        
        // Create content wrapper
        const content = document.createElement('div');
        content.className = 'code-block-content';
        
        // Wrap the pre element
        pre.parentNode.insertBefore(container, pre);
        container.appendChild(header);
        container.appendChild(content);
        content.appendChild(pre);
        
        // Add click handler to toggle
        header.addEventListener('click', () => {
          const isCollapsed = container.classList.toggle('collapsed');
          const toggleText = toggle.querySelector('.toggle-text');
          toggleText.textContent = isCollapsed ? 'Click to expand' : 'Click to collapse';
        });
      });
    }

    // Initialize collapsible code blocks after DOM is ready
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeCollapsibleCodeBlocks);
    } else {
      initializeCollapsibleCodeBlocks();
    }
  </script>
</head>
<body>
  <nav class="navbar navbar-expand-lg sticky-top" aria-label="Top bar">
    <div class="container-fluid d-flex align-items-center">
      <button class="navbar-toggler me-2" id="toggleSidebar" type="button" aria-label="Toggle sidebar">
        <span class="navbar-toggler-icon"></span>
      </button>
      <span class="navbar-brand mb-0 h1 me-auto">ü§ñ GitHub Copilot Agents - In a Nutshell</span>
      <span class="contact-info mb-0">ü§ù Curated by Murthy Vepa</span>
    </div>      
  </nav>

  <div id="appContainer">
    <div class="row g-0" id="mainRow">
      <nav class="col-lg-3 border-end sidebar" id="sidebar" aria-label="Table of contents">
        <div class="menu-header py-2">Contents</div>
        <ul class="list-group list-group-flush toc" id="toc"></ul>
      </nav>

      <main id="main" class="col-lg-9 d-flex flex-column" tabindex="-1">
        <div class="content" id="content">
        
        <!-- Overview Section -->
        <section id="agents-overview" role="article">
          <h1>üìñ Overview</h1>
          <span class="badge">intro</span>
          <span class="badge">overview</span>
          <span class="badge">agents</span>
          
          <p><strong>GitHub Copilot Agents</strong> are specialized AI assistants that extend GitHub Copilot's capabilities beyond code completion. They provide context-aware assistance for specific tasks, domains, and workflows within VS Code.</p>
          
          <div class="callout">
            <strong>üí° What are Agents?</strong><br />
            Agents are AI-powered assistants that can understand your code, workspace context, and intent to help you accomplish complex tasks. Unlike simple code completion, agents can plan, execute multi-step workflows, and interact with your development environment.
          </div>

          <h2>Key Characteristics</h2>
          <ul>
            <li><strong>Context-Aware:</strong> Agents understand your workspace, files, git history, and project structure</li>
            <li><strong>Task-Oriented:</strong> Designed for specific purposes like code review, testing, documentation, or debugging</li>
            <li><strong>Interactive:</strong> Support conversational interactions through the Chat panel</li>
            <li><strong>Tool-Enabled:</strong> Can execute actions like reading files, running commands, and modifying code</li>
            <li><strong>Extensible:</strong> Developers can create custom agents for domain-specific needs</li>
          </ul>

          <h2>Built-in Agents</h2>
          <table class="table table-striped">
            <thead>
              <tr>
                <th>Agent</th>
                <th>Prefix</th>
                <th>Purpose</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>@workspace</strong></td>
                <td>@workspace</td>
                <td>Understands your entire workspace context, files, and structure</td>
              </tr>
              <tr>
                <td><strong>@vscode</strong></td>
                <td>@vscode</td>
                <td>Helps with VS Code commands, settings, and editor operations</td>
              </tr>
              <tr>
                <td><strong>@terminal</strong></td>
                <td>@terminal</td>
                <td>Assists with terminal commands and shell operations</td>
              </tr>
              <tr>
                <td><strong>@github</strong></td>
                <td>@github</td>
                <td>Helps with GitHub operations, issues, PRs, and repositories</td>
              </tr>
            </tbody>
          </table>

          <h2>How to Use Agents</h2>
          <h3>In Chat Panel</h3>
          <pre><code>@workspace how do I implement authentication?
@vscode change theme to dark
@terminal how to list all running processes?</code></pre>

          <h3>Slash Commands</h3>
          <p>Agents support slash commands for specific actions:</p>
          <ul>
            <li><code>/explain</code> - Explain code or concepts</li>
            <li><code>/fix</code> - Suggest fixes for problems</li>
            <li><code>/tests</code> - Generate test cases</li>
            <li><code>/new</code> - Create new files or projects</li>
            <li><code>/newNotebook</code> - Create Jupyter notebooks</li>
          </ul>

          <h2>Benefits</h2>
          <h3>üéØ Specialized Expertise</h3>
          <p>Each agent is optimized for specific tasks, providing more accurate and relevant assistance than a general-purpose AI.</p>

          <h3>üîç Deep Context Understanding</h3>
          <p>Agents have access to your workspace, allowing them to provide context-specific suggestions based on your actual code.</p>

          <h3>‚ö° Streamlined Workflow</h3>
          <p>Reduce context switching by getting help directly in your editor for various development tasks.</p>

          <h3>üîß Extensibility</h3>
          <p>Create custom agents tailored to your team's specific needs, frameworks, or domain knowledge.</p>
        </section>

        <!-- Agent Sessions Section -->
        <section id="agents-sessions" role="article">
          <h1>üîÑ Agent Sessions</h1>
          <span class="badge">sessions</span>
          <span class="badge">lifecycle</span>
          <span class="badge">state</span>
          
          <p>Agent sessions represent the lifecycle and state management of agent interactions within VS Code. Understanding sessions is crucial for building robust and efficient agents.</p>

          <div class="callout">
            <strong>üí° Session Concept</strong><br />
            An agent session is a stateful conversation between you and an agent. It maintains context across multiple exchanges, allowing for coherent multi-turn interactions.
          </div>

          <h2>Session Lifecycle</h2>
          
          <h3>1Ô∏è‚É£ Initialization</h3>
          <ul>
            <li>Session starts when you invoke an agent (e.g., <code>@workspace</code>)</li>
            <li>Agent receives initial context: workspace state, open files, cursor position</li>
            <li>Session ID is created for tracking</li>
          </ul>

          <h3>2Ô∏è‚É£ Active Phase</h3>
          <ul>
            <li>Agent processes requests and maintains conversation history</li>
            <li>Context accumulates with each interaction</li>
            <li>Agent state persists across multiple exchanges</li>
            <li>Tool executions and results are tracked</li>
          </ul>

          <h3>3Ô∏è‚É£ Termination</h3>
          <ul>
            <li>Explicit: User closes chat or starts new session</li>
            <li>Implicit: Timeout after period of inactivity</li>
            <li>Error: Unhandled exception or resource limits</li>
          </ul>

          <h2>Session State Management</h2>
          
          <h3>Context Preservation</h3>
          <p>Sessions maintain:</p>
          <ul>
            <li><strong>Conversation History:</strong> All previous messages and responses</li>
            <li><strong>Workspace State:</strong> File changes, git status, open editors</li>
            <li><strong>User Intent:</strong> Understanding of the current task or goal</li>
            <li><strong>Tool Results:</strong> Outputs from previous tool executions</li>
          </ul>

          <h3>Memory Management</h3>
          <pre><code>// Session memory stores key information
{
  "sessionId": "abc-123-xyz",
  "agent": "@workspace",
  "history": [
    { "role": "user", "content": "How does auth work?" },
    { "role": "assistant", "content": "..." }
  ],
  "context": {
    "workspace": "/path/to/project",
    "activeFiles": ["auth.ts", "login.tsx"],
    "gitBranch": "feature/auth"
  }
}</code></pre>

          <h2>Session Scope</h2>
          
          <table class="table table-striped">
            <thead>
              <tr>
                <th>Scope</th>
                <th>Duration</th>
                <th>Use Case</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Single Request</strong></td>
                <td>One interaction</td>
                <td>Quick questions, simple completions</td>
              </tr>
              <tr>
                <td><strong>Task Session</strong></td>
                <td>Until task complete</td>
                <td>Multi-step workflows, refactoring</td>
              </tr>
              <tr>
                <td><strong>Persistent Session</strong></td>
                <td>Entire coding session</td>
                <td>Ongoing collaboration, complex projects</td>
              </tr>
            </tbody>
          </table>

          <h2>Best Practices</h2>
          
          <h3>‚úÖ Effective Session Management</h3>
          <ul>
            <li>Start new sessions for unrelated tasks to avoid context pollution</li>
            <li>Provide clear context at session start</li>
            <li>Reference previous exchanges when building on earlier discussions</li>
            <li>Close sessions when switching to different work areas</li>
          </ul>

          <h3>‚ö†Ô∏è Avoid</h3>
          <ul>
            <li>Reusing sessions across unrelated projects</li>
            <li>Accumulating too much context (can slow responses)</li>
            <li>Expecting session state to persist indefinitely</li>
          </ul>

          <h2>Session Commands</h2>
          <ul>
            <li><strong>Clear Chat:</strong> Start fresh session while keeping history</li>
            <li><strong>New Chat:</strong> Begin completely new session</li>
            <li><strong>Export Session:</strong> Save conversation for later reference</li>
          </ul>
        </section>

        <!-- Agent Architecture Section -->
        <section id="agent-architecture" role="article">
          <h1>üèóÔ∏è Agent Architecture</h1>
          <span class="badge">architecture</span>
          <span class="badge">design</span>
          <span class="badge">structure</span>
          
          <p>Understanding the architecture of GitHub Copilot agents is essential for building robust, scalable, and maintainable AI-powered development tools. This section covers the core architectural patterns and components.</p>

          <div class="callout">
            <strong>üéØ Foundation for Excellence</strong><br />
            A solid architectural understanding enables you to design agents that are performant, maintainable, and aligned with VS Code's extension model.
          </div>

          <h2>High-Level Architecture</h2>
          
          <div class="mermaid">
%%{ init: { "theme": "base", "fontFamily": "Segoe UI Semibold", "fontSize": "18px" }}%%            
graph TB
    User[üë§ User] -->|Interacts| VSCode[VS Code IDE]
    VSCode -->|Chat Input| ChatAPI[Chat Participant API]
    ChatAPI -->|Requests| Agent[ü§ñ Agent Extension]
    
    Agent -->|Uses| LM[üß† Language Model API]
    Agent -->|Calls| Tools[üõ†Ô∏è Tool Functions]
    Agent -->|Accesses| MCP[üîó MCP Servers]
    Agent -->|Loads| Skills[üéì Skills]
    
    LM -->|Responses| Agent
    Tools -->|Results| Agent
    MCP -->|Data| Agent
    Skills -->|Context| Agent
    
    Agent -->|Stream Response| ChatAPI
    ChatAPI -->|Display| VSCode
    VSCode -->|Shows| User
    
    style Agent fill:#0078d4,color:#fff
    style LM fill:#10a37f,color:#fff
    style Tools fill:#ff6b6b,color:#fff
    style MCP fill:#4ecdc4,color:#fff
    style Skills fill:#ffe66d,color:#000
          </div>

          <h2>Core Components</h2>
          
          <h3>1. Chat Participant (Agent Interface)</h3>
          <p>The entry point for all user interactions with your agent.</p>
          
          <div class="mermaid">
%%{ init: { "theme": "base", "fontFamily": "Segoe UI Semibold", "fontSize": "18px" }}%%
graph LR
    A[Chat Input] --> B[Request Handler]
    B --> C{Route Request}
    C -->|Command| D[Command Handler]
    C -->|Question| E[LLM Handler]
    C -->|Tool Call| F[Tool Executor]
    
    D --> G[Response Builder]
    E --> G
    F --> G
    
    G --> H[Stream to User]
    
    style B fill:#0078d4,color:#fff
    style G fill:#10a37f,color:#fff
          </div>

          <h3>2. Language Model Layer</h3>
          <p>Manages interactions with AI models for intelligent responses.</p>
          
          <div class="mermaid">
%%{ init: { "theme": "base", "fontFamily": "Segoe UI Semibold", "fontSize": "18px" }}%%
graph TB
    Request[Agent Request] --> Router[Model Router]
    Router -->|Simple Query| Fast[GPT-3.5 Turbo]
    Router -->|Complex Task| Power[GPT-4]
    Router -->|Large Context| Long[Claude 3]
    
    Fast --> Proc[Response Processor]
    Power --> Proc
    Long --> Proc
    
    Proc --> Cache{Cache?}
    Cache -->|Hit| Return[Return Cached]
    Cache -->|Miss| Store[Store & Return]
    
    style Router fill:#0078d4,color:#fff
    style Proc fill:#10a37f,color:#fff
          </div>

          <h3>3. Tool System</h3>
          <p>Executable functions that extend agent capabilities.</p>
          
          <div class="mermaid">
%%{ init: { "theme": "base", "fontFamily": "Segoe UI Semibold", "fontSize": "18px" }}%%
graph TB
    Agent[Agent] -->|Discover| Registry[Tool Registry]
    Registry -->|List Tools| Agent
    
    Agent -->|Execute| Validator[Input Validator]
    Validator -->|Valid| Executor[Tool Executor]
    Validator -->|Invalid| Error[Return Error]
    
    Executor -->|Call| FS[File System Tools]
    Executor -->|Call| API[API Tools]
    Executor -->|Call| Code[Code Analysis Tools]
    Executor -->|Call| Custom[Custom Tools]
    
    FS --> Result[Result Aggregator]
    API --> Result
    Code --> Result
    Custom --> Result
    
    Result --> Agent
    
    style Registry fill:#0078d4,color:#fff
    style Executor fill:#10a37f,color:#fff
          </div>

          <h2>Request Processing Flow</h2>
          
          <div class="mermaid">
%%{ init: { "theme": "base", "fontFamily": "Segoe UI Semibold", "fontSize": "18px" }}%%
sequenceDiagram
    participant U as User
    participant VC as VS Code
    participant A as Agent
    participant LM as Language Model
    participant T as Tools
    participant S as State Manager
    
    U->>VC: Type @agent query
    VC->>A: Send ChatRequest
    
    A->>S: Get Session State
    S-->>A: Return Context
    
    A->>A: Parse Request
    
    alt Needs Tool
        A->>T: Execute Tool
        T-->>A: Tool Result
    end
    
    A->>LM: Send Prompt + Context
    
    loop Streaming Response
        LM-->>A: Response Chunk
        A->>VC: Stream Chunk
        VC->>U: Display
    end
    
    A->>S: Update Session State
    
    A->>VC: Complete
    VC->>U: Show Complete
          </div>

          <h2>Agent Extension Structure</h2>
          
          <pre><code>my-agent-extension/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ extension.ts          # Entry point, activation
‚îÇ   ‚îú‚îÄ‚îÄ agent/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ handler.ts        # Main request handler
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ commands.ts       # Slash command implementations
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ tools.ts          # Tool definitions
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ context.ts        # Context gathering
‚îÇ   ‚îú‚îÄ‚îÄ llm/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ client.ts         # LLM client wrapper
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ prompts.ts        # Prompt templates
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ streaming.ts      # Response streaming
‚îÇ   ‚îú‚îÄ‚îÄ state/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ session.ts        # Session state management
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ cache.ts          # Response caching
‚îÇ   ‚îú‚îÄ‚îÄ skills/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ loader.ts         # Skill loading system
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ [domain]/         # Domain-specific skills
‚îÇ   ‚îú‚îÄ‚îÄ mcp/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ client.ts         # MCP client
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ servers/          # Server integrations
‚îÇ   ‚îî‚îÄ‚îÄ utils/
‚îÇ       ‚îú‚îÄ‚îÄ logger.ts         # Logging
‚îÇ       ‚îú‚îÄ‚îÄ validator.ts      # Input validation
‚îÇ       ‚îî‚îÄ‚îÄ errors.ts         # Error handling
‚îú‚îÄ‚îÄ skills/                   # Skill definitions
‚îÇ   ‚îî‚îÄ‚îÄ [domain]/
‚îÇ       ‚îî‚îÄ‚îÄ SKILL.md
‚îú‚îÄ‚îÄ package.json              # Extension manifest
‚îî‚îÄ‚îÄ tsconfig.json             # TypeScript config</code></pre>

          <h2>State Management Architecture</h2>
          
          <div class="mermaid">
%%{ init: { "theme": "base", "fontFamily": "Segoe UI Semibold", "fontSize": "18px" }}%%
graph TB
    subgraph "Session State"
        SS[Session Store]
        SS --> Conv[Conversation History]
        SS --> Meta[Metadata]
        SS --> Ctx[Context Cache]
    end
    
    subgraph "Global State"
        GS[Global Store]
        GS --> Config[Configuration]
        GS --> Auth[Authentication]
        GS --> Metrics[Metrics]
    end
    
    subgraph "Workspace State"
        WS[Workspace Store]
        WS --> Files[File Index]
        WS --> Symbols[Symbol Cache]
        WS --> Deps[Dependencies]
    end
    
    Agent[Agent] --> SS
    Agent --> GS
    Agent --> WS
    
    style SS fill:#0078d4,color:#fff
    style GS fill:#10a37f,color:#fff
    style WS fill:#ff6b6b,color:#fff
          </div>

          <h2>Extension Lifecycle</h2>
          
          <div class="mermaid">
%%{ init: { "theme": "base", "fontFamily": "Segoe UI Semibold", "fontSize": "18px" }}%%
stateDiagram-v2
    [*] --> Inactive
    Inactive --> Activating: VS Code starts/Extension activated
    Activating --> Active: activate() completes
    
    Active --> Processing: User request
    Processing --> Active: Response sent
    
    Active --> Updating: Configuration change
    Updating --> Active: Config applied
    
    Active --> Deactivating: VS Code closes
    Deactivating --> [*]: deactivate() completes
    
    Processing --> Error: Exception
    Error --> Active: Recovery
          </div>

          <h2>Scalability Patterns</h2>
          
          <h3>Async Processing</h3>
          <div class="mermaid">
%%{ init: { "theme": "base", "fontFamily": "Segoe UI Semibold", "fontSize": "18px" }}%%
graph LR
    Request[User Request] --> Queue[Request Queue]
    Queue --> W1[Worker 1]
    Queue --> W2[Worker 2]
    Queue --> W3[Worker 3]
    
    W1 --> Cache[Result Cache]
    W2 --> Cache
    W3 --> Cache
    
    Cache --> Response[Stream Response]
    
    style Queue fill:#0078d4,color:#fff
    style Cache fill:#10a37f,color:#fff
          </div>

          <h3>Caching Strategy</h3>
          <table class="table table-striped">
            <thead>
              <tr>
                <th>Layer</th>
                <th>What to Cache</th>
                <th>TTL</th>
                <th>Invalidation</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Response Cache</strong></td>
                <td>LLM responses for identical prompts</td>
                <td>1 hour</td>
                <td>On context change</td>
              </tr>
              <tr>
                <td><strong>Context Cache</strong></td>
                <td>File contents, symbols, dependencies</td>
                <td>5 minutes</td>
                <td>On file modification</td>
              </tr>
              <tr>
                <td><strong>Tool Results</strong></td>
                <td>Expensive tool executions</td>
                <td>10 minutes</td>
                <td>On state change</td>
              </tr>
              <tr>
                <td><strong>Skill Data</strong></td>
                <td>Loaded skill definitions</td>
                <td>Session</td>
                <td>On skill update</td>
              </tr>
            </tbody>
          </table>

          <h2>Security Architecture</h2>
          
          <div class="mermaid">
%%{ init: { "theme": "base", "fontFamily": "Segoe UI Semibold", "fontSize": "18px" }}%%
graph TB
    Input[User Input] --> Val[Input Validator]
    Val -->|Valid| AuthZ[Authorization Check]
    Val -->|Invalid| Reject1[Reject]
    
    AuthZ -->|Authorized| Rate[Rate Limiter]
    AuthZ -->|Denied| Reject2[Reject]
    
    Rate -->|Within Limit| Sanitize[Sanitize Data]
    Rate -->|Exceeded| Reject3[Reject]
    
    Sanitize --> Execute[Execute Request]
    
    Execute --> Audit[Audit Log]
    Execute --> Filter[Content Filter]
    
    Filter --> Response[Return Response]
    
    style Val fill:#ff6b6b,color:#fff
    style AuthZ fill:#ffd93d,color:#000
    style Rate fill:#ff6b6b,color:#fff
    style Filter fill:#ffd93d,color:#000
          </div>

          <h2>Error Handling Strategy</h2>
          
          <div class="mermaid">
%%{ init: { "theme": "base", "fontFamily": "Segoe UI Semibold", "fontSize": "18px" }}%%
graph TB
    Error[Error Occurs] --> Type{Error Type}
    
    Type -->|Network| Retry[Retry Logic]
    Type -->|Validation| User[User-Friendly Message]
    Type -->|Auth| Prompt[Prompt Re-auth]
    Type -->|Rate Limit| Wait[Wait & Retry]
    Type -->|Unknown| Log[Log & Generic Message]
    
    Retry -->|Success| Continue[Continue]
    Retry -->|Fail| Fallback[Fallback Response]
    
    User --> Response[Send Response]
    Prompt --> Response
    Wait --> Retry
    Log --> Response
    Fallback --> Response
    Continue --> Response
    
    style Error fill:#ff6b6b,color:#fff
    style Response fill:#10a37f,color:#fff
          </div>

          <h2>Performance Optimization</h2>
          
          <h3>Request Batching</h3>
          <pre><code>class RequestBatcher {
  private queue: Request[] = [];
  private timer: NodeJS.Timeout | null = null;
  
  add(request: Request) {
    this.queue.push(request);
    
    if (!this.timer) {
      this.timer = setTimeout(() => this.flush(), 100);
    }
  }
  
  private async flush() {
    const batch = this.queue.splice(0);
    this.timer = null;
    
    // Process batch in parallel
    await Promise.all(batch.map(r => this.process(r)));
  }
}</code></pre>

          <h3>Lazy Loading</h3>
          <pre><code>class AgentLoader {
  private skills: Map<string, Promise<Skill>> = new Map();
  
  async getSkill(name: string): Promise<Skill> {
    if (!this.skills.has(name)) {
      // Lazy load on first access
      this.skills.set(name, this.loadSkill(name));
    }
    return this.skills.get(name)!;
  }
}</code></pre>

          <h2>Best Practices</h2>
          
          <h3>‚úÖ Architectural Principles</h3>
          <ul>
            <li><strong>Separation of Concerns:</strong> Keep agent logic, LLM interaction, and tools separate</li>
            <li><strong>Modularity:</strong> Design components that can be tested and reused independently</li>
            <li><strong>Stateless Where Possible:</strong> Minimize mutable state for easier reasoning</li>
            <li><strong>Fail Fast:</strong> Validate inputs early and provide clear error messages</li>
            <li><strong>Observable:</strong> Add logging and metrics at key points</li>
          </ul>

          <h3>üîß Implementation Guidelines</h3>
          <ul>
            <li>Use TypeScript for type safety</li>
            <li>Implement proper error boundaries</li>
            <li>Add telemetry for monitoring</li>
            <li>Version your APIs and skills</li>
            <li>Document architectural decisions</li>
          </ul>
        </section>

        <!-- Agent Definition Schema Section -->
        <section id="agent-definition-schema" role="article">
          <h1>üìã Agent Definition Schema</h1>
          <span class="badge">schema</span>
          <span class="badge">configuration</span>
          <span class="badge">structure</span>
          
          <p>The agent definition schema is the blueprint for configuring your GitHub Copilot agent. Defined in the <code>agent.json</code> or <code>.github/copilot/agent.yml</code> file, this schema controls your agent's identity, capabilities, and behavior.</p>

          <div class="callout">
            <strong>üéØ Configuration as Code</strong><br />
            The agent schema provides a declarative way to configure agents without writing boilerplate code. It's version-controlled, reviewable, and enables consistent agent behavior across environments.
          </div>

          <h2>Schema Fields Reference</h2>
          
          <table class="table table-striped">
            <thead>
              <tr>
                <th style="width: 20%;">Field</th>
                <th style="width: 12%;">Type</th>
                <th style="width: 12%;">Required</th>
                <th style="width: 56%;">Purpose</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><code>name</code></td>
                <td>string</td>
                <td>‚úÖ Yes</td>
                <td>@name invocation handle</td>
              </tr>
              <tr>
                <td><code>description</code></td>
                <td>string</td>
                <td>‚úÖ Yes</td>
                <td>Shown in agent picker</td>
              </tr>
              <tr>
                <td><code>model</code></td>
                <td>string</td>
                <td>No</td>
                <td>Override AI model</td>
              </tr>
              <tr>
                <td><code>user-invokable</code></td>
                <td>boolean</td>
                <td>No</td>
                <td>Direct user access (default false)</td>
              </tr>
              <tr>
                <td><code>type</code></td>
                <td>string</td>
                <td>No</td>
                <td>e.g. local for workspace-only agents</td>
              </tr>
              <tr>
                <td><code>scope</code></td>
                <td>string</td>
                <td>No</td>
                <td>e.g. workspace for full workspace access</td>
              </tr>
              <tr>
                <td><code>commands</code></td>
                <td>array</td>
                <td>No</td>
                <td>Slash commands with typed arguments</td>
              </tr>
              <tr>
                <td><code>commands[].arguments</code></td>
                <td>array</td>
                <td>No</td>
                <td>Named, typed, required/optional params</td>
              </tr>
              <tr>
                <td><code>subagents</code></td>
                <td>array</td>
                <td>No</td>
                <td>Agents this one can delegate to</td>
              </tr>
              <tr>
                <td><code>instructions</code></td>
                <td>array</td>
                <td>No</td>
                <td>Injected system context (standards, rules)</td>
              </tr>
              <tr>
                <td><code>prompts</code></td>
                <td>array</td>
                <td>No</td>
                <td>Reusable prompt templates</td>
              </tr>
              <tr>
                <td><code>capabilities</code></td>
                <td>array</td>
                <td>No</td>
                <td>Feature flags for the agent runtime</td>
              </tr>
              <tr>
                <td><code>knowledge-base</code></td>
                <td>array</td>
                <td>No</td>
                <td>Files indexed as grounded knowledge</td>
              </tr>
              <tr>
                <td><code>index-patterns</code></td>
                <td>array</td>
                <td>No</td>
                <td>Source files included in code search</td>
              </tr>
              <tr>
                <td><code>exclude-patterns</code></td>
                <td>array</td>
                <td>No</td>
                <td>Paths excluded from indexing</td>
              </tr>
            </tbody>
          </table>

          <h2>Field Details & Examples</h2>

          <h3>Core Identity Fields</h3>

          <h4>name</h4>
          <p>The unique identifier used to invoke your agent with <code>@name</code> syntax. Must be lowercase, alphanumeric, and without spaces.</p>
          <pre><code>{
  "name": "security-scanner",
  "description": "Scans code for security vulnerabilities"
}</code></pre>

          <h4>description</h4>
          <p>User-facing description shown in the agent picker and help dialogs. Should be clear and concise (max 100 chars).</p>
          <pre><code>{
  "name": "api-designer",
  "description": "Helps design RESTful APIs following OpenAPI standards"
}</code></pre>

          <h3>Model & Runtime Configuration</h3>

          <h4>model</h4>
          <p>Override the default AI model. Useful for specialized agents requiring specific model capabilities (e.g., extended context, multilingual support).</p>
          <pre><code>{
  "name": "architect",
  "model": "gpt-4-turbo-preview",
  "description": "System architecture design assistant"
}</code></pre>
          <p><strong>Supported models:</strong> <code>gpt-4</code>, <code>gpt-4-turbo-preview</code>, <code>gpt-3.5-turbo</code>, <code>claude-3-opus</code></p>

          <h4>user-invokable</h4>
          <p>Controls whether users can directly invoke this agent. Set to <code>false</code> for background/helper agents that should only be called by other agents.</p>
          <pre><code>{
  "name": "test-helper",
  "user-invokable": false,
  "description": "Internal agent for test generation"
}</code></pre>

          <h3>Scope & Access Control</h3>

          <h4>type</h4>
          <p>Defines the agent's deployment model. Common values:</p>
          <ul>
            <li><code>local</code> - Workspace-specific agent</li>
            <li><code>cloud</code> - Organization-level cloud agent</li>
            <li><code>extension</code> - Packaged as VS Code extension</li>
          </ul>
          <pre><code>{
  "name": "project-standards",
  "type": "local",
  "description": "Enforces project-specific coding standards"
}</code></pre>

          <h4>scope</h4>
          <p>Defines what resources the agent can access:</p>
          <ul>
            <li><code>workspace</code> - Full read/write access to workspace files</li>
            <li><code>repository</code> - Access to Git repository metadata</li>
            <li><code>conversation</code> - Only conversation context, no file access</li>
          </ul>
          <pre><code>{
  "name": "code-reviewer",
  "scope": "workspace",
  "description": "Reviews code changes in workspace"
}</code></pre>

          <h3>Commands & Arguments</h3>

          <h4>commands</h4>
          <p>Slash commands that provide structured interaction patterns. Each command can have typed arguments.</p>
          <pre><code>{
  "commands": [
    {
      "name": "deploy",
      "description": "Deploy application to environment",
      "arguments": [
        {
          "name": "environment",
          "type": "string",
          "required": true,
          "options": ["dev", "staging", "production"]
        },
        {
          "name": "version",
          "type": "string",
          "required": false
        }
      ]
    }
  ]
}</code></pre>

          <h4>commands[].arguments</h4>
          <p>Define typed parameters for commands with validation rules:</p>
          <ul>
            <li><code>name</code> - Parameter name</li>
            <li><code>type</code> - Data type (string, number, boolean, file, folder)</li>
            <li><code>required</code> - Whether parameter is mandatory</li>
            <li><code>options</code> - Allowed values (for enums)</li>
            <li><code>default</code> - Default value if not provided</li>
          </ul>

          <h3>Delegation & Composition</h3>

          <h4>subagents</h4>
          <p>Declare which agents this agent can delegate tasks to. Enables hierarchical agent architectures.</p>
          <pre><code>{
  "name": "fullstack-assistant",
  "subagents": [
    "@frontend-expert",
    "@backend-expert",
    "@database-optimizer"
  ],
  "description": "Coordinates frontend and backend development"
}</code></pre>

          <h3>Context & Instructions</h3>

          <h4>instructions</h4>
          <p>System-level instructions injected into every conversation. Use for coding standards, architectural guidelines, or domain rules.</p>
          <pre><code>{
  "instructions": [
    {
      "file": ".github/copilot/instructions/coding-standards.md"
    },
    {
      "file": ".github/copilot/instructions/security-rules.md"
    },
    {
      "content": "Always prefer TypeScript strict mode and functional programming patterns."
    }
  ]
}</code></pre>

          <h4>prompts</h4>
          <p>Reusable prompt templates that can be referenced in commands or conversations.</p>
          <pre><code>{
  "prompts": [
    {
      "name": "code-review-checklist",
      "file": ".github/copilot/prompts/review-checklist.md"
    },
    {
      "name": "refactor-guide",
      "content": "When refactoring: 1) Extract method 2) Simplify conditionals 3) Remove duplication"
    }
  ]
}</code></pre>

          <h4>capabilities</h4>
          <p>Feature flags that control runtime behavior. Common capabilities:</p>
          <ul>
            <li><code>code-editing</code> - Can modify files directly</li>
            <li><code>terminal-access</code> - Can run terminal commands</li>
            <li><code>web-search</code> - Can search the internet</li>
            <li><code>git-operations</code> - Can perform Git operations</li>
          </ul>
          <pre><code>{
  "capabilities": [
    "code-editing",
    "terminal-access",
    "git-operations"
  ]
}</code></pre>

          <h3>Knowledge & Search</h3>

          <h4>knowledge-base</h4>
          <p>Files that are indexed and used as grounded truth for agent responses. Perfect for documentation, API specs, and standards.</p>
          <pre><code>{
  "knowledge-base": [
    "docs/api-reference.md",
    "CONTRIBUTING.md",
    "standards/*.md",
    "architecture/decisions/*.md"
  ]
}</code></pre>

          <h4>index-patterns</h4>
          <p>Glob patterns for files included in semantic search and code analysis. Helps agents find relevant code faster.</p>
          <pre><code>{
  "index-patterns": [
    "src/**/*.ts",
    "src/**/*.tsx",
    "tests/**/*.test.ts",
    "*.config.js"
  ]
}</code></pre>

          <h4>exclude-patterns</h4>
          <p>Patterns to exclude from indexing. Reduces noise and improves search quality.</p>
          <pre><code>{
  "exclude-patterns": [
    "node_modules/**",
    "dist/**",
    "build/**",
    "*.min.js",
    "coverage/**"
  ]
}</code></pre>

          <h2>Complete Example</h2>

          <pre><code>{
  "$schema": "https://copilot.github.com/schemas/agent.json",
  "name": "api-guardian",
  "description": "API design and governance assistant",
  "model": "gpt-4-turbo-preview",
  "user-invokable": true,
  "type": "local",
  "scope": "workspace",
  
  "commands": [
    {
      "name": "validate",
      "description": "Validate API against standards",
      "arguments": [
        {
          "name": "spec-file",
          "type": "file",
          "required": true
        },
        {
          "name": "strict",
          "type": "boolean",
          "default": false
        }
      ]
    },
    {
      "name": "generate",
      "description": "Generate API boilerplate",
      "arguments": [
        {
          "name": "framework",
          "type": "string",
          "required": true,
          "options": ["express", "fastify", "nestjs"]
        }
      ]
    }
  ],
  
  "subagents": [
    "@security-scanner",
    "@test-generator"
  ],
  
  "instructions": [
    {
      "file": ".github/copilot/instructions/api-standards.md"
    },
    {
      "content": "Always validate OpenAPI 3.0+ compatibility. Enforce RESTful principles."
    }
  ],
  
  "prompts": [
    {
      "name": "security-checklist",
      "file": ".github/copilot/prompts/api-security.md"
    }
  ],
  
  "capabilities": [
    "code-editing",
    "terminal-access",
    "web-search"
  ],
  
  "knowledge-base": [
    "docs/api-guidelines.md",
    "examples/openapi-specs/*.yaml",
    "standards/rest-conventions.md"
  ],
  
  "index-patterns": [
    "src/api/**/*.ts",
    "src/controllers/**/*.ts",
    "openapi/**/*.yaml"
  ],
  
  "exclude-patterns": [
    "node_modules/**",
    "dist/**",
    "*.test.ts"
  ]
}</code></pre>

          <h2>Best Practices</h2>

          <h3>‚úÖ Schema Design Guidelines</h3>
          <ul>
            <li><strong>Descriptive Names:</strong> Use clear, purpose-driven names like <code>@api-designer</code> rather than <code>@helper1</code></li>
            <li><strong>Minimal Scope:</strong> Grant only necessary permissions via <code>scope</code> and <code>capabilities</code></li>
            <li><strong>Version Control:</strong> Keep agent schemas in Git for history and review</li>
            <li><strong>Documentation:</strong> Use rich descriptions and maintain separate docs for complex agents</li>
            <li><strong>Modular Instructions:</strong> Split instructions into focused files rather than one large block</li>
          </ul>

          <h3>üéØ Performance Optimization</h3>
          <ul>
            <li><strong>Targeted Indexing:</strong> Use specific <code>index-patterns</code> to reduce search space</li>
            <li><strong>Exclude Aggressively:</strong> Block generated files, dependencies, and build outputs</li>
            <li><strong>Right-Size Knowledge Base:</strong> Include only essential docs to minimize context</li>
            <li><strong>Command Arguments:</strong> Validate inputs early with typed arguments</li>
            <li><strong>Model Selection:</strong> Use faster models for simple tasks, GPT-4 only when needed</li>
          </ul>

          <h3>üîí Security Considerations</h3>
          <ul>
            <li><strong>Principle of Least Privilege:</strong> Disable <code>user-invokable</code> for internal agents</li>
            <li><strong>Scope Restrictions:</strong> Use <code>conversation</code> scope for read-only agents</li>
            <li><strong>Capability Limits:</strong> Only enable <code>terminal-access</code> when absolutely necessary</li>
            <li><strong>Input Validation:</strong> Always define <code>options</code> for enum-like parameters</li>
            <li><strong>Audit Trail:</strong> Version schema changes for compliance tracking</li>
          </ul>

          <h3>üöÄ Advanced Patterns</h3>
          <ul>
            <li><strong>Agent Composition:</strong> Use <code>subagents</code> to build specialized agent teams</li>
            <li><strong>Context Injection:</strong> Combine <code>instructions</code> + <code>knowledge-base</code> for rich context</li>
            <li><strong>Dynamic Commands:</strong> Use arguments with <code>options</code> for type-safe workflows</li>
            <li><strong>Prompt Libraries:</strong> Build reusable <code>prompts</code> for common tasks</li>
            <li><strong>Multi-Agent Orchestration:</strong> Create a coordinator agent that delegates to specialists</li>
          </ul>

          <div class="callout">
            <strong>üí° Schema Validation</strong><br />
            Use JSON Schema validation in your CI/CD pipeline to catch configuration errors early. The official schema is available at <code>https://copilot.github.com/schemas/agent.json</code>
          </div>
        </section>

        <!-- Agent Types Section -->
        <section id="agent-types" role="article">
          <h1>üéØ Agent Types</h1>
          <span class="badge">types</span>
          <span class="badge">categories</span>
          
          <p>GitHub Copilot supports various types of agents, each designed for different use cases and deployment scenarios. Understanding these types helps you choose the right approach for your needs.</p>

          <h2>Agent Categories</h2>
          
          <table class="table table-striped">
            <thead>
              <tr>
                <th>Type</th>
                <th>Location</th>
                <th>Purpose</th>
                <th>Examples</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Background Agents</strong></td>
                <td>VS Code Process</td>
                <td>Continuous monitoring and assistance</td>
                <td>Code analysis, error detection</td>
              </tr>
              <tr>
                <td><strong>Custom Agents</strong></td>
                <td>Extensions</td>
                <td>Domain-specific expertise</td>
                <td>Framework helpers, company standards</td>
              </tr>
              <tr>
                <td><strong>Local Agents</strong></td>
                <td>Workspace</td>
                <td>Project-specific context</td>
                <td>Monorepo navigation, project docs</td>
              </tr>
              <tr>
                <td><strong>Cloud Agents</strong></td>
                <td>GitHub Cloud</td>
                <td>Enterprise-wide knowledge</td>
                <td>Organization policies, shared knowledge</td>
              </tr>
              <tr>
                <td><strong>Third-Party Agents</strong></td>
                <td>External Services</td>
                <td>Integration with external tools</td>
                <td>Jira, Slack, Azure DevOps</td>
              </tr>
            </tbody>
          </table>

          <h2>By Architecture</h2>
          
          <h3>üèóÔ∏è Standalone Agents</h3>
          <ul>
            <li>Operate independently</li>
            <li>Single-purpose focus</li>
            <li>Direct user interaction</li>
            <li>Examples: <code>@terminal</code>, <code>@vscode</code></li>
          </ul>

          <h3>ü§ù Composite Agents</h3>
          <ul>
            <li>Orchestrate multiple sub-agents</li>
            <li>Delegate tasks to specialists</li>
            <li>Complex workflow management</li>
            <li>Example: <code>@workspace</code> may delegate to file, git, and search agents</li>
          </ul>

          <h2>By Interaction Model</h2>
          
          <h3>üí¨ Conversational Agents</h3>
          <ul>
            <li>Chat-based interaction</li>
            <li>Multi-turn conversations</li>
            <li>Natural language understanding</li>
            <li>Use Case: Debugging, learning, exploration</li>
          </ul>

          <h3>‚ö° Action Agents</h3>
          <ul>
            <li>Direct command execution</li>
            <li>Single-purpose actions</li>
            <li>Quick operations</li>
            <li>Use Case: Code formatting, file operations</li>
          </ul>

          <h3>üëÅÔ∏è Observational Agents</h3>
          <ul>
            <li>Monitor workspace passively</li>
            <li>Provide proactive suggestions</li>
            <li>Background analysis</li>
            <li>Use Case: Best practice recommendations, security scanning</li>
          </ul>

          <h2>By Scope</h2>
          
          <h3>üìÅ File-Scoped Agents</h3>
          <ul>
            <li>Work with single files</li>
            <li>Fast, focused operations</li>
            <li>Limited context</li>
          </ul>

          <h3>üìÇ Project-Scoped Agents</h3>
          <ul>
            <li>Access entire project/workspace</li>
            <li>Cross-file awareness</li>
            <li>Comprehensive analysis</li>
          </ul>

          <h3>üåê Organization-Scoped Agents</h3>
          <ul>
            <li>Access organization knowledge base</li>
            <li>Enforce company policies</li>
            <li>Shared across teams</li>
          </ul>

          <h2>Selection Criteria</h2>
          
          <div class="callout">
            <strong>üéØ Choose Based On:</strong>
            <ul>
              <li><strong>Privacy:</strong> Local agents for sensitive code</li>
              <li><strong>Performance:</strong> Background agents for real-time feedback</li>
              <li><strong>Specialization:</strong> Custom agents for specific frameworks</li>
              <li><strong>Scale:</strong> Cloud agents for enterprise deployment</li>
              <li><strong>Integration:</strong> Third-party agents for tool connectivity</li>
            </ul>
          </div>
        </section>

        <!-- Background Agents Section -->
        <section id="background-agents" role="article">
          <h1>üîô Background Agents</h1>
          <span class="badge">background</span>
          <span class="badge">async</span>
          
          <p>Background agents run continuously in VS Code, monitoring your workspace and providing proactive assistance without explicit invocation. They work silently to enhance your development experience.</p>

          <div class="callout">
            <strong>üí° Key Concept</strong><br />
            Background agents operate asynchronously, analyzing your code as you work and surfacing insights when relevant, without interrupting your flow.
          </div>

          <h2>Characteristics</h2>
          <ul>
            <li><strong>Always Active:</strong> Run continuously while VS Code is open</li>
            <li><strong>Non-Blocking:</strong> Don't interrupt user workflow</li>
            <li><strong>Context-Aware:</strong> Monitor file changes, git operations, and editor state</li>
            <li><strong>Proactive:</strong> Suggest improvements before being asked</li>
            <li><strong>Resource-Conscious:</strong> Optimize CPU and memory usage</li>
          </ul>

          <h2>Common Background Agent Tasks</h2>
          
          <h3>üîç Code Analysis</h3>
          <ul>
            <li>Detect code smells and anti-patterns</li>
            <li>Identify potential bugs and errors</li>
            <li>Suggest refactoring opportunities</li>
            <li>Monitor code complexity metrics</li>
          </ul>

          <h3>üîí Security Scanning</h3>
          <ul>
            <li>Identify security vulnerabilities</li>
            <li>Detect exposed secrets and credentials</li>
            <li>Flag insecure dependencies</li>
            <li>Suggest security best practices</li>
          </ul>

          <h3>üìö Documentation Monitoring</h3>
          <ul>
            <li>Flag missing documentation</li>
            <li>Suggest doc improvements</li>
            <li>Ensure consistency across codebase</li>
          </ul>

          <h3>‚öôÔ∏è Performance Optimization</h3>
          <ul>
            <li>Identify performance bottlenecks</li>
            <li>Suggest optimization opportunities</li>
            <li>Monitor resource usage patterns</li>
          </ul>

          <h2>Implementation Pattern</h2>
          <pre><code>// Background agent structure
class BackgroundAnalysisAgent {
  private watcher: FileSystemWatcher;
  
  activate(context: ExtensionContext) {
    // Monitor file changes
    this.watcher = workspace.createFileSystemWatcher('**/*.ts');
    
    // Debounced analysis
    this.watcher.onDidChange(
      debounce((uri) => this.analyzeFile(uri), 500)
    );
  }
  
  async analyzeFile(uri: Uri) {
    // Run analysis in background
    const issues = await this.performAnalysis(uri);
    
    // Surface findings non-intrusively
    if (issues.length > 0) {
      this.showDiagnostics(uri, issues);
    }
  }
}</code></pre>

          <h2>Notification Strategies</h2>
          
          <table class="table table-striped">
            <thead>
              <tr>
                <th>Method</th>
                <th>Intrusiveness</th>
                <th>Use Case</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Inline Hints</strong></td>
                <td>Low</td>
                <td>Suggestions that don't block work</td>
              </tr>
              <tr>
                <td><strong>Diagnostics Panel</strong></td>
                <td>Low</td>
                <td>Aggregate findings for review</td>
              </tr>
              <tr>
                <td><strong>Status Bar Items</strong></td>
                <td>Medium</td>
                <td>Important but non-urgent updates</td>
              </tr>
              <tr>
                <td><strong>Notifications</strong></td>
                <td>High</td>
                <td>Critical issues requiring attention</td>
              </tr>
            </tbody>
          </table>

          <h2>Performance Considerations</h2>
          
          <h3>‚úÖ Best Practices</h3>
          <ul>
            <li>Use debouncing to avoid excessive analysis</li>
            <li>Implement incremental analysis when possible</li>
            <li>Cache results to minimize recomputation</li>
            <li>Use worker threads for CPU-intensive tasks</li>
            <li>Respect user's idle time for heavy operations</li>
          </ul>

          <h3>‚ö†Ô∏è Avoid</h3>
          <ul>
            <li>Blocking the main thread</li>
            <li>Analyzing on every keystroke</li>
            <li>Holding large data structures in memory</li>
            <li>Running analysis when VS Code is busy</li>
          </ul>

          <h2>Configuration</h2>
          <pre><code>// settings.json or config.yaml
{
  "copilot.backgroundAgents.enabled": true,
  "copilot.backgroundAgents.analysisDelay": 500,
  "copilot.backgroundAgents.maxConcurrent": 3,
  "copilot.backgroundAgents.respectIdleTime": true
}</code></pre>

          <h2>Markdown-Based Background Agent Example</h2>
          
          <h3>Code Quality Analyzer (.github/agents/quality-analyzer.md)</h3>
          <pre><code>---
name: quality-analyzer
description: Continuously analyzes code quality in the background
type: background
user-invokable: false
triggers:
  - event: file-save
    file-pattern: "**/*.{js,ts,jsx,tsx,py,java,cs}"
  - event: file-open
  - event: workspace-idle
    delay: 1000
schedule:
  interval: 30000  # Run every 30 seconds during idle
  max-concurrent: 1
---

# Background Code Quality Analyzer

I am a background agent that continuously monitors code quality without user interaction.

## Automatic Analysis

I automatically analyze:

### On File Save
- Code complexity (cyclomatic complexity)
- Duplicate code detection
- Code smells (long methods, large classes)
- Naming convention violations
- Comment quality

### On File Open
- Security vulnerabilities
- Performance anti-patterns
- Accessibility issues
- Best practice violations

### During Workspace Idle
- Full workspace analysis
- Cross-file dependency issues
- Architecture pattern violations
- Technical debt metrics

## Analysis Output

I provide non-intrusive notifications:

**Priority Levels:**
- üî¥ Critical: Security vulnerabilities, breaking changes
- üü° Warning: Code smells, deprecated APIs
- üü¢ Info: Suggestions, optimizations

**Delivery Methods:**
- Silent background updates (diagnostics panel)
- Status bar indicators
- Subtle notifications for critical issues only

## Performance Optimization

- Incremental analysis (only changed files)
- Debouncing to avoid excessive runs
- Respect system resources (CPU/memory thresholds)
- Pause during active typing or debugging
- Cache results for unchanged files

## Configuration

Users can configure my behavior:
- Enable/disable specific checks
- Set notification thresholds
- Configure analysis frequency
- Exclude file patterns
- Set resource limits</code></pre>

          <h3>Dependency Watcher (.github/agents/dependency-watcher.md)</h3>
          <pre><code>---
name: dependency-watcher
description: Monitors dependency updates and security advisories
type: background
user-invokable: false
triggers:
  - event: file-change
    file-pattern: "**/package.json,**/requirements.txt,**/pom.xml,**/*.csproj"
  - event: workspace-open
schedule:
  interval: 3600000  # Check hourly
---

# Dependency Watcher Agent

I monitor your project dependencies in the background.

## What I Watch

### Package Files
- package.json (npm/yarn)
- requirements.txt (Python pip)
- Gemfile (Ruby)
- pom.xml (Maven)
- build.gradle (Gradle)
- *.csproj (NuGet)
- go.mod (Go modules)

### Automated Checks
1. **Security Vulnerabilities**: Check against CVE databases
2. **Outdated Packages**: Compare with latest versions
3. **License Compliance**: Verify license compatibility
4. **Breaking Changes**: Detect major version updates

## Notifications

**Critical (Immediate):**
- High/Critical CVEs in dependencies
- License violations

**Informational (Batched):**
- Minor version updates available
- Deprecated package warnings

## Actions

I can automatically:
- Create pull requests for security patches
- Generate update reports
- Suggest migration paths for breaking changes
- Update lock files

## Integration

I integrate with:
- GitHub Security Advisories
- npm audit
- Snyk
- OWASP Dependency-Check
- WhiteSource</code></pre>

          <h2>Examples</h2>
          
          <h3>Built-in Background Agents</h3>
          <ul>
            <li><strong>IntelliSense Engine:</strong> Provides code completions</li>
            <li><strong>Problem Matcher:</strong> Detects errors and warnings</li>
            <li><strong>Git Watcher:</strong> Monitors repository changes</li>
            <li><strong>Import Organizer:</strong> Suggests import optimizations</li>
            <li><strong>Test Runner:</strong> Auto-runs tests on file changes</li>
            <li><strong>Build Monitor:</strong> Watches build status</li>
          </ul>
        </section>

        <!-- Custom Agents Section -->
        <section id="custom-agents" role="article">
          <h1>üé® Custom Agents</h1>
          <span class="badge">custom</span>
          <span class="badge">build</span>
          
          <p>Custom agents extend GitHub Copilot with specialized capabilities tailored to your team's frameworks, coding standards, or domain expertise. Create agents that understand your unique development context.</p>

          <div class="callout">
            <strong>üí° Why Build Custom Agents?</strong><br />
            Custom agents encode your team's knowledge, enforce standards, and provide domain-specific assistance that general-purpose AI can't match.
          </div>

          <h2>Use Cases</h2>
          
          <h3>üè≠ Company-Specific</h3>
          <ul>
            <li>Internal framework assistance (proprietary libraries)</li>
            <li>Coding standards enforcement</li>
            <li>Architecture pattern guidance</li>
            <li>Legacy codebase navigation</li>
          </ul>

          <h3>üõ†Ô∏è Framework-Specific</h3>
          <ul>
            <li>React best practices agent</li>
            <li>Angular migration helper</li>
            <li>Spring Boot configuration assistant</li>
            <li>Django model generator</li>
          </ul>

          <h3>üíº Domain-Specific</h3>
          <ul>
            <li>Financial calculations helper</li>
            <li>Healthcare compliance checker</li>
            <li>Gaming engine assistant</li>
            <li>Data science workflow guide</li>
          </ul>

          <h2>Markdown-Based Custom Agent Examples</h2>
          
          <h3>React Helper Agent (.github/agents/react-helper.md)</h3>
          <pre><code>---
name: reacthelper
description: Expert in React best practices and our company's React architecture
user-invokable: true
commands:
  - name: component
    description: Generate a React component following our patterns
  - name: test
    description: Create tests for a React component
  - name: migrate
    description: Migrate class component to hooks
  - name: optimize
    description: Suggest performance optimizations
knowledge-base:
  - docs/react-patterns.md
  - docs/component-library.md
  - src/components/examples/**
---

# React Helper Agent

I am your React development expert, specialized in our company's React architecture and best practices.

## My Expertise

**Framework Knowledge:**
- React 18+ with hooks and concurrent features
- TypeScript for type-safe components
- Redux Toolkit for state management
- React Testing Library for testing
- CSS Modules and styled-components

**Company Patterns:**
- Component composition patterns
- Custom hook conventions
- State management architecture
- Error boundary standards
- Performance optimization patterns

## Commands

### /component - Generate Components

Generate components following our architecture:

**Functional Components:**
- TypeScript interfaces for props
- Proper prop destructuring
- Custom hooks for logic
- CSS Modules for styling
- JSDoc comments

**Example Usage:**
```
@reacthelper /component Button with primary and secondary variants
```

**I will create:**
- Button.tsx (component file)
- Button.module.css (styles)
- Button.types.ts (TypeScript types)
- Button.stories.tsx (Storybook stories)
- index.ts (barrel export)

### /test - Generate Tests

Create comprehensive test suites:

**Test Coverage:**
- Component rendering tests
- User interaction tests
- Accessibility tests (a11y)
- Edge case handling
- Mock data setup

**Example Usage:**
```
@reacthelper /test for the UserProfile component
```

### /migrate - Migration Support

Migrate legacy code to modern patterns:

**Migration Types:**
- Class components ‚Üí Functional with hooks
- Redux connect() ‚Üí useSelector/useDispatch
- PropTypes ‚Üí TypeScript interfaces
- ComponentWillReceiveProps ‚Üí useEffect

### /optimize - Performance Analysis

Identify and fix performance issues:

**Checks:**
- Unnecessary re-renders (React.memo)
- Missing dependency arrays
- Large bundle sizes
- Inefficient list rendering
- Context overuse

## Best Practices I Enforce

1. **Props Validation**: Always use TypeScript interfaces
2. **Hooks Rules**: Follow React hooks rules
3. **Immutability**: Never mutate state directly
4. **Accessibility**: Include ARIA attributes
5. **Error Boundaries**: Wrap async components
6. **Code Splitting**: Use lazy loading
7. **Memoization**: Apply when appropriate

## Integration

I can integrate with:
- Storybook for component documentation
- ESLint for code quality
- Jest and React Testing Library
- Chromatic for visual testing
- Bundle analyzers for optimization</code></pre>

          <h3>Framework-Specific Agent (.github/agents/spring-boot-helper.md)</h3>
          <pre><code>---
name: springboot
description: Spring Boot expert for Java microservices
user-invokable: true
commands:
  - name: controller
    description: Generate REST controller
  - name: service
    description: Create service layer
  - name: entity
    description: Generate JPA entity
  - name: test
    description: Create integration tests
---

# Spring Boot Helper Agent

I specialize in Spring Boot microservices development.

## Expertise

- Spring Boot 3.x with Java 17+
- RESTful API design
- JPA/Hibernate for data access
- Spring Security for authentication
- Microservices patterns

## Commands

### /controller - REST Controllers

Generate REST controllers with:
- RequestMapping annotations
- DTOs for request/response
- Validation annotations
- Exception handling
- OpenAPI documentation

### /service - Service Layer

Create service classes with:
- Business logic separation
- Transaction management
- Exception handling
- Logging

### /entity - JPA Entities

Generate entities with:
- Proper annotations (@Entity, @Table)
- Relationships (OneToMany, ManyToOne)
- Validation constraints
- Audit fields (createdAt, updatedAt)

### /test - Integration Tests

Create tests with:
- @SpringBootTest configuration
- MockMvc for API testing
- Test data setup
- Database mocking

## Design Patterns

- Controller ‚Üí Service ‚Üí Repository layering
- DTO pattern for API contracts
- Builder pattern for complex objects
- Factory pattern for object creation
- Strategy pattern for algorithms</code></pre>

          <h3>Domain-Specific Agent (.github/agents/fintech-compliance.md)</h3>
          <pre><code>---
name: fintech-compliance
description: Financial services compliance and security expert
user-invokable: true
commands:
  - name: audit
    description: Audit code for compliance violations
  - name: encrypt
    description: Add encryption to sensitive data
  - name: validate
    description: Validate financial calculations
---

# Fintech Compliance Agent

I ensure your financial software meets regulatory requirements.

## Compliance Areas

**Regulatory Standards:**
- PCI DSS (Payment Card Industry)
- GDPR (Data privacy)
- SOX (Financial reporting)
- KYC/AML (Know Your Customer)

**Security Requirements:**
- Data encryption (at rest and in transit)
- Access control (RBAC)
- Audit logging
- Sensitive data handling

## Commands

### /audit - Compliance Audit

I check for:
- Unencrypted sensitive data
- Missing audit logs
- Improper access controls
- Data retention violations
- Insufficient validation

### /encrypt - Encryption Implementation

I add encryption for:
- Credit card numbers
- SSN/Tax IDs
- Banking details
- Personal information

### /validate - Financial Validation

I verify:
- Currency calculations (precision)
- Rounding rules
- Interest calculations
- Exchange rate handling
- Transaction integrity

## Best Practices

1. Never log sensitive data
2. Use parameterized queries (prevent SQL injection)
3. Implement rate limiting
4. Validate all inputs
5. Encrypt PII at rest
6. Audit all financial transactions
7. Use secure random number generation
8. Implement timeout mechanisms</code></pre>

          <h2>Best Practices</h2>
          
          <h3>‚úÖ Do's</h3>
          <ul>
            <li>Provide clear, specific descriptions for your agent</li>
            <li>Implement meaningful slash commands</li>
            <li>Handle errors gracefully</li>
            <li>Respect cancellation tokens</li>
            <li>Stream responses for better UX</li>
            <li>Include examples in agent description</li>
            <li>Test with various input types</li>
          </ul>

          <h3>‚ö†Ô∏è Don'ts</h3>
          <ul>
            <li>Don't make blocking operations on main thread</li>
            <li>Don't expose sensitive internal information</li>
            <li>Don't override built-in agent names</li>
            <li>Don't ignore context from chat history</li>
          </ul>

          <h2>Publishing</h2>
          
          <h3>Internal Distribution</h3>
          <ul>
            <li>Package as VSIX file</li>
            <li>Distribute via internal marketplace</li>
            <li>Version control in company repo</li>
          </ul>

          <h3>Public Distribution</h3>
          <ul>
            <li>Publish to VS Code Marketplace</li>
            <li>Add clear documentation</li>
            <li>Include usage examples</li>
            <li>Provide support channels</li>
          </ul>

          <h2>Example: React Component Generator</h2>
          <pre><code>@reacthelper /component Button with variants

// Agent generates:
import React from 'react';
import styles from './Button.module.css';

interface ButtonProps {
  variant: 'primary' | 'secondary' | 'outline';
  children: React.ReactNode;
  onClick?: () => void;
}

export const Button: React.FC<ButtonProps> = ({
  variant,
  children,
  onClick
}) => {
  return (
    <button 
      className={`${styles.button} ${styles[variant]}`}
      onClick={onClick}
    >
      {children}
    </button>
  );
};</code></pre>
        </section>

        <!-- Local Agents Section -->
        <section id="local-agents" role="article">
          <h1>üíª Local Agents</h1>
          <span class="badge">local</span>
          <span class="badge">workspace</span>
          
          <p>Local agents are workspace-specific AI assistants that understand your project's unique structure, conventions, and context. They run entirely within your local VS Code environment.</p>

          <div class="callout">
            <strong>üîí Privacy First</strong><br />
            Local agents keep your code private. They operate on your machine without sending code to external services, making them ideal for sensitive or proprietary projects.
          </div>

          <h2>Key Features</h2>
          <ul>
            <li><strong>Full Workspace Context:</strong> Access to all project files and structure</li>
            <li><strong>Local Processing:</strong> No external network calls required</li>
            <li><strong>Project-Aware:</strong> Understand your specific patterns and conventions</li>
            <li><strong>Fast Response:</strong> No network latency</li>
            <li><strong>Offline Capable:</strong> Work without internet connection</li>
          </ul>

          <h2>Configuration</h2>
          
          <h3>Workspace Settings</h3>
          <pre><code>// .vscode/settings.json or workspace.yaml
{
  "copilot.localAgents": {
    "enabled": true,
    "indexWorkspace": true,
    "excludePatterns": [
      "**/node_modules/**",
      "**/dist/**",
      "**/.git/**",
      "**/build/**",
      "**/.next/**"
    ],
    "maxFileSize": 1048576 // 1MB
  }
}</code></pre>

          <h2>Markdown-Based Local Agent Examples</h2>
          
          <h3>Project Helper Agent (.github/agents/project-helper.md)</h3>
          <pre><code>---
name: project
description: Expert in this workspace's architecture, patterns, and conventions
type: local
user-invokable: true
scope: workspace
capabilities:
  - code-navigation
  - pattern-detection
  - refactoring-support
  - documentation-search
knowledge-base:
  - docs/**/*.md
  - README.md
  - CONTRIBUTING.md
  - ARCHITECTURE.md
  - src/**/README.md
index-patterns:
  - "**/*.{ts,tsx,js,jsx}"
  - "**/*.{py,java,cs,go}"
  - "**/*.{md,mdx}"
  - "**/package.json"
  - "**/tsconfig.json"
exclude-patterns:
  - "**/node_modules/**"
  - "**/dist/**"
  - "**/.git/**"
---

# Project Helper Agent

I am your workspace-specific AI assistant. I understand this project's architecture, coding patterns, and conventions.

## What I Know

### Project Structure
- Complete codebase organization
- Module dependencies
- Component hierarchy
- File naming conventions
- Directory structure patterns

### Coding Patterns
- Common design patterns used
- Utility function patterns
- API call conventions
- Error handling approaches
- State management patterns

### Documentation
- All markdown docs
- Inline code comments
- README files
- API documentation
- Architecture decisions (ADRs)

## Capabilities

### Code Navigation
```
@project where is the user authentication logic?
@project find all database models
@project show me API endpoints for products
@project what files import UserContext?
```

### Pattern Detection
```
@project find components using deprecated patterns
@project show me inconsistent error handling
@project identify duplicate logic
@project find unused exports
```

### Refactoring Support
```
@project help me extract this into a custom hook
@project show all usages of this function
@project suggest how to refactor this component
@project find circular dependencies
```

### Documentation Search
```
@project how do I deploy to staging?
@project what's our git workflow?
@project explain the authentication flow
@project where are the API docs?
```

## Knowledge Index

I maintain a local index of:

**Code Symbols:**
- Functions, classes, interfaces
- Exports and imports
- React components and hooks
- API routes

**Relationships:**
- File dependencies
- Component usage
- Function call graphs
- Module boundaries

**Metadata:**
- File types and purposes
- Code complexity metrics
- Test coverage
- Documentation completeness

## Privacy & Performance

**Fully Local:**
- All data stays on your machine
- No external network calls
- Offline capable
- Workspace-scoped only

**Optimized Indexing:**
- Incremental updates (only changed files)
- Background indexing during idle time
- Compressed index storage
- Fast retrieval with embeddings

## Context-Aware Suggestions

I provide suggestions based on:
- Current file you're editing
- Recently modified files
- Project conventions
- Similar code patterns
- Team best practices

## Example Workflows

### Onboarding New Developers
```
@project give me an overview of the codebase
@project where do I start for backend changes?
@project explain the testing setup
```

### Feature Development
```
@project find similar features for reference
@project what patterns should I follow?
@project check if this violates any conventions
```

### Debugging
```
@project trace this error through the codebase
@project find where this state is modified
@project show all error handling for this module
```</code></pre>

          <h3>Monorepo Navigator (.github/agents/monorepo-nav.md)</h3>
          <pre><code>---
name: monorepo
description: Navigate and manage large monorepo workspaces
type: local
user-invokable: true
scope: workspace
knowledge-base:
  - "**/package.json"
  - "**/tsconfig.json"
  - "lerna.json"
  - "nx.json"
  - "pnpm-workspace.yaml"
---

# Monorepo Navigator Agent

I specialize in navigating and managing monorepo workspaces (Nx, Lerna, pnpm workspaces, Turborepo).

## Monorepo Understanding

**Package Structure:**
- Identify all packages/apps
- Understand package dependencies
- Map shared libraries
- Track workspace organization

**Build Configuration:**
- Build order based on dependencies
- Affected packages analysis
- Task pipeline configuration
- Caching strategies

## Commands

### Navigation
```
@monorepo list all packages
@monorepo find packages depending on @company/ui
@monorepo show me all apps
@monorepo which packages use React 18?
```

### Dependency Analysis
```
@monorepo show dependency graph
@monorepo find circular dependencies
@monorepo what depends on this package?
@monorepo analyze package versions
```

### Change Impact
```
@monorepo what's affected by changes in @company/auth?
@monorepo which packages need testing?
@monorepo show me changed packages
```

## Integration

- Nx workspace analysis
- Lerna package management
- pnpm workspace topology
- Turborepo task orchestration</code></pre>

          <h2>Use Cases</h2>
          
          <h3>üóÇÔ∏è Monorepo Navigation</h3>
          <pre><code>@project where is the authentication logic?
@project show me all API endpoints
@project find components using deprecated patterns</code></pre>

          <h3>üìù Documentation Assistance</h3>
          <ul>
            <li>Index internal documentation</li>
            <li>Answer project-specific questions</li>
            <li>Generate docs from code</li>
            <li>Maintain consistency across docs</li>
          </ul>

          <h3>üîÑ Refactoring Support</h3>
          <ul>
            <li>Identify refactoring opportunities</li>
            <li>Update all usages across workspace</li>
            <li>Maintain consistency during changes</li>
            <li>Generate migration scripts</li>
          </ul>

          <h2>Knowledge Indexing</h2>
          
          <h3>What Gets Indexed</h3>
          <ul>
            <li>Source code files</li>
            <li>Documentation (Markdown, reStructuredText)</li>
            <li>Configuration files</li>
            <li>API schemas (OpenAPI, GraphQL)</li>
            <li>Database schemas</li>
            <li>Test files</li>
          </ul>

          <h3>Indexing Strategy</h3>
          <pre><code>// Semantic chunks for retrieval
{
  "chunks": [
    {
      "type": "function",
      "name": "authenticateUser",
      "file": "src/auth/authenticate.ts",
      "lines": [45, 78],
      "embedding": [...],
      "metadata": {
        "exported": true,
        "async": true,
        "params": ["username", "password"]
      }
    }
  ]
}</code></pre>

          <h2>Performance Optimization</h2>
          
          <table class="table table-striped">
            <thead>
              <tr>
                <th>Technique</th>
                <th>Purpose</th>
                <th>Impact</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Incremental Indexing</strong></td>
                <td>Only re-index changed files</td>
                <td>Fast updates</td>
              </tr>
              <tr>
                <td><strong>Caching</strong></td>
                <td>Store frequently accessed data</td>
                <td>Reduced computation</td>
              </tr>
              <tr>
                <td><strong>Lazy Loading</strong></td>
                <td>Load context on-demand</td>
                <td>Lower memory usage</td>
              </tr>
              <tr>
                <td><strong>Compression</strong></td>
                <td>Compact index storage</td>
                <td>Smaller disk footprint</td>
              </tr>
            </tbody>
          </table>

          <h2>Integration with @workspace</h2>
          <p>The built-in <code>@workspace</code> agent is a powerful local agent that:</p>
          <ul>
            <li>Understands your entire codebase structure</li>
            <li>Provides context-aware code suggestions</li>
            <li>Answers questions about your project</li>
            <li>Helps navigate large codebases</li>
          </ul>

          <h3>Example Usage</h3>
          <pre><code>@workspace how does authentication work in this project?
@workspace find all database queries
@workspace show me the component hierarchy
@workspace /explain the build process</code></pre>

          <h2>Security Considerations</h2>
          
          <h3>‚úÖ Advantages</h3>
          <ul>
            <li>Code never leaves your machine</li>
            <li>Full control over data</li>
            <li>Compliance with strict security policies</li>
            <li>No dependency on external services</li>
          </ul>

          <h3>üõ°Ô∏è Best Practices</h3>
          <ul>
            <li>Regularly clear unused indexes</li>
            <li>Exclude sensitive files from indexing</li>
            <li>Use .gitignore patterns for exclusions</li>
            <li>Encrypt index files if needed</li>
          </ul>

          <h2>Limitations</h2>
          <ul>
            <li>Limited to workspace scope</li>
            <li>Requires initial indexing time</li>
            <li>Performance depends on project size</li>
            <li>No access to external knowledge</li>
          </ul>
        </section>

        <!-- Cloud Agents Section -->
        <section id="cloud-agents" role="article">
          <h1>‚òÅÔ∏è Cloud Agents</h1>
          <span class="badge">cloud</span>
          <span class="badge">remote</span>
          
          <p>Cloud agents leverage GitHub's cloud infrastructure to provide enterprise-wide AI assistance, accessing organization knowledge bases and enforcing company-wide policies.</p>

          <div class="callout">
            <strong>üåê Enterprise Scale</strong><br />
            Cloud agents enable organizations to centralize knowledge, maintain consistency across teams, and deploy AI capabilities at scale.
          </div>

          <h2>Key Capabilities</h2>
          <ul>
            <li><strong>Organization Knowledge:</strong> Access to company-wide documentation and code</li>
            <li><strong>Centralized Management:</strong> Configure and update agents centrally</li>
            <li><strong>Policy Enforcement:</strong> Ensure compliance with company standards</li>
            <li><strong>Scalability:</strong> Serve thousands of developers simultaneously</li>
            <li><strong>Advanced Models:</strong> Access to latest AI models and capabilities</li>
          </ul>

          <h2>GitHub Copilot Enterprise Features</h2>
          
          <h3>üìö Custom Knowledge Base</h3>
          <ul>
            <li>Index private repositories</li>
            <li>Include internal documentation</li>
            <li>Integrate API specifications</li>
            <li>Reference architecture documents</li>
          </ul>

          <h3>üõ°Ô∏è Security & Compliance</h3>
          <pre><code>// Organization policies
{
  "policies": {
    "allowedDomains": ["company.com"],
    "dataRetention": "30days",
    "auditLogging": true,
    "contentFilters": [
      "no-secrets",
      "no-pii",
      "no-proprietary"
    ]
  }
}</code></pre>

          <h3>üìà Usage Analytics</h3>
          <ul>
            <li>Track agent usage across organization</li>
            <li>Measure productivity impact</li>
            <li>Identify popular use cases</li>
            <li>Monitor performance metrics</li>
          </ul>

          <h2>Deployment Models</h2>
          
          <table class="table table-striped">
            <thead>
              <tr>
                <th>Model</th>
                <th>Hosting</th>
                <th>Use Case</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>GitHub Hosted</strong></td>
                <td>GitHub Cloud</td>
                <td>Standard enterprise deployment</td>
              </tr>
              <tr>
                <td><strong>Azure Hosted</strong></td>
                <td>Azure Cloud</td>
                <td>Azure-integrated environments</td>
              </tr>
              <tr>
                <td><strong>Hybrid</strong></td>
                <td>Mixed</td>
                <td>Sensitive data + cloud features</td>
              </tr>
            </tbody>
          </table>

          <h2>Configuration</h2>
          
          <h3>Organization Settings (cloud-config.yaml)</h3>
          <pre><code># Organization-level cloud agent configuration
organization:
  id: acme-corp
  
cloud-agents:
  enabled: true
  
  knowledge-base:
    repositories:
      - acme-corp/platform
      - acme-corp/docs
      - acme-corp/shared-libraries
    documentation:
      - https://docs.company.com
      - https://wiki.company.com
    update-frequency: daily
    
  custom-agents:
    - id: company-standards
      name: standards
      description: Company coding standards and best practices
      model: gpt-4o
      
    - id: architecture-guide
      name: architect
      description: Enterprise architecture guidance
      model: gpt-4o
      
  policies:
    data-retention: 30days
    audit-logging: true
    content-filters:
      - no-secrets
      - no-pii
      - no-proprietary</code></pre>

          <h3>User Access Control (rbac-config.yaml)</h3>
          <pre><code># Role-based access control
access-control:
  roles:
    developer:
      can-use:
        - "@workspace"
        - "@standards"
        - "@docs"
      rate-limit: 1000
      
    architect:
      can-use: "*"
      can-manage: true
      rate-limit: 5000
      
    contractor:
      can-use:
        - "@workspace"
      rate-limit: 500
      restricted-repos:
        - private-core</code></pre>

          <h2>Markdown-Based Cloud Agent Examples</h2>
          
          <h3>Company Standards Agent (.github/agents/cloud/standards.md)</h3>
          <pre><code>---
name: standards
description: Company-wide coding standards and best practices enforcer
type: cloud
user-invokable: true
scope: organization
knowledge-base:
  repositories:
    - org/coding-standards
    - org/architecture-docs
    - org/security-guidelines
  documentation:
    - https://standards.company.com
model: gpt-4o
---

# Company Standards Agent

I enforce coding standards and best practices across the entire organization.

## Knowledge Source

**Organization Repositories:**
- Coding standards documentation
- Architecture decision records (ADRs)
- Security guidelines
- API design patterns
- Database schema conventions

**Company Documentation:**
- Engineering wiki
- Best practices guides
- Style guides (code, API, UI)
- Deployment procedures

## Capabilities

### Code Review
```
@standards review this code for compliance
@standards check naming conventions
@standards validate API design
@standards verify error handling
```

### Architecture Guidance
```
@standards how should I structure a new microservice?
@standards what's our preferred database for caching?
@standards recommend architecture for high-traffic API
@standards validate this system design
```

### Best Practices
```
@standards what's our logging standard?
@standards how do we handle authentication?
@standards show me API versioning patterns
@standards explain our CI/CD workflow
```

## Enforcement Areas

**Code Quality:**
- Naming conventions (camelCase, PascalCase, etc.)
- File organization
- Comment standards
- Code complexity limits
- Test coverage requirements

**Architecture:**
- Microservices boundaries
- Database per service
- API gateway patterns
- Event-driven architecture
- CQRS where applicable

**Security:**
- Authentication patterns (OAuth, JWT)
- Authorization (RBAC, ABAC)
- Encryption standards
- Secret management
- API security

**API Design:**
- RESTful conventions
- Versioning strategy
- Error response format
- Pagination patterns
- Rate limiting

## Cloud Benefits

**Centralized Knowledge:**
- Single source of truth
- Automatically updated
- Organization-wide consistency

**Scale:**
- Available to all developers
- Handles thousands of requests
- Low latency globally

**Management:**
- Centrally configured
- Rollout updates instantly
- Track usage analytics</code></pre>

          <h3>Onboarding Agent (.github/agents/cloud/onboarding.md)</h3>
          <pre><code>---
name: onboarding
description: New developer onboarding assistant
type: cloud
user-invokable: true
scope: organization
knowledge-base:
  repositories:
    - org/developer-handbook
    - org/setup-guides
  documentation:
    - https://onboarding.company.com
---

# Onboarding Agent

I help new developers get up to speed quickly.

## What I Help With

### Environment Setup
```
@onboarding how do I set up my development environment?
@onboarding install required tools
@onboarding configure git and SSH keys
@onboarding set up local databases
```

### Codebase Navigation
```
@onboarding give me a tour of the codebase
@onboarding where is the authentication code?
@onboarding explain the folder structure
@onboarding show me how to run tests
```

### Team Processes
```
@onboarding what's our git workflow?
@onboarding how do I create a pull request?
@onboarding explain the code review process
@onboarding where do I find documentation?
```

### Common Tasks
```
@onboarding how do I add a new API endpoint?
@onboarding show me how to deploy to staging
@onboarding explain our testing standards
@onboarding walk me through a typical feature development
```

## Onboarding Checklist

I track progress through:
1. Environment setup
2. Repository access
3. First PR merged
4. Tests written
5. Deployed to staging
6. Production deployment</code></pre>

          <h3>Security Agent (.github/agents/cloud/security-advisor.md)</h3>
          <pre><code>---
name: security
description: Organization-wide security advisor and vulnerability scanner
type: cloud
user-invokable: true
scope: organization
knowledge-base:
  repositories:
    - org/security-policies
    - org/threat-models
  external:
    - CVE database
    - OWASP guidelines
    - Security advisories
---

# Security Advisor Agent

I provide security guidance and scan for vulnerabilities across all organization repositories.

## Security Checks

### Code Analysis
```
@security scan this code for vulnerabilities
@security check for SQL injection
@security verify authentication implementation
@security analyze dependencies for CVEs
```

### Architecture Review
```
@security review this system design
@security check API security
@security validate encryption approach
@security assess data flow security
```

### Compliance
```
@security check GDPR compliance
@security verify SOC 2 requirements
@security validate PCI DSS controls
@security audit access controls
```

## Organization-Wide Monitoring

**Continuous Scanning:**
- All repositories for secrets
- Dependencies for CVEs
- Infrastructure configs
- API endpoints

**Alerting:**
- Critical vulnerabilities (immediate)
- High-risk patterns detected
- Compliance violations
- Unusual access patterns</code></pre>

          <h2>Integration Patterns</h2>
          
          <h3>üîó Repository Integration</h3>
          <ul>
            <li>Automatic indexing of new commits</li>
            <li>Pull request analysis</li>
            <li>Code review assistance</li>
            <li>Dependency tracking</li>
          </ul>

          <h3>üìä Analytics Integration</h3>
          <ul>
            <li>Export metrics to data warehouse</li>
            <li>Dashboard integrations</li>
            <li>Custom reporting</li>
          </ul>

          <h2>Use Cases</h2>
          
          <h3>üèóÔ∏è New Developer Onboarding</h3>
          <pre><code>@company how do I set up the development environment?
@company what's our deployment process?
@company show me examples of our API design patterns</code></pre>

          <h3>üìú Architecture Guidance</h3>
          <pre><code>@standards how should I structure a new microservice?
@standards what's our preferred logging approach?
@standards validate this database schema design</code></pre>

          <h3>üîç Code Review</h3>
          <pre><code>@reviewer check this PR for standards compliance
@reviewer identify security concerns
@reviewer suggest performance improvements</code></pre>

          <h2>Benefits</h2>
          
          <h3>‚úÖ For Organizations</h3>
          <ul>
            <li>Consistent code quality across teams</li>
            <li>Faster developer onboarding</li>
            <li>Centralized knowledge management</li>
            <li>Improved compliance and security</li>
            <li>Data-driven insights into development</li>
          </ul>

          <h3>‚úÖ For Developers</h3>
          <ul>
            <li>Access to company expertise</li>
            <li>Less time searching for information</li>
            <li>Automated best practice guidance</li>
            <li>Context-aware suggestions</li>
          </ul>

          <h2>Cost Considerations</h2>
          <ul>
            <li>Per-user licensing (GitHub Copilot Enterprise)</li>
            <li>API usage for custom integrations</li>
            <li>Storage for knowledge bases</li>
            <li>Compute for model fine-tuning</li>
          </ul>

          <h2>Migration Path</h2>
          
          <h3>Step 1: Pilot Program</h3>
          <ul>
            <li>Start with small team</li>
            <li>Test with non-critical projects</li>
            <li>Gather feedback</li>
          </ul>

          <h3>Step 2: Knowledge Base Setup</h3>
          <ul>
            <li>Identify key repositories</li>
            <li>Curate documentation</li>
            <li>Configure indexing</li>
          </ul>

          <h3>Step 3: Rollout</h3>
          <ul>
            <li>Gradual team expansion</li>
            <li>Training and support</li>
            <li>Monitor usage and feedback</li>
          </ul>

          <h3>Step 4: Optimization</h3>
          <ul>
            <li>Refine knowledge base</li>
            <li>Add custom agents</li>
            <li>Integrate with workflows</li>
          </ul>
        </section>

        <!-- Third Party Agents Section -->
        <section id="third-party-agents" role="article">
          <h1>üîå Third Party Agents</h1>
          <span class="badge">third-party</span>
          <span class="badge">extensions</span>
          
          <p>Third-party agents integrate external tools, services, and platforms with GitHub Copilot, extending its capabilities beyond code to your entire development ecosystem.</p>

          <div class="callout">
            <strong>üåê Ecosystem Integration</strong><br />
            Connect Copilot with issue trackers, CI/CD platforms, cloud services, databases, and more to create a unified AI-powered development experience.
          </div>

          <h2>Categories</h2>
          
          <h3>üé´ Project Management</h3>
          <ul>
            <li><strong>Jira Agent:</strong> Create, update, and query Jira issues</li>
            <li><strong>Azure DevOps Agent:</strong> Manage work items and boards</li>
            <li><strong>Trello Agent:</strong> Sync tasks with Trello boards</li>
            <li><strong>Linear Agent:</strong> Track issues and project status</li>
          </ul>

          <h3>‚òÅÔ∏è Cloud Platforms</h3>
          <ul>
            <li><strong>AWS Agent:</strong> Deploy and manage AWS resources</li>
            <li><strong>Azure Agent:</strong> Azure resource management</li>
            <li><strong>GCP Agent:</strong> Google Cloud operations</li>
            <li><strong>Kubernetes Agent:</strong> Cluster management and deployment</li>
          </ul>

          <h3>üìÑ Documentation</h3>
          <ul>
            <li><strong>Confluence Agent:</strong> Search and update documentation</li>
            <li><strong>Notion Agent:</strong> Access knowledge bases</li>
            <li><strong>SharePoint Agent:</strong> Enterprise document management</li>
          </ul>

          <h3>üìä Analytics & Monitoring</h3>
          <ul>
            <li><strong>Datadog Agent:</strong> Monitor application performance</li>
            <li><strong>New Relic Agent:</strong> Analyze metrics and logs</li>
            <li><strong>Sentry Agent:</strong> Error tracking and debugging</li>
          </ul>

          <h2>Popular Third-Party Agents</h2>
          
          <h3>üêõ Jira Integration</h3>
          <pre><code>@jira create a bug for authentication error
@jira what's the status of PROJ-123?
@jira assign PROJ-456 to me
@jira show my open issues</code></pre>

          <h3>‚òÅÔ∏è AWS Assistant</h3>
          <pre><code>@aws deploy this Lambda function
@aws what's the status of my EC2 instances?
@aws create an S3 bucket for uploads
@aws show CloudWatch logs for my-app</code></pre>

          <h3>üê≥ Docker & Kubernetes</h3>
          <pre><code>@docker build and push this image
@k8s deploy to production
@k8s show pod logs for api-service
@k8s scale deployment to 5 replicas</code></pre>

          <h2>Markdown-Based Third-Party Agent Examples</h2>
          
          <h3>Jira Integration Agent (.github/agents/integrations/jira.md)</h3>
          <pre><code>---
name: jira
description: Jira issue tracking integration
type: third-party
user-invokable: true
commands:
  - name: create
    description: Create a new Jira issue
  - name: update
    description: Update an existing issue
  - name: query
    description: Search for issues
  - name: assign
    description: Assign issue to user
api:
  base-url: https://company.atlassian.net
  authentication: api-token
  rate-limit: 100/minute
configuration:
  - name: jira.host
    required: true
    description: Jira instance URL
  - name: jira.project
    required: false
    description: Default project key
---

# Jira Integration Agent

I integrate with Jira to manage issues, track work, and update tickets without leaving your editor.

## Commands

### /create - Create Issue

Create new Jira issues:

```
@jira /create a bug for authentication error
@jira /create story: Add password reset feature
@jira /create task in PROJECT-123 to update dependencies
```

**I will:**
1. Parse your description
2. Determine issue type (bug, story, task)
3. Extract key details
4. Create issue in Jira
5. Return issue key and link

### /query - Search Issues

Find and display issues:

```
@jira /query my open issues
@jira /query bugs in PROJECT assigned to me
@jira /query all stories in current sprint
@jira /query issues updated this week
```

### /update - Update Issue

Modify existing issues:

```
@jira /update PROJECT-123 status to In Progress
@jira /update PROJECT-456 add comment "Fixed in PR #789"
@jira /update PROJECT-789 priority to High
```

### /assign - Assign Issue

Assign issues to team members:

```
@jira /assign PROJECT-123 to me
@jira /assign PROJECT-456 to john.doe
@jira /assign PROJECT-789 to current sprint
```

## Issue Creation Intelligence

I automatically:
- Extract issue type from keywords (bug, feature, story, task)
- Parse priority indicators (urgent, high, low)
- Detect affected components from context
- Suggest labels based on content
- Link to current file/code if relevant

## Workflow Integration

**From Code Comments:**
```javascript
// TODO: Fix authentication timeout issue
// @jira create bug
```
I detect this and create: "Bug: Fix authentication timeout issue"

**From Pull Requests:**
```
@jira /create story from this PR description
```
I extract: title, description, acceptance criteria

**From Error Messages:**
```
@jira /create bug from this stack trace
```
I include: error message, stack trace, file location

## Smart Features

**Context Awareness:**
- Detect current file and include in description
- Reference open PRs
- Link related commits
- Tag affected components

**Auto-linking:**
- Link code to issues
- Update issues when PRs merge
- Close issues on deployment

## Configuration

Required settings:
```yaml
jira:
  host: company.atlassian.net
  project: PROJ  # Default project
  credentials:
    type: api-token
    token: ${JIRA_API_TOKEN}  # From environment
```

## Security

- API tokens stored in secure credential store
- Never log sensitive data
- HTTPS for all communications
- Token expires after 90 days
- Requires user authentication</code></pre>

          <h3>AWS Integration Agent (.github/agents/integrations/aws.md)</h3>
          <pre><code>---
name: aws
description: AWS cloud services management and deployment
type: third-party
user-invokable: true
commands:
  - name: deploy
    description: Deploy application to AWS
  - name: status
    description: Check resource status
  - name: logs
    description: View CloudWatch logs
  - name: create
    description: Create AWS resources
api:
  authentication: aws-credentials
  regions:
    - us-east-1
    - us-west-2
    - eu-west-1
configuration:
  - name: aws.region
    required: true
  - name: aws.profile
    required: false
---

# AWS Integration Agent

I help you manage AWS resources, deploy applications, and monitor cloud infrastructure.

## Commands

### /deploy - Deploy Applications

Deploy code to AWS:

```
@aws /deploy this Lambda function
@aws /deploy to ECS production
@aws /deploy static site to S3
@aws /deploy API to API Gateway
```

**Supported Services:**
- Lambda functions
- ECS/Fargate containers
- S3 static hosting
- API Gateway
- CloudFront

### /status - Resource Status

Check AWS resources:

```
@aws /status EC2 instances
@aws /status my Lambda functions
@aws /status RDS databases
@aws /status S3 buckets
```

### /logs - CloudWatch Logs

View application logs:

```
@aws /logs for my-lambda-function
@aws /logs from last 1 hour
@aws /logs error messages only
@aws /logs follow (real-time)
```

### /create - Create Resources

Provision AWS resources:

```
@aws /create S3 bucket for uploads
@aws /create Lambda function for image processing
@aws /create RDS PostgreSQL database
@aws /create DynamoDB table for sessions
```

## Infrastructure as Code

I can generate:
- CloudFormation templates
- Terraform configurations
- AWS CDK code
- SAM templates

## Security Best Practices

**I enforce:**
- IAM least privilege
- Encryption at rest
- VPC security groups
- KMS key management
- CloudTrail logging

## Cost Awareness

I warn about:
- Expensive resource types
- Always-on instances
- Unoptimized storage
- Data transfer costs
- Unused resources</code></pre>

          <h3>Slack Integration Agent (.github/agents/integrations/slack.md)</h3>
          <pre><code>---
name: slack
description: Slack workspace integration for team communication
type: third-party
user-invokable: true
commands:
  - name: send
    description: Send message to channel
  - name: notify
    description: Notify user or channel
  - name: status
    description: Update Slack status
---

# Slack Integration Agent

I integrate with Slack for team notifications and updates.

## Commands

### /send - Send Messages

```
@slack /send to #engineering "Deployment complete"
@slack /send DM to @john "Code review ready"
@slack /send to #alerts with deployment summary
```

### /notify - Smart Notifications

```
@slack /notify team of build failure
@slack /notify on-call about production issue
@slack /notify #releases when PR merges
```

### /status - Update Status

```
@slack /status set to "In a meeting"
@slack /status clear
@slack /status "Deploying" until 3pm
```

## Automation

**Automatic Notifications:**
- Build failures ‚Üí #engineering
- Security alerts ‚Üí #security
- Deployments ‚Üí #releases
- PR reviews ‚Üí Reviewers DM</code></pre>

          <h3>GitHub Integration Agent (.github/agents/integrations/github.md)</h3>
          <pre><code>---
name: github
description: GitHub repository and PR management
type: third-party
user-invokable: true
commands:
  - name: pr
    description: Create or manage pull requests
  - name: issue
    description: Manage GitHub issues
  - name: review
    description: Code review operations
  - name: actions
    description: GitHub Actions management
---
# GitHub Integration Agent

I help manage GitHub repositories, PRs, and workflows.

## Commands

### /pr - Pull Request Management

```
@github /pr create from current branch
@github /pr status of #123
@github /pr merge #456
@github /pr request review from @team
```

### /issue - Issue Management

```
@github /issue create bug for this error
@github /issue list my assigned issues
@github /issue close #789
```

### /review - Code Reviews

```
@github /review PR #123
@github /review suggest improvements
@github /review check for security issues
```

### /actions - Workflow Management

```
@github /actions status
@github /actions re-run failed jobs
@github /actions view logs
```</code></pre>

          <h2>Configuration</h2>
          
          <h3>Extension Settings</h3>
          <pre><code>// settings.json
{
  "thirdPartyAgents": {
    "jira": {
      "enabled": true,
      "host": "company.atlassian.net",
      "defaultProject": "PROJ"
    },
    "aws": {
      "enabled": true,
      "region": "us-east-1",
      "profile": "default"
    },
    "slack": {
      "enabled": true,
      "workspace": "company-workspace"
    }
  }
}</code></pre>

          <h2>Security Considerations</h2>
          
          <h3>üîí Best Practices</h3>
          <ul>
            <li>Never hardcode credentials</li>
            <li>Use VS Code SecretStorage API</li>
            <li>Implement OAuth where possible</li>
            <li>Request minimal permissions</li>
            <li>Validate all external data</li>
            <li>Log security events</li>
          </ul>

          <h3>‚ö†Ô∏è Data Privacy</h3>
          <ul>
            <li>Disclose what data is sent to third parties</li>
            <li>Allow users to opt-in/opt-out</li>
            <li>Provide data deletion options</li>
            <li>Comply with GDPR/privacy regulations</li>
          </ul>

          <h2>Generic Third-Party Agent Template</h2>
          
          <h3>Template for Any Service (.github/agents/integrations/template.md)</h3>
          <pre><code>---
name: service-name
description: Brief description of the service integration
type: third-party
user-invokable: true
commands:
  - name: action1
    description: What this command does
  - name: action2
    description: What this command does
api:
  base-url: https://api.service.com
  authentication: api-key | oauth | basic
  rate-limit: 100/minute
configuration:
  - name: service.api_key
    required: true
    description: API key for authentication
  - name: service.endpoint
    required: false
    description: Custom endpoint URL
permissions:
  - read
  - write
  - delete
---

# Service Name Integration Agent

I integrate with [Service Name] to [primary purpose].

## What I Can Do

[List main capabilities]

## Commands

### /action1 - [Action Description]

[Detailed description of what this command does]

**Examples:**
```
@service-name /action1 example usage
@service-name /action1 another example
```

**I will:**
1. [Step 1]
2. [Step 2]
3. [Step 3]

### /action2 - [Action Description]

[Detailed description]

## Configuration

Required settings:
```yaml
service-name:
  api-key: ${SERVICE_API_KEY}
  workspace: your-workspace
  default-project: project-id
```

## Authentication

[How authentication works]

**OAuth Flow:**
1. User authorizes app
2. Receive access token
3. Store securely
4. Refresh when needed

**API Key:**
1. Get from service settings
2. Store in environment variable
3. Never commit to code

## Security & Privacy

**Data Handling:**
- What data is sent to the service
- How data is stored
- Retention policies
- User control options

**Best Practices:**
- Use environment variables for secrets
- Validate all inputs
- Implement rate limiting
- Log API calls for audit

## Error Handling

Common errors and solutions:
- **Authentication Failed**: Check API key
- **Rate Limit**: Wait and retry
- **Not Found**: Verify resource exists

## Examples

[Real-world usage examples]

## Limitations

- [Any limitations]
- [Rate limits]
- [Feature restrictions]

## Support

- Documentation: [URL]
- API Reference: [URL]
- Issues: [URL]</code></pre>

          <h2>Common Integration Patterns</h2>
          
          <h3>üîÑ Bidirectional Sync</h3>
          <ul>
            <li>Keep VS Code and external tool in sync</li>
            <li>Handle conflict resolution</li>
            <li>Implement efficient polling/webhooks</li>
          </ul>

          <h3>üì° Event-Driven Updates</h3>
          <ul>
            <li>React to external events</li>
            <li>Notify users of changes</li>
            <li>Update local state automatically</li>
          </ul>

          <h3>üîç Search & Discovery</h3>
          <ul>
            <li>Provide fuzzy search capabilities</li>
            <li>Implement filters and facets</li>
            <li>Cache frequent queries</li>
          </ul>

          <h2>Popular Extensions</h2>
          
          <table class="table table-striped">
            <thead>
              <tr>
                <th>Extension</th>
                <th>Service</th>
                <th>Key Features</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>GitHub Pull Requests</strong></td>
                <td>GitHub</td>
                <td>PR reviews, issue management</td>
              </tr>
              <tr>
                <td><strong>Azure Tools</strong></td>
                <td>Azure</td>
                <td>Resource management, deployment</td>
              </tr>
              <tr>
                <td><strong>Docker</strong></td>
                <td>Docker</td>
                <td>Container management</td>
              </tr>
              <tr>
                <td><strong>Kubernetes</strong></td>
                <td>K8s</td>
                <td>Cluster operations</td>
              </tr>
            </tbody>
          </table>

          <h2>Discovery & Installation</h2>
          
          <h3>VS Code Marketplace</h3>
          <ul>
            <li>Search for "Copilot Agent" or specific services</li>
            <li>Check ratings and reviews</li>
            <li>Verify publisher authenticity</li>
            <li>Review required permissions</li>
          </ul>

          <h3>Enterprise Distribution</h3>
          <ul>
            <li>Internal marketplace</li>
            <li>Pre-approved extension list</li>
            <li>Automatic deployment via policy</li>
          </ul>
        </section>

        <!-- Agent Tools Section -->
        <section id="agent-tools" role="article">
          <h1>üõ†Ô∏è Agent Tools</h1>
          <span class="badge">tools</span>
          <span class="badge">capabilities</span>
          <span class="badge">actions</span>
          
          <p>Agent tools are the capabilities that agents can use to interact with your development environment, files, terminal, and external services. They enable agents to go beyond conversation and take action.</p>

          <div class="callout">
            <strong>üí° Tools = Actions</strong><br />
            Tools allow agents to read files, execute commands, search code, make API calls, and modify your workspace‚Äîturning conversational AI into an active development assistant.
          </div>

          <h2>Built-in Tool Categories</h2>

          <div style="display: grid; grid-template-columns: repeat(auto-fit, minmax(320px, 1fr)); gap: 20px; margin: 30px 0;">
            
            <!-- File & Code -->
            <div style="background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%); border-left: 5px solid #f97316; border-radius: 8px; padding: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.08);">
              <h3 style="margin-top: 0; color: #ea580c; display: flex; align-items: center; gap: 10px; font-weight: 600;">
                <span style="font-size: 24px;">üìÅ</span> File & Code
              </h3>
              <ul style="margin: 15px 0; padding-left: 20px; line-height: 1.8; color: #78350f;">
                <li>Read / write files</li>
                <li>Search codebase (semantic + regex)</li>
                <li>Create / delete / rename files</li>
                <li>Edit with precise diffs</li>
                <li>Analyze ASTs & symbols</li>
              </ul>
            </div>

            <!-- Terminal -->
            <div style="background: linear-gradient(135deg, #e9d5ff 0%, #d8b4fe 100%); border-left: 5px solid #7c3aed; border-radius: 8px; padding: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.08);">
              <h3 style="margin-top: 0; color: #6d28d9; display: flex; align-items: center; gap: 10px; font-weight: 600;">
                <span style="font-size: 24px;">üíª</span> Terminal
              </h3>
              <ul style="margin: 15px 0; padding-left: 20px; line-height: 1.8; color: #581c87;">
                <li>Run shell commands</li>
                <li>Execute build scripts</li>
                <li>Run test suites</li>
                <li>Install dependencies</li>
                <li>Start/stop dev servers</li>
              </ul>
            </div>

            <!-- Web & APIs -->
            <div style="background: linear-gradient(135deg, #ccfbf1 0%, #99f6e4 100%); border-left: 5px solid #0d9488; border-radius: 8px; padding: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.08);">
              <h3 style="margin-top: 0; color: #0f766e; display: flex; align-items: center; gap: 10px; font-weight: 600;">
                <span style="font-size: 24px;">üåê</span> Web & APIs
              </h3>
              <ul style="margin: 15px 0; padding-left: 20px; line-height: 1.8; color: #134e4a;">
                <li>Fetch URLs & docs</li>
                <li>Call REST / GraphQL APIs</li>
                <li>Search the web</li>
                <li>Scrape & summarize pages</li>
                <li>OAuth-authenticated requests</li>
              </ul>
            </div>

            <!-- GitHub Native -->
            <div style="background: linear-gradient(135deg, #dcfce7 0%, #bbf7d0 100%); border-left: 5px solid #059669; border-radius: 8px; padding: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.08);">
              <h3 style="margin-top: 0; color: #047857; display: flex; align-items: center; gap: 10px; font-weight: 600;">
                <span style="font-size: 24px;">üë§</span> GitHub Native
              </h3>
              <ul style="margin: 15px 0; padding-left: 20px; line-height: 1.8; color: #14532d;">
                <li>Create / comment on Issues</li>
                <li>Open & update Pull Requests</li>
                <li>Trigger GitHub Actions</li>
                <li>Read repo metadata</li>
                <li>Access Discussions & Projects</li>
              </ul>
            </div>

            <!-- Memory & Context -->
            <div style="background: linear-gradient(135deg, #fce7f3 0%, #fbcfe8 100%); border-left: 5px solid #be185d; border-radius: 8px; padding: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.08);">
              <h3 style="margin-top: 0; color: #9f1239; display: flex; align-items: center; gap: 10px; font-weight: 600;">
                <span style="font-size: 24px;">üß†</span> Memory & Context
              </h3>
              <ul style="margin: 15px 0; padding-left: 20px; line-height: 1.8; color: #831843;">
                <li>In-session scratchpad</li>
                <li>Inject repository context</li>
                <li>Read prompt files</li>
                <li>Track conversation history</li>
                <li>Reference previous tool outputs</li>
              </ul>
            </div>

            <!-- MCP Servers -->
            <div style="background: linear-gradient(135deg, #fed7aa 0%, #fdba74 100%); border-left: 5px solid #ea580c; border-radius: 8px; padding: 20px; box-shadow: 0 2px 8px rgba(0,0,0,0.08);">
              <h3 style="margin-top: 0; color: #c2410c; display: flex; align-items: center; gap: 10px; font-weight: 600;">
                <span style="font-size: 24px;">üîó</span> MCP Servers
              </h3>
              <ul style="margin: 15px 0; padding-left: 20px; line-height: 1.8; color: #7c2d12;">
                <li>Connect to custom tool servers</li>
                <li>DB queries (Postgres, SQLite...)</li>
                <li>Calendar & email access</li>
                <li>Slack / Teams messaging</li>
                <li>Any protocol-compliant tool</li>
              </ul>
            </div>

          </div>

          <h2>Tool Execution Flow</h2>
          
          <h3>Request Flow</h3>
          <pre><code>User: "@workspace read the auth.ts file"

1. Agent receives request
2. Agent identifies needed tool: read_file
3. Agent determines parameters: { path: "src/auth.ts" }
4. Tool executes and returns result
5. Agent incorporates result into response
6. User sees: "Here's the content of auth.ts: ..."
</code></pre>

          <h3>Multi-Tool Orchestration</h3>
          <pre><code>User: "Find all TODO comments and create a task list"

1. grep_search tool: Find all "TODO" comments
2. read_file tool: Get context around each TODO
3. External API: Create tasks in project management tool
4. Response: "Created 5 tasks from TODO comments"</code></pre>

          <h2>Tool Safety & Permissions</h2>
          
          <h3>Permission Levels</h3>
          <table class="table table-striped">
            <thead>
              <tr>
                <th>Level</th>
                <th>Capabilities</th>
                <th>User Consent</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Read-Only</strong></td>
                <td>Read files, search code</td>
                <td>Automatic</td>
              </tr>
              <tr>
                <td><strong>Workspace</strong></td>
                <td>Modify files in workspace</td>
                <td>Per-action or blanket</td>
              </tr>
              <tr>
                <td><strong>System</strong></td>
                <td>Execute commands, access network</td>
                <td>Explicit per-action</td>
              </tr>
              <tr>
                <td><strong>External</strong></td>
                <td>Call external APIs</td>
                <td>Explicit + credentials</td>
              </tr>
            </tbody>
          </table>

          <h2>Best Practices</h2>
          
          <h3>‚úÖ Effective Tool Design</h3>
          <ul>
            <li>Clear, descriptive tool names</li>
            <li>Comprehensive parameter documentation</li>
            <li>Meaningful error messages</li>
            <li>Idempotent operations where possible</li>
            <li>Progress reporting for long operations</li>
          </ul>

          <h3>‚ö†Ô∏è Security</h3>
          <ul>
            <li>Validate all inputs</li>
            <li>Sanitize file paths (prevent traversal)</li>
            <li>Limit command execution scope</li>
            <li>Rate limit expensive operations</li>
            <li>Audit tool usage</li>
          </ul>
        </section>

        <!-- Agent Planning Section -->
        <section id="agent-planning" role="article">
          <h1>üìã Agent Planning</h1>
          <span class="badge">planning</span>
          <span class="badge">orchestration</span>
          <span class="badge">workflow</span>
          
          <p>Agent planning enables AI assistants to break down complex tasks into manageable steps, orchestrate multi-tool workflows, and execute sophisticated operations autonomously.</p>

          <div class="callout">
            <strong>üß† Strategic Thinking</strong><br />
            Instead of just responding to prompts, planning agents create action plans, anticipate dependencies, and execute multi-step workflows to accomplish complex goals.
          </div>

          <h2>Planning Capabilities</h2>
          
          <h3>üéØ Task Decomposition</h3>
          <ul>
            <li>Break complex requests into subtasks</li>
            <li>Identify dependencies between steps</li>
            <li>Determine optimal execution order</li>
            <li>Parallelize independent operations</li>
          </ul>

          <h3>üîÑ Workflow Orchestration</h3>
          <ul>
            <li>Coordinate multiple tools and agents</li>
            <li>Handle conditional logic and branching</li>
            <li>Manage error recovery and retries</li>
            <li>Track progress and state</li>
          </ul>

          <h2>Planning Modes</h2>
          
          <table class="table table-striped">
            <thead>
              <tr>
                <th>Mode</th>
                <th>Description</th>
                <th>Use Case</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Single-Shot</strong></td>
                <td>Create complete plan upfront</td>
                <td>Well-defined tasks with clear steps</td>
              </tr>
              <tr>
                <td><strong>Iterative</strong></td>
                <td>Plan and execute incrementally</td>
                <td>Exploratory tasks, uncertain outcomes</td>
              </tr>
              <tr>
                <td><strong>Reactive</strong></td>
                <td>Adjust plan based on results</td>
                <td>Complex debugging, adaptive workflows</td>
              </tr>
              <tr>
                <td><strong>Human-in-Loop</strong></td>
                <td>Request approval at key steps</td>
                <td>Critical operations, learning</td>
              </tr>
            </tbody>
          </table>

          <h2>Planning Process</h2>
          
          <h3>Phase 1: Understanding</h3>
          <pre><code>User: "Refactor the authentication module to use OAuth2"

Agent Analysis:
- Identify current auth implementation
- Understand OAuth2 requirements
- Assess impact on existing code
- Identify affected components</code></pre>

          <h3>Phase 2: Planning</h3>
          <pre><code>Generated Plan:
1. üîç Analyze current auth.ts implementation
2. üìö Research OAuth2 best practices
3. üèóÔ∏è Create new OAuth2Service class
4. üîÑ Update AuthController to use OAuth2Service
5. üß™ Modify login and logout endpoints
6. ‚öôÔ∏è Update configuration files
7. üßπ Remove deprecated password-based auth
8. ‚úÖ Update tests
9. üìù Update documentation</code></pre>

          <h3>Phase 3: Execution</h3>
          <pre><code>Execution Log:
‚úÖ Step 1: Analyzed auth.ts (found PasswordAuth class)
‚úÖ Step 2: Retrieved OAuth2 patterns from knowledge base
üîÑ Step 3: Creating OAuth2Service...
   - Generated OAuth2Service.ts
   - Added configuration interface
   - Implemented token exchange
‚è∏Ô∏è  Paused: User review requested for OAuth2Service</code></pre>

          <h3>Phase 4: Review & Adapt</h3>
          <pre><code>User Feedback: "Looks good, but add refresh token support"

Agent Updates Plan:
3a. Add RefreshTokenService
3b. Integrate with OAuth2Service
‚ñ∂Ô∏è Resuming execution...</code></pre>

          <h2>Example: Multi-Step Workflow</h2>
          
          <h3>Task: "Create a REST API for user management"</h3>
          <pre><code>User: @workspace /new Create a REST API for user management

Agent Plan:

üìã PLANNING PHASE
‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
1. Design API structure
   - Define routes (GET, POST, PUT, DELETE)
   - Plan DTOs and validation
   - Determine database schema

2. Generate code files
   - User model (src/models/User.ts)
   - User controller (src/controllers/UserController.ts)
   - User service (src/services/UserService.ts)
   - Routes configuration (src/routes/users.ts)

3. Add dependencies
   - express
   - class-validator
   - typeorm

4. Create tests
   - Unit tests for service
   - Integration tests for API

5. Update documentation
   - Add API docs to README
   - Generate OpenAPI spec

Proceed with execution? (y/n)</code></pre>

          <h2>Planning Strategies</h2>
          
          <h3>üéØ Goal-Oriented Planning</h3>
          <ul>
            <li>Start with end goal</li>
            <li>Work backwards to identify steps</li>
            <li>Ensure each step contributes to goal</li>
          </ul>

          <h3>üß© Constraint-Based Planning</h3>
          <ul>
            <li>Identify constraints (time, resources, dependencies)</li>
            <li>Generate plan that satisfies all constraints</li>
            <li>Optimize for efficiency</li>
          </ul>

          <h3>üîÄ Feedback-Driven Planning</h3>
          <ul>
            <li>Execute initial steps</li>
            <li>Observe results</li>
            <li>Adjust plan based on findings</li>
            <li>Iterate until goal achieved</li>
          </ul>

          <h2>Advanced Features</h2>
          
          <h3>ü§ù Parallel Execution</h3>
          <pre><code>Plan with parallelization:

1. Setup Phase
   ‚îî‚îÄ Install dependencies

2. Development Phase (parallel)
   ‚îú‚îÄ Create models üîÑ
   ‚îú‚îÄ Create services üîÑ
   ‚îî‚îÄ Create controllers üîÑ

3. Integration Phase (after 2 completes)
   ‚îú‚îÄ Wire up routes
   ‚îî‚îÄ Add middleware

4. Testing Phase (parallel)
   ‚îú‚îÄ Unit tests üîÑ
   ‚îî‚îÄ Integration tests üîÑ</code></pre>

          <h3>üö´ Error Handling</h3>
          <pre><code>async function executePlanWithRecovery(plan) {
  for (const step of plan.steps) {
    try {
      await executeStep(step);
    } catch (error) {
      // Analyze error
      const recovery = await planRecovery(step, error);
      
      if (recovery.canRecover) {
        // Try alternative approach
        await executeStep(recovery.alternativeStep);
      } else {
        // Escalate to user
        await requestUserIntervention(step, error);
      }
    }
  }
}</code></pre>

          <h3>üìä Progress Tracking</h3>
          <pre><code>Plan Progress:
‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë 60% Complete

‚úÖ 1. Analyze requirements
‚úÖ 2. Design schema
‚úÖ 3. Generate models
üîÑ 4. Create services (in progress)
‚è∏Ô∏è  5. Build controllers (waiting)
‚è∏Ô∏è  6. Add tests (waiting)

Estimated time remaining: 2 minutes</code></pre>

          <h2>Plan Visualization</h2>
          
          <h3>Dependency Graph</h3>
          <pre><code>Requirements
    ‚îÇ
    ‚îî‚îÄ‚îÄ‚îÄ Design
         ‚îú‚îÄ‚îÄ‚îÄ Models
         ‚îÇ    ‚îî‚îÄ‚îÄ‚îÄ Services
         ‚îÇ         ‚îî‚îÄ‚îÄ‚îÄ Controllers
         ‚îÇ              ‚îî‚îÄ‚îÄ‚îÄ Routes
         ‚îÇ                   ‚îî‚îÄ‚îÄ‚îÄ Tests
         ‚îî‚îÄ‚îÄ‚îÄ Documentation</code></pre>

          <h2>User Interaction</h2>
          
          <h3>Approval Checkpoints</h3>
          <pre><code>// Configure approval points
plan.addCheckpoint({
  after: 'generate-code',
  before: 'modify-files',
  message: 'Review generated code before applying?',
  required: true
});</code></pre>

          <h3>Plan Modification</h3>
          <pre><code>User: "Skip the documentation step"

Agent: ‚úÖ Removed step 9 (Update documentation)
Updated plan: 8 steps remaining</code></pre>

          <h2>Best Practices</h2>
          
          <h3>‚úÖ Effective Planning</h3>
          <ul>
            <li>Break tasks into atomic, testable steps</li>
            <li>Make dependencies explicit</li>
            <li>Include validation after each step</li>
            <li>Provide clear progress indicators</li>
            <li>Allow user to pause/modify plan</li>
            <li>Include rollback capability</li>
          </ul>

          <h3>‚ö†Ô∏è Pitfalls to Avoid</h3>
          <ul>
            <li>Over-planning (analysis paralysis)</li>
            <li>Inflexible plans that can't adapt</li>
            <li>Steps that are too coarse-grained</li>
            <li>Ignoring user feedback/intervention</li>
            <li>No fallback for failed steps</li>
          </ul>
        </section>

        <!-- SubAgents Section -->
        <section id="subagents" role="article">
          <h1>ü§ñ SubAgents</h1>
          <span class="badge">subagents</span>
          <span class="badge">delegation</span>
          <span class="badge">hierarchy</span>
          
          <p>SubAgents enable agents to delegate specialized tasks to other agents, creating powerful hierarchical workflows. VS Code Copilot supports two types of subagents: programmatic (code-based) and chat-based (@-invoked).</p>

          <div class="callout">
            <strong>üéØ Master Collaboration</strong><br />
            SubAgents allow parent agents to orchestrate multiple specialized agents, combining their expertise to solve complex problems more effectively than any single agent could alone.
          </div>

          <h2>SubAgent Architecture</h2>
          
          <div class="mermaid">
%%{ init: { "theme": "base", "fontFamily": "Segoe UI Semibold", "fontSize": "18px" }}%%
graph TB
    User["üë§ User"] -->|Request| Parent["@workspace Agent"]
    
    Parent -->|Delegate| SA1["@vscode SubAgent"]
    Parent -->|Delegate| SA2["@terminal SubAgent"]
    Parent -->|Delegate| SA3["Custom SubAgent"]
    Parent -->|Delegate| SA4["Code-based SubAgent"]
    
    SA1 -->|Result| Parent
    SA2 -->|Result| Parent
    SA3 -->|Result| Parent
    SA4 -->|Result| Parent
    
    Parent -->|Unified Response| User
    
    style Parent fill:#0078d4,color:#fff
    style SA1 fill:#10a37f,color:#fff
    style SA2 fill:#10a37f,color:#fff
    style SA3 fill:#10a37f,color:#fff
    style SA4 fill:#10a37f,color:#fff
          </div>

          <h2>Two Types of SubAgents</h2>
          
          <table class="table table-striped">
            <thead>
              <tr>
                <th>Type</th>
                <th>Invocation</th>
                <th>Use Case</th>
                <th>Example</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Chat-Based</strong></td>
                <td>@-syntax in chat</td>
                <td>Invoke built-in or third-party agents</td>
                <td><code>@workspace use @vscode to...</code></td>
              </tr>
              <tr>
                <td><strong>Code-Based</strong></td>
                <td>Programmatic API</td>
                <td>Custom delegation logic in extensions</td>
                <td><code>runSubagent(...)</code></td>
              </tr>
            </tbody>
          </table>

          <h2>Chat-Based SubAgents (VS Code)</h2>
          
          <h3>Using @ to Invoke SubAgents</h3>
          <p>Any agent can invoke another agent using the @ symbol within its response or workflow.</p>
          
          <div class="callout">
            <strong>üìñ Reference</strong><br />
            Learn more: <a href="https://code.visualstudio.com/docs/copilot/agents/subagents" target="_blank" rel="noopener">VS Code SubAgents Documentation</a> | 
            <a href="https://imaginet.com/2025/mastering-subagents-in-vs-code-copilot-how-to-actually-use-them/" target="_blank" rel="noopener">Mastering SubAgents Guide</a>
          </div>

          <h3>Basic Syntax</h3>
          <pre><code># User asks @workspace
@workspace how do I change my theme and list running processes?

# @workspace delegates to other agents:
@workspace: I'll help you with both tasks.

1. For theme changes, I'll ask @vscode:
   @vscode change to dark theme
   
2. For processes, I'll ask @terminal:
   @terminal list all running processes

# Result combines both subagent responses</code></pre>

          <h3>SubAgent Invocation Patterns</h3>
          
          <h4>Pattern 1: Sequential Delegation</h4>
          <pre><code>User: @workspace analyze this file and fix issues

@workspace response:
1. First, I'll analyze:
   @vscode /explain current file structure
   
2. Based on that analysis:
   @workspace /fix detected issues
   
3. Finally:
   @terminal run tests to verify</code></pre>

          <h4>Pattern 2: Parallel Expertise</h4>
          <pre><code>User: @workspace comprehensive code review

@workspace:
I'll get insights from multiple experts:

Security check:
@workspace check for security vulnerabilities

Performance analysis:
@workspace analyze performance bottlenecks

Style compliance:
@vscode verify coding standards

Test coverage:
@workspace check test coverage</code></pre>

          <h4>Pattern 3: Context Passing</h4>
          <pre><code>User: @workspace create feature with tests

@workspace:
Step 1 - Design:
@workspace design user authentication feature
# Returns: architecture plan

Step 2 - Implementation:
Using the design above:
@workspace implement auth with JWT
# Uses context from step 1

Step 3 - Testing:
@workspace generate tests for the auth implementation
# Uses context from step 2</code></pre>

          <h3>Built-in SubAgents</h3>
          
          <table class="table table-striped">
            <thead>
              <tr>
                <th>Agent</th>
                <th>Specialty</th>
                <th>When to Use as SubAgent</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><code>@workspace</code></td>
                <td>Workspace context & files</td>
                <td>File operations, codebase search, project-wide tasks</td>
              </tr>
              <tr>
                <td><code>@vscode</code></td>
                <td>VS Code features</td>
                <td>Editor operations, settings, UI tasks</td>
              </tr>
              <tr>
                <td><code>@terminal</code></td>
                <td>Terminal commands</td>
                <td>Shell operations, scripts, system commands</td>
              </tr>
              <tr>
                <td><code>@github</code></td>
                <td>GitHub integration</td>
                <td>Repository operations, PR management, issues</td>
              </tr>
            </tbody>
          </table>

          <h3>Custom Agent as SubAgent</h3>
          <pre><code>// Your custom agent can be invoked as a subagent
User: @workflow deploy to production

@workflow:
1. Running pre-deployment checks:
   @quality-checker review codebase
   
2. Building application:
   @build-agent create production build
   
3. Security scan:
   @security-scanner audit for vulnerabilities
   
4. Deploy:
   @deploy-agent push to production
   
5. Verify:
   @monitor-agent check health status</code></pre>

          <h2>Code-Based SubAgents</h2>
          
          <h3>Programmatic SubAgent Invocation</h3>
          <p>Extensions can programmatically invoke other agents using the Copilot API.</p>

          <div class="mermaid">
sequenceDiagram
    participant User
    participant Parent as Parent Agent
    participant API as Copilot API
    participant Sub1 as SubAgent 1
    participant Sub2 as SubAgent 2
    
    User->>Parent: Complex request
    Parent->>Parent: Create plan
    
    Parent->>API: Invoke SubAgent 1
    API->>Sub1: Execute task
    Sub1-->>API: Result 1
    API-->>Parent: Result 1
    
    Parent->>API: Invoke SubAgent 2
    API->>Sub2: Execute task
    Sub2-->>API: Result 2
    API-->>Parent: Result 2
    
    Parent->>Parent: Aggregate results
    Parent-->>User: Unified response
          </div>

          <h3>Implementation Example</h3>
          <pre><code>import * as vscode from 'vscode';

export function activate(context: vscode.ExtensionContext) {
  const agent = vscode.chat.createChatParticipant(
    'orchestrator',
    async (request, context, response, token) => {
      
      // Parent agent receives request
      const userRequest = request.prompt;
      
      // Create execution plan
      const plan = await createPlan(userRequest);
      
      // Execute SubAgents
      const results = [];
      
      for (const task of plan.tasks) {
        const subAgentResult = await executeSubAgent(
          task.agentName,
          task.prompt,
          context,
          token
        );
        results.push(subAgentResult);
      }
      
      // Aggregate and respond
      const finalResponse = aggregateResults(results);
      response.markdown(finalResponse);
    }
  );
}

async function executeSubAgent(
  agentName: string,
  prompt: string,
  context: vscode.ChatContext,
  token: vscode.CancellationToken
) {
  // Invoke another agent programmatically
  const request = {
    prompt: prompt,
    command: undefined,
    references: []
  };
  
  // This is conceptual - actual API may vary
  const subAgent = vscode.chat.getParticipant(agentName);
  const result = await subAgent.invoke(request, context, token);
  
  return result;
}</code></pre>

          <h3>Creating Specialized SubAgents</h3>
          <pre><code>class CodeAnalyzerSubAgent {
  name = 'code-analyzer';
  description = 'Analyzes code quality and complexity';
  
  async execute(context: {
    code: string,
    language: string
  }): Promise<AnalysisResult> {
    const complexity = this.calculateComplexity(context.code);
    const issues = await this.findIssues(context.code);
    const suggestions = this.generateSuggestions(issues);
    
    return {
      complexity,
      issues,
      suggestions,
      score: this.calculateScore(complexity, issues)
    };
  }
}

class TestGeneratorSubAgent {
  name = 'test-generator';
  description = 'Generates unit tests';
  
  async execute(context: {
    code: string,
    framework: string
  }): Promise<TestResult> {
    // Use LLM to generate tests
    const models = await vscode.lm.selectChatModels({ vendor: 'copilot' });
    const model = models[0];
    
    const prompt = `Generate ${context.framework} tests for:\n${context.code}`;
    const messages = [vscode.LanguageModelChatMessage.User(prompt)];
    
    const response = await model.sendRequest(messages, {}, token);
    
    let tests = '';
    for await (const chunk of response.text) {
      tests += chunk;
    }
    
    return {
      tests,
      coverage: this.estimateCoverage(tests),
      testCount: this.countTests(tests)
    };
  }
}</code></pre>

          <h2>SubAgent Orchestration Patterns</h2>
          
          <h3>Sequential Pattern</h3>
          <div class="mermaid">
graph LR
    A[User Request] --> B[SubAgent 1]
    B --> C[SubAgent 2]
    C --> D[SubAgent 3]
    D --> E[Aggregated Result]
    
    style B fill:#10a37f,color:#fff
    style C fill:#10a37f,color:#fff
    style D fill:#10a37f,color:#fff
          </div>
          
          <pre><code>// Each depends on previous result
const analysis = await analyzerSubAgent.execute(code);
const refactored = await refactorerSubAgent.execute(analysis);
const tests = await testerSubAgent.execute(refactored);
const docs = await documenterSubAgent.execute(refactored);</code></pre>

          <h3>Parallel Pattern</h3>
          <div class="mermaid">
graph TB
    A[User Request] --> B[SubAgent 1]
    A --> C[SubAgent 2]
    A --> D[SubAgent 3]
    
    B --> E[Aggregator]
    C --> E
    D --> E
    
    E --> F[Combined Result]
    
    style B fill:#10a37f,color:#fff
    style C fill:#10a37f,color:#fff
    style D fill:#10a37f,color:#fff
          </div>
          
          <pre><code>// Independent SubAgents run simultaneously
const [security, performance, style, tests] = await Promise.all([
  securitySubAgent.execute(code),
  performanceSubAgent.execute(code),
  styleSubAgent.execute(code),
  testSubAgent.execute(code)
]);

const report = combineResults({ security, performance, style, tests });</code></pre>

          <h3>Conditional Pattern</h3>
          <div class="mermaid">
graph TB
    A[User Request] --> B{Analyze}
    B -->|Complex| C[Refactoring SubAgent]
    B -->|Simple| D[Skip]
    
    C --> E{Check Coverage}
    D --> E
    
    E -->|Low| F[Testing SubAgent]
    E -->|High| G[Skip]
    
    F --> H[Final Result]
    G --> H
    
    style C fill:#10a37f,color:#fff
    style F fill:#10a37f,color:#fff
          </div>
          
          <pre><code>const analysis = await analyzerSubAgent.execute(code);

if (analysis.complexity > 0.7) {
  code = await refactorerSubAgent.execute(code);
}

if (analysis.coverage < 0.8) {
  tests = await testerSubAgent.execute(code);
}

if (analysis.securityIssues.length > 0) {
  fixes = await securitySubAgent.execute(code);
}</code></pre>

          <h2>Best Practices</h2>
          
          <h3>‚úÖ Chat-Based SubAgents</h3>
          <ul>
            <li><strong>Be Explicit:</strong> Clearly state which subagent you're invoking and why</li>
            <li><strong>Context Matters:</strong> Provide subagents with relevant context from previous steps</li>
            <li><strong>Verify Results:</strong> Check subagent outputs before proceeding</li>
            <li><strong>Handle Errors:</strong> Have fallback plans if a subagent fails</li>
          </ul>

          <h3>‚úÖ Code-Based SubAgents</h3>
          <ul>
            <li><strong>Single Responsibility:</strong> Each SubAgent has one clear purpose</li>
            <li><strong>Clear Interfaces:</strong> Well-defined inputs and outputs</li>
            <li><strong>Stateless Design:</strong> SubAgents don't maintain state between calls</li>
            <li><strong>Timeout Handling:</strong> Set appropriate timeouts for SubAgent execution</li>
            <li><strong>Error Boundaries:</strong> SubAgents handle their own errors</li>
          </ul>

          <h3>‚ö†Ô∏è Pitfalls to Avoid</h3>
          <ul>
            <li>Too deep nesting (avoid SubAgent ‚Üí SubAgent ‚Üí SubAgent ‚Üí ...)</li>
            <li>Circular dependencies between SubAgents</li>
            <li>Passing excessive context (only send what's needed)</li>
            <li>No error handling or recovery strategy</li>
            <li>Tight coupling between parent and SubAgents</li>
          </ul>

          <h2>Real-World Examples</h2>
          
          <h3>Example 1: Comprehensive Code Review</h3>
          <pre><code>User: @code-reviewer review this pull request

@code-reviewer:
I'll coordinate a thorough review:

1. Security Analysis:
   @security-agent audit for vulnerabilities
   Result: ‚úÖ No critical issues, 2 suggestions

2. Performance Check:
   @performance-agent analyze bottlenecks
   Result: ‚ö†Ô∏è Found 3 optimization opportunities

3. Code Quality:
   @workspace check coding standards
   Result: ‚úÖ Compliant with team standards

4. Test Coverage:
   @workspace calculate test coverage
   Result: ‚ùå Coverage at 65%, below 80% threshold

5. Documentation:
   @workspace verify documentation
   Result: ‚ö†Ô∏è Missing JSDoc for 5 functions

Summary:
- Security: Good
- Performance: Needs optimization
- Quality: Excellent
- Tests: Need more coverage
- Docs: Need updates

Recommendation: Address test coverage before merging.</code></pre>

          <h3>Example 2: Feature Implementation</h3>
          <pre><code>User: @architect build user authentication feature

@architect:
I'll orchestrate the implementation:

Phase 1 - Design:
@architect design JWT-based auth architecture
# Generated: architecture diagram, data models

Phase 2 - Backend:
@backend-dev implement auth endpoints
# Created: /login, /register, /refresh routes

Phase 3 - Security:
@security-agent add rate limiting and validation
# Added: express-rate-limit, input sanitization

Phase 4 - Testing:
@test-gen create integration tests
# Generated: 15 test cases, 92% coverage

Phase 5 - Documentation:
@docs-gen create API documentation
# Created: OpenAPI spec, usage guide

Phase 6 - Deployment:
@devops setup production config
# Added: environment vars, docker config

‚úÖ Feature complete and production-ready!</code></pre>

          <h3>Example 3: Debugging Workflow</h3>
          <pre><code>User: @debug-master fix the login bug

@debug-master:
Starting systematic debugging:

1. Reproduce issue:
   @terminal run test suite
   Result: Login test failing with 500 error

2. Analyze logs:
   @workspace search for error in logs
   Result: Found "JWT signature mismatch"

3. Check code:
   @vscode /explain JWT signing logic
   Result: Using wrong secret in production

4. Identify root cause:
   Environment variable mismatch

5. Propose fix:
   @workspace update env config
   @devops verify production secrets

6. Verify fix:
   @terminal run tests again
   Result: ‚úÖ All tests passing

Bug resolved: JWT secret misconfiguration</code></pre>

          <h2>Monitoring SubAgent Execution</h2>
          
          <h3>Execution Trace</h3>
          <pre><code>SubAgent Execution Log:

[14:23:01] üéØ Parent: Received "create REST API"
[14:23:02] üìã Parent: Created 4-step plan
[14:23:03] ‚îú‚îÄ ü§ñ Delegating to @architect
[14:23:05] ‚îÇ  ‚îî‚îÄ ‚úÖ Architecture designed
[14:23:05] ‚îú‚îÄ ü§ñ Delegating to @backend-dev
[14:23:12] ‚îÇ  ‚îî‚îÄ ‚úÖ Endpoints implemented
[14:23:12] ‚îú‚îÄ ü§ñ Delegating to @test-gen
[14:23:18] ‚îÇ  ‚îî‚îÄ ‚úÖ 23 tests generated
[14:23:18] ‚îî‚îÄ ü§ñ Delegating to @docs-gen
[14:23:22]    ‚îî‚îÄ ‚úÖ Documentation created
[14:23:22] üéâ Parent: All SubAgents complete
[14:23:23] üì§ Parent: Delivering unified result</code></pre>

          <h3>Performance Metrics</h3>
          <table class="table table-striped">
            <thead>
              <tr>
                <th>Metric</th>
                <th>Target</th>
                <th>Monitoring</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>SubAgent Response Time</td>
                <td>&lt; 5s per SubAgent</td>
                <td>Track p95, p99 latency</td>
              </tr>
              <tr>
                <td>Success Rate</td>
                <td>&gt; 95%</td>
                <td>Count failures vs successes</td>
              </tr>
              <tr>
                <td>Context Size</td>
                <td>&lt; 50KB per delegation</td>
                <td>Monitor payload sizes</td>
              </tr>
              <tr>
                <td>Parallel Efficiency</td>
                <td>Linear speedup</td>
                <td>Compare sequential vs parallel</td>
              </tr>
            </tbody>
          </table>

          <h2>Advanced Patterns</h2>
          
          <h3>Dynamic SubAgent Selection</h3>
          <pre><code>async function selectSubAgent(task: Task): Promise<SubAgent> {
  if (task.type === 'security') {
    return securitySubAgent;
  } else if (task.complexity > 0.8) {
    return expertSubAgent;
  } else if (task.language === 'python') {
    return pythonSubAgent;
  } else {
    return generalSubAgent;
  }
}

// Use in orchestration
for (const task of plan.tasks) {
  const subAgent = await selectSubAgent(task);
  await subAgent.execute(task);
}</code></pre>

          <h3>Retry Logic</h3>
          <pre><code>async function executeWithRetry(
  subAgent: SubAgent,
  context: any,
  maxRetries = 3
) {
  for (let i = 0; i < maxRetries; i++) {
    try {
      return await subAgent.execute(context);
    } catch (error) {
      if (i === maxRetries - 1) throw error;
      await sleep(1000 * Math.pow(2, i)); // Exponential backoff
    }
  }
}</code></pre>

          <h3>Circuit Breaker Pattern</h3>
          <pre><code>class SubAgentCircuitBreaker {
  private failures = 0;
  private lastFailure: Date | null = null;
  private state: 'closed' | 'open' | 'half-open' = 'closed';
  
  async execute(subAgent: SubAgent, context: any) {
    if (this.state === 'open') {
      if (Date.now() - this.lastFailure!.getTime() > 60000) {
        this.state = 'half-open';
      } else {
        throw new Error('Circuit breaker open');
      }
    }
    
    try {
      const result = await subAgent.execute(context);
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }
  
  private onSuccess() {
    this.failures = 0;
    this.state = 'closed';
  }
  
  private onFailure() {
    this.failures++;
    this.lastFailure = new Date();
    if (this.failures >= 5) {
      this.state = 'open';
    }
  }
}</code></pre>

          
        </section>
<section id="subagents-vscode" role="article">
        <h1>SubAgents in VS Code</h1>
        <span class="badge">vscode</span>
        <span class="badge">subagents</span>
        <span class="badge">chat</span>
          
          <p>When working on complex tasks, you can delegate subtasks to subagents. A <strong>subagent</strong> is an independent AI agent that performs focused work, such as researching a topic, analyzing code, or reviewing changes, and reports the results back to the main agent. Because each subagent runs in its own context window, it doesn't add noise to your main conversation. VS Code can also run multiple subagents in parallel to speed up multi-part tasks.</p>

          <div class="callout">
            <strong>üí° What Subagents Are (In Plain English)</strong><br />
            A subagent is a dedicated Copilot Chat session that runs in isolation from your main conversation:
            <ul style="margin-bottom: 0; margin-top: 8px;">
              <li>You invoke it with <code>runSubagent</code> inside Copilot Chat</li>
              <li>Copilot spins up a fresh "mini-agent" with its own instructions and tools</li>
              <li>It usually works in a separate Git worktree so your main workspace doesn't get trashed</li>
              <li>When it's done, it hands you back artifacts: diffs, summaries, test results, etc.</li>
            </ul>
          </div>

          <p>For example, the built-in <strong>Plan agent</strong> uses subagents to perform research and analysis before creating an implementation plan. Each subagent works autonomously and returns only its findings. The Plan agent synthesizes these findings into a final plan.</p>

          <p>By default, subagents use the same model and tools as the main chat session but start with a clean context window. Subagents don't inherit the main agent's instructions or conversation history. They receive only the task prompt you provide. By running a custom agent as a subagent, you can apply specialized behavior, tools, and models for specific tasks.</p>

          <h2>How Subagent Execution Works</h2>
          
          <p>The following diagram shows how subagents work. The main agent receives your task, delegates subtasks to one or more subagents that each run in their own context window, and then combines the results.</p>

          <div class="mermaid">
%%{ init: { "theme": "base", "fontFamily": "Segoe UI Semibold", "fontSize": "18px" }}%%
graph TB
    User[User Task] --> MainAgent[Main Agent]
    MainAgent --> Plan[Creates Plan]
    
    Plan --> Sub1[SubAgent 1<br/>Own Context]
    Plan --> Sub2[SubAgent 2<br/>Own Context]
    Plan --> Sub3[SubAgent 3<br/>Own Context]
    
    Sub1 --> Result1[Result Summary]
    Sub2 --> Result2[Result Summary]
    Sub3 --> Result3[Result Summary]
    
    Result1 --> Combine[Main Agent<br/>Combines Results]
    Result2 --> Combine
    Result3 --> Combine
    
    Combine --> Final[Unified Response]
    
    style Sub1 fill:#10a37f,color:#fff
    style Sub2 fill:#10a37f,color:#fff
    style Sub3 fill:#10a37f,color:#fff
    style MainAgent fill:#0066cc,color:#fff
    style Combine fill:#0066cc,color:#fff
          </div>

          <p><strong>Subagents are synchronous</strong>: the main agent waits for subagent results before continuing. This blocking behavior is intentional: subagent findings typically inform the next step of the task. Without the subagent results, the main agent lacks the information it needs to proceed effectively.</p>

          <p>However, VS Code can spawn multiple subagents in parallel. When you request parallel analysis (for example, "analyze security, performance, and accessibility simultaneously"), VS Code runs those subagents concurrently and waits for all results before the main agent continues.</p>

          <div class="callout">
            <strong>üìù Note</strong><br />
            Subagents are different from starting a new agent session. A new session creates an entirely separate conversation with no connection to your current task. Subagents maintain the relationship: they do focused work and report back to the main agent, which stays in control of the overall task.
          </div>

          <h2>What the User Sees</h2>

          <p>When a subagent runs, it appears in the chat as a <strong>collapsible tool call</strong>. By default, the subagent is collapsed and shows:</p>

          <ul>
            <li>The name of the custom agent (if you specify one)</li>
            <li>The currently running tool (for example, "Reading file..." or "Searching codebase...")</li>
          </ul>

          <p>Select the subagent tool call to expand it and view the full details, including all tool calls the subagent made, the prompt passed to the subagent, and the returned result.</p>

          <p>This visibility gives you control over how much detail you see without cluttering your main conversation with intermediate steps.</p>

          <h2>Why Use Subagents?</h2>

          <p>Subagents help you manage complex AI-assisted workflows more effectively:</p>

          <h3>Key Benefits</h3>

          <div class="callout">
            <strong>‚úÖ Keep main agent context focused</strong><br />
            The main agent's context window accumulates information from every prompt and response. By offloading research, analysis, or implementation tasks to subagents, you prevent context bloat and help the main agent stay focused on orchestrating the overall task.
          </div>

          <div class="callout">
            <strong>‚ö° Improve performance with parallel execution</strong><br />
            VS Code can run multiple subagents simultaneously. For example, when implementing a feature, you can research authentication patterns, analyze existing code structure, and review documentation in parallel rather than sequentially.
          </div>

          <div class="callout">
            <strong>üî¨ Isolate experimental or exploratory work</strong><br />
            Subagents are ideal for tasks where you want to explore options without committing to a direction. If a subagent's research leads to a dead end, only the final summary affects your main context - not all the intermediate exploration.
          </div>

          <div class="callout">
            <strong>üéØ Apply specialized behavior for specific tasks</strong><br />
            By combining subagents with custom agents, you can apply specialized tools, instructions, and models for specific subtasks. For example, use a security-focused custom agent to review code for vulnerabilities, while a documentation agent generates user guides.
          </div>

          <div class="callout">
            <strong>üí∞ Reduce token usage and costs</strong><br />
            Because subagents have their own context windows, they don't add their full conversation history to the main agent's context. Only the final result is returned, which can significantly reduce overall token consumption for complex tasks.
          </div>

          <h3>What Subagents Can Actually Do</h3>

          <p>Subagents extend Copilot from "chatty autocomplete" into something closer to a lightweight automation layer:</p>

          <ul>
            <li><strong>Task delegation:</strong> Offload focused work like refactors, test generation, security scans, docs, etc.</li>
            <li><strong>Tool integration:</strong> They can use tools (file search, code edits, terminal commands‚Äîsubject to your approval) to actually change things instead of just talking about it.</li>
            <li><strong>Background-ish work:</strong> They can run longer tasks while you keep using the main chat. You don't have to sit there glued to one thread.</li>
            <li><strong>Context management:</strong> They work in isolated sessions / worktrees, so giant changes don't land in your main working directory until you say so.</li>
            <li><strong>Multi-step orchestration:</strong> "Analyze the code ‚Üí propose changes ‚Üí apply them ‚Üí run tests ‚Üí summarize" can all be part of a single subagent flow.</li>
          </ul>

          <h3>Limitations You Should Know Upfront</h3>

          <p>Subagents are powerful, but not magic:</p>

          <ul>
            <li><strong>No nesting:</strong> A subagent cannot invoke another subagent. No agent pyramids.</li>
            <li><strong>Tools must be enabled:</strong> If the tools icon (hammer/wrench) in Copilot Chat isn't enabled, you're not getting the full experience.</li>
            <li><strong>Prompt quality still matters:</strong> Vague in ‚Üí vague out. You know the drill.</li>
            <li><strong>Still evolving:</strong> Some areas are experimental; org settings and policies can restrict what they can do.</li>
          </ul>

          <h2>Invoking Subagents</h2>

          <h3>Agent-Initiated vs. User-Invoked</h3>

          <p>Subagents are typically <strong>agent-initiated</strong>, not directly invoked by users in chat. To allow the main agent to invoke subagents, make sure the <code>runSubagent</code> tool is enabled.</p>

          <p>The main agent decides when context isolation helps. You don't need to manually type "run a subagent" for every task. The pattern works like this:</p>

          <ol>
            <li>You (or your custom agent's instructions) describe a complex task.</li>
            <li>The main agent recognizes the part of the task that benefits from isolated context.</li>
            <li>The agent starts a subagent, passing only the relevant subtask.</li>
            <li>The subagent works autonomously and returns a summary.</li>
            <li>The main agent incorporates the result and continues.</li>
          </ol>

          <p>You can hint that you want subagent delegation by phrasing your prompt to suggest isolated research or parallel analysis. The main agent will start a subagent, pass the task to it, and receive only the final result.</p>

          <div class="callout">
            <strong>üí° Tip</strong><br />
            For consistent subagent behavior, define when to use subagents in your custom agent's instructions rather than prompting for them manually each time.
          </div>

          <p>To optimize subagent performance, clearly define the task and expected output. This helps the subagent focus on the specific goal without passing unnecessary context back to the main agent.</p>

          <h3>Basic Invocation Examples</h3>
          
          <h4>First, Make Sure Tools Are Enabled</h4>
          <p>Click the hammer/wrench icon in Copilot Chat to enable tools. Without this, you won't get the full subagent experience.</p>

          <h4>Explicit Subagent Call</h4>
          <pre><code># You can call a subagent explicitly using runSubagent:
runSubagent: Analyze the authentication module for security issues

# Sometimes Copilot will suggest using a subagent automatically 
# for more complex tasks - accepting that suggestion gives you 
# the same behavior, just with a friendlier UI.</code></pre>

          <h4>Using @ Mentions</h4>
          <pre><code># User can directly call multiple agents
@workspace analyze authentication.ts

# Then follow up with another agent
@vscode show me the test explorer

# Or chain them in one request
@workspace find login bugs and @terminal run tests</code></pre>

          <h4>Agent-to-Agent Invocation</h4>
          <pre><code># Agent can delegate to another agent in its response
User: @workspace how do I setup this project?

@workspace response:
1. First, let me check the dependencies:
   @workspace /explain package.json
   
2. Now I'll help you install:
   @terminal npm install
   
3. Let's configure your VS Code:
   @vscode recommended extensions for this project</code></pre>

          <h3>Invoke a Subagent in a Prompt File</h3>

          <p>To invoke a subagent inside a prompt file, ensure that the <code>runSubagent</code> or <code>agent</code> tool is included in the <code>tools</code> frontmatter property:</p>

          <pre><code>---
name: document-feature
tools: ['agent', 'read', 'search', 'edit']
---
Run a subagent to research the new feature implementation details 
and return only information relevant for user documentation.
Then update the docs/ folder with the new documentation.</code></pre>

          <p>In the prompt instructions, you can then hint the agent to use subagents by suggesting isolated research or parallel analysis for specific subtasks.</p>

          <h2>Usage Scenarios: Where Subagents Shine</h2>

          <p>Let's talk about situations where this isn't theory‚Äîthis is just smart laziness.</p>

          <h3>Scenario 1: Refactoring Legacy Code Without Losing Your Mind</h3>

          <p><strong>Situation:</strong> You've got a massive <code>legacy.js</code> with mixed concerns, weird patterns, and "do not touch" vibes.</p>

          <h4>Prompt:</h4>
          <pre><code>runSubagent: Analyze legacy.js, identify code smells, 
propose refactors, and apply fixes in an isolated worktree. 
Give me a diff when done.</code></pre>

          <h4>What happens:</h4>
          <ul>
            <li>Subagent analyzes the file in isolation.</li>
            <li>Proposes refactors and applies them outside your main workspace.</li>
            <li>Gives you a diff so you can review like a normal human instead of blindly trusting it.</li>
          </ul>

          <p>You stay in control. It does the grunt work.</p>

          <h3>Scenario 2: Generating and Running Tests (Without Setting Everything Up Manually)</h3>

          <p><strong>Situation:</strong> You've just built a Node.js API. Tests are "on the list" but you don't want to spend your whole afternoon wiring up Jest.</p>

          <h4>Prompt:</h4>
          <pre><code>runSubagent: Generate Jest tests for the auth routes in src/routes/auth.js. 
Set up the test environment if needed. Run tests and report coverage.</code></pre>

          <h4>What happens:</h4>
          <ul>
            <li>Subagent generates test files.</li>
            <li>Runs <code>npm test</code> via tools (with your approval).</li>
            <li>Summarizes what passed, what failed, and where coverage is thin.</li>
          </ul>

          <p>You can then refine specific tests manually, instead of starting from zero.</p>

          <h3>Scenario 3: Security Pass Before a Release</h3>

          <p><strong>Situation:</strong> You're about to cut a release of a Python app and you want a quick security sanity check.</p>

          <h4>Prompt:</h4>
          <pre><code>runSubagent: Scan the workspace for security issues. 
Look for hardcoded secrets, SQL injection risks, and known vulnerabilities. 
Report findings with severity levels.</code></pre>

          <h4>What happens:</h4>
          <ul>
            <li>Subagent sweeps the workspace.</li>
            <li>Runs static analysis tools (e.g., Bandit or similar, depending on what it has access to).</li>
            <li>Reports potential issues + suggested patches in an isolated branch/worktree.</li>
          </ul>

          <p>You get an actionable list instead of vague "maybe this is bad" vibes.</p>

          <h3>Scenario 4: Documentation You've Been Putting Off</h3>

          <p><strong>Situation:</strong> You have a React component library. The code works, but the docs are‚Ä¶ let's call them "aspirational."</p>

          <h4>Prompt:</h4>
          <pre><code>runSubagent: Review all components in src/components/, 
add JSDoc comments where missing, and generate a comprehensive README 
with usage examples.</code></pre>

          <h4>What happens:</h4>
          <ul>
            <li>Subagent goes through the components, adds JSDoc where it makes sense.</li>
            <li>Generates or updates a README.</li>
            <li>Optionally prepares a commit ready for you to review.</li>
          </ul>

          <p>You still own the doc quality‚Äîbut the bulk of the writing and formatting is handled.</p>

          <h3>Scenario 5: Debugging Multi-Service Nightmares</h3>

          <p><strong>Situation:</strong> There's a production issue involving several services, logs are scattered, and nobody wants to spelunk through them.</p>

          <h4>Prompt:</h4>
          <pre><code>runSubagent: Analyze error logs from the last hour across all services. 
Identify the root cause of the 500 errors in the auth service. 
Propose a fix.</code></pre>

          <h4>What happens:</h4>
          <ul>
            <li>Subagent pulls in related logs and code.</li>
            <li>Proposes a hypothesis, tests it where possible, and hands you a concise summary of likely root causes and candidate fixes.</li>
          </ul>

          <p>You're still the one shipping the fix‚Äîbut you're not starting from a blank terminal.</p>

          <h3>Scenario 6: Research Before Implementation</h3>

          <p><strong>Situation:</strong> You need to implement OAuth, but you're not sure which library or pattern fits your stack best.</p>

          <h4>Prompt:</h4>
          <pre><code>runSubagent: Research OAuth 2.0 implementation options for Node.js. 
Compare Passport.js, Auth0, and custom JWT approaches. 
Focus on security, maintainability, and our existing Express stack.</code></pre>

          <h4>What happens:</h4>
          <ul>
            <li>Subagent researches patterns and libraries.</li>
            <li>Returns a concise comparison without cluttering your main chat history.</li>
            <li>You make an informed decision and proceed with implementation.</li>
          </ul>

          <h3>Scenario 7: Parallel Code Analysis</h3>

          <p><strong>Situation:</strong> You're about to merge a PR and want a quick multi-angle review.</p>

          <h4>Prompt:</h4>
          <pre><code>Run parallel subagents to analyze:
1. Security vulnerabilities
2. Performance bottlenecks 
3. Code quality and style
4. Test coverage gaps

Aggregate findings and prioritize by severity.</code></pre>

          <h4>What happens:</h4>
          <ul>
            <li>VS Code runs 4 subagents simultaneously.</li>
            <li>Each analyzes from its specific perspective.</li>
            <li>Main agent combines results into a single actionable report.</li>
          </ul>

          <h3>Scenario 8: Explore Multiple Solutions</h3>

          <p><strong>Situation:</strong> You need to add caching, but you're unsure whether to use Redis, in-memory, or CDN-based caching.</p>

          <h4>Prompt:</h4>
          <pre><code>Use separate subagents to prototype:
1. Redis-based caching implementation
2. In-memory caching with node-cache
3. CDN approach with CloudFront

Compare trade-offs and recommend the best fit for our read-heavy API.</code></pre>

          <h4>What happens:</h4>
          <ul>
            <li>Three subagents explore different approaches in parallel.</li>
            <li>Each builds a proof-of-concept in isolated worktrees.</li>
            <li>Main agent synthesizes findings: performance, complexity, cost, operational overhead.</li>
            <li>You choose the winner based on actual prototypes, not guesswork.</li>
          </ul>

          <h3>Scenario 9: Code Review with Specialized Focus</h3>

          <p><strong>Situation:</strong> You want a thorough review of a critical authentication module before deployment.</p>

          <h4>Prompt:</h4>
          <pre><code>Use specialized subagents to review src/auth/*:
- Security agent: check for auth bypasses, injection risks, session handling
- Performance agent: identify bottlenecks in token validation
- Testing agent: verify test coverage and edge cases
- Documentation agent: ensure all security assumptions are documented</code></pre>

          <h4>What happens:</h4>
          <ul>
            <li>Each subagent brings specialized knowledge and tools.</li>
            <li>Security subagent might use security-focused MCP servers.</li>
            <li>Performance subagent analyzes algorithmic complexity.</li>
            <li>Combined report gives you multi-dimensional confidence before deploy.</li>
          </ul>

          <h2>Run a Custom Agent as a Subagent</h2>

          <p>By default, a subagent inherits the agent from the main chat session and uses the same model and tools. To define specific behavior for a subagent, use a custom agent. Custom agents can specify their own model, tools, and instructions. When used as a subagent, these settings override the defaults inherited from the main session.</p>

          <h3>Control Subagent Invocation</h3>

          <p>You can control how a custom agent can be invoked by using two frontmatter properties:</p>

          <ul>
            <li><strong>user-invokable:</strong> controls whether the agent appears in the agents dropdown in chat (default is <code>true</code>). Set to <code>false</code> to create agents that are only accessible as subagents.</li>
            <li><strong>disable-model-invocation:</strong> prevents the agent from being invoked as a subagent by other agents (default is <code>false</code>). Set to <code>true</code> when agents should only be triggered explicitly by users.</li>
          </ul>

          <h4>Example: Agent Only Usable as Subagent</h4>
          <pre><code>---
name: internal-helper
user-invokable: false
---
This agent can only be invoked as a subagent.</code></pre>

          <div class="callout">
            <strong>üìù Note</strong><br />
            The <code>infer</code> property is deprecated. Use <code>user-invokable</code> and <code>disable-model-invocation</code> instead for more granular control.
          </div>

          <h4>Example: Running Custom Agents as Subagents</h4>
          <pre><code># Run the Research agent as a subagent to research auth methods
Run the Research agent as a subagent to research the best 
auth methods for this project.

# Use the Plan agent in a subagent to create implementation plan
Use the Plan agent in a subagent to create an implementation 
plan for myfeature. Then save the plan in plans/myfeature.plan.md</code></pre>

          <h3>Restrict Which Subagents Can Be Used</h3>

          <p>By default, all custom agents that don't have <code>disable-model-invocation: true</code> are available to be used as subagents. If two or more agents have similar names or descriptions, the AI might select an unintended agent.</p>

          <p>You can restrict which custom agents can be used as subagents by specifying the <code>agents</code> property in the main agent's frontmatter, and providing a list of allowed custom agents.</p>

          <p>The <code>agents</code> property accepts:</p>

          <ul>
            <li>A list of agent names (for example, <code>['Edit', 'Search']</code>) to allow only specific agents</li>
            <li><code>*</code> to allow all available agents (default behavior)</li>
            <li>An empty array <code>[]</code> to prevent any subagent use</li>
          </ul>

          <div class="callout">
            <strong>üìù Note</strong><br />
            Explicitly listing an agent in the <code>agents</code> array overrides <code>disable-model-invocation: true</code>. This means you can create agents that are protected from general subagent use but still accessible to specific coordinator agents that explicitly allow them.
          </div>

          <h4>Example: TDD Agent with Restricted Subagents</h4>

          <p>A test-driven development (TDD) agent should only use the Red, Green, and Refactor agents as subagents. If not restricted, the TDD agent might select a more generic coding agent for implementing the tests instead of the specialized TDD agents.</p>

          <pre><code>---
name: TDD
tools: ['agent']
agents: ['Red', 'Green', 'Refactor']
---
Implement the following feature using test-driven development. 
Use subagents to guide the following steps:

1. Use the Red agent to write failing tests
2. Use the Green agent to implement code to pass the tests
3. Use the Refactor agent to improve the code quality</code></pre>
          
          <h2>Orchestration Patterns</h2>

          <p>Subagents enable orchestration patterns where a coordinator agent delegates work to specialized worker agents. This approach helps you build sophisticated workflows while keeping each agent focused on what it does best.</p>

          <h3>Coordinator and Worker Pattern</h3>

          <p>A coordinator agent manages the overall task and delegates subtasks to specialized subagents. Each worker agent can have a tailored set of tools. For example, planning and review agents need only read-only access, while the implementer needs edit capabilities.</p>

          <h4>Example: Feature Builder Coordinator</h4>

          <pre><code>---
name: Feature Builder
tools: ['agent', 'edit', 'search', 'read']
agents: ['Planner', 'Plan Architect', 'Implementer', 'Reviewer']
---
You are a feature development coordinator. For each feature request:

1. Use the Planner agent to break down the feature into tasks.
2. Use the Plan Architect agent to validate the plan against codebase patterns.
3. If the architect identifies reusable patterns or libraries, 
   send feedback to the Planner to update the plan.
4. Use the Implementer agent to write the code for each task.
5. Use the Reviewer agent to check the implementation.
6. If the reviewer identifies issues, use the Implementer agent 
   again to apply fixes.

Iterate between planning and architecture, and between review 
and implementation, until each phase converges.</code></pre>

          <p>The worker agents each define their own tool access and can pick a faster or more cost-effective model since they have a narrower focus:</p>

          <h4>Planner Agent (Worker)</h4>
          <pre><code>---
name: Planner
user-invokable: false
tools: ['read', 'search']
---
Break down feature requests into implementation tasks. 
Incorporate feedback from the Plan Architect.</code></pre>

          <h4>Plan Architect Agent (Worker)</h4>
          <pre><code>---
name: Plan Architect
user-invokable: false
tools: ['read', 'search']
---
Validate plans against the codebase. Identify existing patterns, 
utilities, and libraries that should be reused. Flag any plan steps 
that duplicate existing functionality.</code></pre>

          <h4>Implementer Agent (Worker)</h4>
          <pre><code>---
name: Implementer
user-invokable: false
model: ['Claude Haiku 4.5 (copilot)', 'Gemini 3 Flash (Preview) (copilot)']
---
Write code to complete assigned tasks.</code></pre>

          <p>This pattern keeps the coordinator's context focused on the high-level workflow while each worker agent has a clean context and appropriate permissions for its specific job.</p>

          <h3>Multi-Perspective Code Review Pattern</h3>

          <p>Code review benefits from multiple perspectives. A single pass often misses problems that become obvious when you look through a different lens. Use subagents to run each review perspective in parallel, then synthesize the findings.</p>

          <pre><code>---
name: Thorough Reviewer
tools: ['agent', 'read', 'search']
---
You review code through multiple perspectives simultaneously. 
Run each perspective as a parallel subagent so findings are 
independent and unbiased.

When asked to review code, run these subagents in parallel:

- Correctness reviewer: logic errors, edge cases, type issues.
- Code quality reviewer: readability, naming, duplication.
- Security reviewer: input validation, injection risks, data exposure.
- Architecture reviewer: codebase patterns, design consistency, 
  structural alignment.

After all subagents complete, synthesize findings into a prioritized 
summary. Note which issues are critical versus nice-to-have. 
Acknowledge what the code does well.</code></pre>

          <p>This pattern works because each subagent approaches the code fresh, without being anchored by what other perspectives found. In this example, the orchestrator shapes each subagent's focus area through its prompt. This is a lightweight approach that requires no additional agent files.</p>

          <div class="callout">
            <strong>üí° Tip</strong><br />
            For more control, each review perspective can be its own custom agent with specialized tool access. For example, a security reviewer might use a security-focused MCP server, while a code-quality reviewer might have access to linting CLI tools. This approach lets each perspective use the best tools for its specific focus.
          </div>

          <h3>Multi-Step Orchestration Patterns</h3>

          <p>Subagents really start paying off when you think in multi-step flows instead of one-off prompts.</p>

          <h4>Pattern 1: Multi-Step Refactor</h4>
          <pre><code>runSubagent: 
1. Analyze src/legacy.js for code smells
2. Propose refactoring strategies  
3. Apply cleanest approach in a new branch
4. Run tests to verify nothing broke
5. Generate a summary of changes</code></pre>

          <p>You've basically handed it a small plan. It executes, and you just review.</p>

          <h4>Pattern 2: Code Generation + Validation</h4>
          <pre><code>runSubagent: Generate a new Express middleware for rate limiting.
Check for conflicts with existing middleware. Report any issues.</code></pre>

          <p>The key here is that the subagent doesn't just generate code; it also checks for conflicts and reports back.</p>

          <h4>Pattern 3: Background Maintenance Task</h4>
          <pre><code>runSubagent: Update all dependencies to latest compatible versions. 
Run test suite after each major update. Roll back if tests fail.</code></pre>

          <p>You can keep working in your main chat while this grindy task runs elsewhere.</p>

          <h4>Pattern 4: Pairing with Plan Mode</h4>

          <p>Plan Mode is great at outlining big changes. Subagents are great at executing pieces of that plan.</p>

          <pre><code>@workspace /plan: Add comprehensive logging to the application

# Then after reviewing the plan:
Use separate subagents to implement each phase of the plan:
- Phase 1 subagent: Set up logging infrastructure
- Phase 2 subagent: Add request/response logging
- Phase 3 subagent: Add error logging
- Phase 4 subagent: Add performance metrics</code></pre>

          <p>You get structure and execution, without losing track of what's happening.</p>

          <h2>Built-in VS Code Agents as Subagents</h2>

          <p>VS Code provides several built-in agents that can be used as subagents via @ mentions:</p>

          <h3>@workspace Agent</h3>
          <pre><code># File operations
@workspace find all TypeScript files with TODOs

# Code search
@workspace show me authentication logic

# Project analysis
@workspace explain the architecture

# Code generation
@workspace create a new React component</code></pre>

          <h3>@vscode Agent</h3>
          <pre><code># Editor operations
@vscode open the settings

# UI customization
@vscode change theme to dark

# Extension management
@vscode recommended extensions for Python

# Workspace configuration
@vscode setup debugging for this project</code></pre>

          <h3>@terminal Agent</h3>
          <pre><code># Command execution
@terminal list running processes

# Package management
@terminal install dependencies

# Script execution
@terminal run build script

# System operations
@terminal check git status</code></pre>

          <h3>@github Agent</h3>
          <pre><code># Repository operations
@github list open pull requests

# Issue management
@github create issue for bug

# Code review
@github review latest changes

# Collaboration
@github who worked on this file?</code></pre>

          <h2>Creating Custom Agents for SubAgent Use</h2>
          
          <h4>Registering a Chat Participant</h4>
          <pre><code>import * as vscode from 'vscode';

export function activate(context: vscode.ExtensionContext) {
  // Register a custom agent that can be used as a subagent
  const myAgent = vscode.chat.createChatParticipant(
    'mycompany.code-reviewer', 
    async (request, context, response, token) => {
      // This agent can be invoked as @code-reviewer
      
      if (request.command === 'security') {
        response.markdown('## Security Analysis\n');
        // Perform security review
        const issues = await analyzeSecurityIssues(request);
        response.markdown(formatSecurityReport(issues));
        
      } else {
        // General code review
        response.markdown('## Code Review\n');
        const review = await performCodeReview(request);
        response.markdown(review);
      }
      
      return {};
    }
  );
  
  myAgent.iconPath = vscode.Uri.joinPath(
    context.extensionUri, 
    'icon.png'
  );
  
  context.subscriptions.push(myAgent);
}</code></pre>

          <h4>Making Your Agent SubAgent-Friendly</h4>
          <pre><code>// Design agents to accept context from parent agents
vscode.chat.createChatParticipant('mycompany.tester', 
  async (request, context, response, token) => {
    
    // Check if invoked by another agent
    const parentAgent = context.history.find(
      msg => msg.participant?.includes('workspace')
    );
    
    if (parentAgent) {
      // Context from parent agent
      response.markdown('Received context from parent agent:\n');
      response.markdown(`- Files: ${request.references.length}\n`);
    }
    
    // Generate tests based on context
    const tests = await generateTests({
      code: request.prompt,
      references: request.references,
      parentContext: parentAgent
    });
    
    response.markdown('## Generated Tests\n');
    response.markdown(tests);
    
    return {};
  }
);</code></pre>

          <h3>Advanced SubAgent Patterns in VS Code</h3>
          
          <h4>Conditional SubAgent Chains</h4>
          <pre><code>User: @workspace comprehensive security audit

@workspace:
Step 1: Scanning codebase...
@workspace /explain security configuration
Result: Found authentication module

Step 2: Checking dependencies...
@terminal npm audit
Result: 3 vulnerabilities found

Step 3: Analyzing vulnerable packages...
@workspace show usage of vulnerable packages
Result: Used in authentication.ts

Step 4: Checking for secrets...
@workspace search for API keys or passwords
Result: No hardcoded secrets found

Step 5: Generating report...
Summary:
‚úÖ No hardcoded credentials
‚ö†Ô∏è 3 dependency vulnerabilities 
üìã Recommendation: Update packages in package.json</code></pre>

          <h4>Parallel SubAgent Execution</h4>
          <pre><code>User: @workspace prepare for code review

@workspace:
Running multiple checks in parallel:

1. Code Quality:
   @workspace /explain complexity metrics
   
2. Test Coverage:
   @terminal npm run test:coverage
   
3. Linting:
   @terminal npm run lint
   
4. Type Checking:
   @terminal npm run type-check

I'll aggregate results when all complete...</code></pre>

          <h2>Safety, Governance, and "Don't Shoot Yourself in the Foot"</h2>

          <p>Subagents are powerful because they can:</p>

          <ul>
            <li>Run terminal commands</li>
            <li>Modify files</li>
            <li>Commit changes</li>
          </ul>

          <p>That's exactly why you don't just blindly approve everything.</p>

          <h3>Practical Safety Habits</h3>

          <div class="callout">
            <strong>üìñ Read prompts before approving tools</strong><br />
            If Copilot wants to run a command, make sure it's something you'd actually type yourself.
          </div>

          <div class="callout">
            <strong>üåø Prefer isolated worktrees/branches</strong><br />
            Let subagents experiment away from your main development branch.
          </div>

          <div class="callout">
            <strong>üëÄ Review diffs like normal PRs</strong><br />
            Subagent output is not exempt from review just because AI wrote it.
          </div>

          <div class="callout">
            <strong>üîí Be careful with sensitive data</strong><br />
            Don't paste secrets, internal tokens, or anything compliance would yell at you about.
          </div>

          <div class="callout">
            <strong>üè¢ Respect company policies</strong><br />
            If you're in a company environment, admins may have policies that restrict tools and subagent behavior. Respect that‚Äîthose policies exist for a reason.
          </div>

          <h3>Getting Your Team Comfortable with Subagents</h3>

          <p>If you're introducing this to a team, don't pitch it as "AI will write all our code." Instead:</p>

          <ul>
            <li><strong>Start with non-critical tasks</strong> (docs, small refactors, test scaffolding).</li>
            <li><strong>Agree on a review standard:</strong> everything generated by an agent is treated like code from a junior dev‚Äîreviewed carefully, but not dismissed.</li>
            <li><strong>Encourage people to share prompt patterns</strong> that worked well (and those that failed).</li>
            <li><strong>Use CI as the final gate:</strong> tests, linters, and checks don't care whether a human or subagent wrote the change.</li>
          </ul>

          <h3>When You Should NOT Use a Subagent</h3>

          <p>Just because you can doesn't mean you should.</p>

          <p><strong>Skip subagents for:</strong></p>

          <ul>
            <li>Tiny changes you can type faster than you can describe.</li>
            <li>One-liners or trivial fixes.</li>
            <li>Anything that requires deep product judgment rather than mechanical work.</li>
          </ul>

          <p><strong>Save them for:</strong></p>

          <ul>
            <li>Tasks that would take you 30+ minutes.</li>
            <li>Multi-file or multi-step changes.</li>
            <li>Work that's boring but important: cleanup, tests, audits, updates, etc.</li>
          </ul>

          <h2>Best Practices Cheat Sheet</h2>

          <h3>‚úÖ Do These Things</h3>

          <table class="table table-striped">
            <thead>
              <tr>
                <th>Best Practice</th>
                <th>Why It Matters</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Be specific in your prompts</strong></td>
                <td>File paths, expected outputs, and constraints help subagents focus on the right goal</td>
              </tr>
              <tr>
                <td><strong>Use them for complexity, not laziness</strong></td>
                <td>Subagents shine when the task is structured but heavy</td>
              </tr>
              <tr>
                <td><strong>Combine Plan Mode + subagents</strong></td>
                <td>Plan big, execute small‚Äîget structure and autonomy</td>
              </tr>
              <tr>
                <td><strong>Review everything</strong></td>
                <td>Treat subagent output like any other code contribution</td>
              </tr>
              <tr>
                <td><strong>Iterate</strong></td>
                <td>After each run, ask: "What could I have told the subagent to make this result better?" Then bake that into the next prompt</td>
              </tr>
              <tr>
                <td><strong>Clearly state which subagent you're delegating to</strong></td>
                <td>Makes workflows explicit and traceable</td>
              </tr>
              <tr>
                <td><strong>Provide context from previous steps</strong></td>
                <td>Helps subagents make informed decisions</td>
              </tr>
              <tr>
                <td><strong>Use the most appropriate agent for each task</strong></td>
                <td>Specialized agents produce better results</td>
              </tr>
              <tr>
                <td><strong>Chain agents logically (analyze ‚Üí fix ‚Üí test)</strong></td>
                <td>Creates natural, verifiable workflows</td>
              </tr>
              <tr>
                <td><strong>Handle failures gracefully with fallbacks</strong></td>
                <td>Makes workflows resilient to errors</td>
              </tr>
            </tbody>
          </table>

          <h3>‚ö†Ô∏è Pitfalls to Avoid</h3>

          <table class="table table-striped">
            <thead>
              <tr>
                <th>Anti-Pattern</th>
                <th>Why It's Problematic</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Create circular dependencies (@a calls @b calls @a)</strong></td>
                <td>Creates infinite loops and wasted tokens</td>
              </tr>
              <tr>
                <td><strong>Nest too deeply (limit to 2-3 levels)</strong></td>
                <td>Context gets lost, debugging becomes impossible</td>
              </tr>
              <tr>
                <td><strong>Pass excessive context between agents</strong></td>
                <td>Wastes tokens, slows performance, dilutes focus</td>
              </tr>
              <tr>
                <td><strong>Use agents for tasks they're not designed for</strong></td>
                <td>Produces poor results and wastes time</td>
              </tr>
              <tr>
                <td><strong>Forget to verify subagent outputs before proceeding</strong></td>
                <td>Propagates errors through the entire workflow</td>
              </tr>
              <tr>
                <td><strong>Too deep nesting (SubAgent ‚Üí SubAgent ‚Üí SubAgent ‚Üí ...)</strong></td>
                <td>Not currently supported; will fail</td>
              </tr>
              <tr>
                <td><strong>Tight coupling between parent and SubAgents</strong></td>
                <td>Makes agents brittle and hard to maintain</td>
              </tr>
            </tbody>
          </table>

          <h3>Code-Based SubAgents Best Practices</h3>

          <div class="callout">
            <strong>‚úÖ For Extension Developers</strong>
            <ul style="margin-bottom: 0; margin-top: 8px;">
              <li><strong>Single Responsibility:</strong> Each SubAgent has one clear purpose</li>
              <li><strong>Clear Interfaces:</strong> Well-defined inputs and outputs</li>
              <li><strong>Stateless Design:</strong> SubAgents don't maintain state between calls</li>
              <li><strong>Timeout Handling:</strong> Set appropriate timeouts for SubAgent execution</li>
              <li><strong>Error Boundaries:</strong> SubAgents handle their own errors</li>
            </ul>
          </div>

          <h3>Debugging SubAgent Interactions</h3>
          
          <h4>VS Code Chat History</h4>
          <pre><code>// Access conversation history to see subagent interactions
const history = context.history;

history.forEach(message => {
  console.log(`Participant: ${message.participant}`);
  console.log(`Content: ${message.content}`);
  console.log(`References: ${message.references?.length || 0}`);
});</code></pre>

          <h4>Logging SubAgent Calls</h4>
          <pre><code>// In your agent implementation
async function delegateToSubAgent(
  agentName: string, 
  prompt: string
) {
  console.log(`[${Date.now()}] Delegating to ${agentName}`);
  console.log(`Prompt: ${prompt}`);
  
  const startTime = Date.now();
  const result = await invokeAgent(agentName, prompt);
  const duration = Date.now() - startTime;
  
  console.log(`[${Date.now()}] ${agentName} completed in ${duration}ms`);
  console.log(`Result length: ${result.length} chars`);
  
  return result;
}</code></pre>

          <h3>Testing SubAgent Workflows</h3>
          
          <pre><code>import { expect } from 'chai';

describe('SubAgent Workflow Tests', () => {
  
  it('should delegate to @workspace for file search', async () => {
    const response = await invokeAgent('my-orchestrator', {
      prompt: 'find authentication files',
      history: []
    });
    
    // Verify delegation occurred
    expect(response).to.include('@workspace');
    expect(response).to.include('authentication');
  });
  
  it('should chain @workspace and @terminal', async () => {
    const response = await invokeAgent('my-orchestrator', {
      prompt: 'run tests for auth module',
      history: []
    });
    
    // Should search files first
    expect(response).to.match(/@workspace.*authentication/);
    // Then run tests
    expect(response).to.match(/@terminal.*npm.*test/);
  });
  
  it('should handle subagent failures', async () => {
    // Simulate @terminal unavailable
    const response = await invokeAgent('my-orchestrator', {
      prompt: 'deploy application',
      history: [],
      simulateFailure: '@terminal'
    });
    
    // Should have fallback behavior
    expect(response).to.include('unable to execute terminal command');
    expect(response).to.include('manual deployment steps');
  });
});</code></pre>

          <h3>Real-World Example: Feature Implementation</h3>
          
          <pre><code>User: @workspace implement user registration feature

@workspace: I'll coordinate the implementation:

üìã Step 1: Architecture Design
@workspace analyze existing user management code
Result: Found user.service.ts, auth.controller.ts

üìù Step 2: Create Data Model
Creating user registration model...
‚úÖ Created: models/registration.model.ts

üîß Step 3: Implement Backend
@workspace create registration endpoint in auth.controller.ts
‚úÖ Added: POST /api/auth/register

üîê Step 4: Add Validation
@workspace add input validation for registration
‚úÖ Added: email, password strength validation

üß™ Step 5: Generate Tests
@workspace create tests for registration endpoint
‚úÖ Created: auth.controller.spec.ts with 8 test cases

üì± Step 6: Create Frontend Form
@workspace create registration form component
‚úÖ Created: components/RegistrationForm.tsx

‚úÖ Step 7: Run Tests
@terminal npm test auth.controller
Result: All 8 tests passing ‚úì

üìö Step 8: Documentation
@workspace add API documentation for registration
‚úÖ Updated: api-docs.md

üéâ Implementation Complete!
Files Created: 3
Files Modified: 2
Tests: 8 passing
Next Steps: Review and deploy</code></pre>

          <h3>Resources</h3>
          
          <ul>
            <li>üìñ <a href="https://code.visualstudio.com/docs/copilot/agents/subagents" target="_blank" rel="noopener">Official VS Code SubAgents Documentation</a></li>
            <li>üìù <a href="https://imaginet.com/2025/mastering-subagents-in-vs-code-copilot-how-to-actually-use-them/" target="_blank" rel="noopener">Mastering SubAgents in VS Code Copilot</a></li>
            <li>üéì <a href="https://code.visualstudio.com/api/extension-guides/chat" target="_blank" rel="noopener">Chat Extension Guide</a></li>
            <li>üîß <a href="https://github.com/microsoft/vscode-extension-samples" target="_blank" rel="noopener">VS Code Extension Samples</a></li>
          </ul>
        </section>

        <!-- Agent Customization Section -->
        <section id="agent-customization" role="article">
          <h1>‚öôÔ∏è Agent Customization</h1>
          <span class="badge">customization</span>
          <span class="badge">configuration</span>
          
          <p>Agent customization allows you to tailor AI assistants to your specific needs, workflows, and domain knowledge. Customize behavior through prompt files, instructions, skills, capabilities, language models, MCP servers, and hooks.</p>

          <div class="callout">
            <strong>üéØ Make It Yours</strong><br />
            Customization transforms generic AI into a specialized expert that understands your codebase, follows your standards, and speaks your team's language.
          </div>

          <h2>Customization Layers</h2>
          
          <table class="table table-striped">
            <thead>
              <tr>
                <th>Layer</th>
                <th>Purpose</th>
                <th>Scope</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Prompt Files</strong></td>
                <td>Reusable prompts and templates</td>
                <td>Project/Team</td>
              </tr>
              <tr>
                <td><strong>Instructions</strong></td>
                <td>Global rules and constraints</td>
                <td>User/Organization</td>
              </tr>
              <tr>
                <td><strong>Skills</strong></td>
                <td>Domain-specific knowledge</td>
                <td>Team/Organization</td>
              </tr>
              <tr>
                <td><strong>Capabilities</strong></td>
                <td>Permission and feature flags</td>
                <td>Agent</td>
              </tr>
              <tr>
                <td><strong>Language Models</strong></td>
                <td>Choose AI model for tasks</td>
                <td>User/Agent</td>
              </tr>
              <tr>
                <td><strong>MCP Servers</strong></td>
                <td>Connect external context</td>
                <td>Project/Organization</td>
              </tr>
              <tr>
                <td><strong>Hooks</strong></td>
                <td>Custom event handlers</td>
                <td>Workspace/Extension</td>
              </tr>
            </tbody>
          </table>

          <h2>Customization Architecture</h2>
          
          <pre><code>User Request
      ‚îÇ
      ‚Üì
[üìù Instructions] Apply global rules
      ‚îÇ
      ‚Üì
[üìö Skills] Add domain knowledge
      ‚îÇ
      ‚Üì
[üìù Prompt Files] Use templates
      ‚îÇ
      ‚Üì
[üéØ Capabilities] Check permissions
      ‚îÇ
      ‚Üì
[üß† Language Model] Process with chosen LLM
      ‚îÇ
      ‚Üì
[üîó MCP Servers] Fetch external context
      ‚îÇ
      ‚Üì
[ü™£ Hooks] Trigger custom logic
      ‚îÇ
      ‚Üì
  Agent Response</code></pre>

          <h2>Configuration Hierarchy</h2>
          
          <h3>Priority Order (highest to lowest)</h3>
          <ol>
            <li><strong>User-level settings:</strong> <code>~/.config/Code/User/settings.json</code></li>
            <li><strong>Workspace settings:</strong> <code>.vscode/settings.json</code></li>
            <li><strong>Project config:</strong> <code>.copilot/config.json</code></li>
            <li><strong>Extension defaults:</strong> Built-in configuration</li>
          </ol>

          <h3>Configuration Example</h3>
          <pre><code>// .vscode/settings.json
{
  "github.copilot.customization": {
    "instructions": ".copilot/instructions.md",
    "skills": [".copilot/skills/**/*.md"],
    "promptFiles": ".copilot/prompts/**/*.md",
    "mcp": {
      "servers": [
        "company-knowledge",
        "jira-integration"
      ]
    },
    "hooks": {
      "beforeRequest": "./hooks/validate.js",
      "afterResponse": "./hooks/log.js"
    },
    "modelPreferences": {
      "chat": "gpt-4o",
      "completion": "gpt-4o-mini",
      "planning": "claude-sonnet-4"
    }
  }
}</code></pre>

          <h2>Customization Workflow</h2>
          
          <h3>Step 1: Define Requirements</h3>
          <ul>
            <li>What domain knowledge does the agent need?</li>
            <li>What standards should it enforce?</li>
            <li>What tools/services should it integrate with?</li>
            <li>What workflows are most common?</li>
          </ul>

          <h3>Step 2: Choose Customization Methods</h3>
          <ul>
            <li><strong>Instructions:</strong> For universal rules ("Always use TypeScript strict mode")</li>
            <li><strong>Skills:</strong> For domain expertise ("React best practices")</li>
            <li><strong>Prompt Files:</strong> For reusable templates ("API endpoint template")</li>
            <li><strong>MCP:</strong> For external data ("Company docs", "Jira")</li>
            <li><strong>Hooks:</strong> For custom behavior ("Log all requests")</li>
          </ul>

          <h3>Step 3: Implement</h3>
          <p>Create configuration files in <code>.copilot/</code> directory</p>

          <h3>Step 4: Test & Iterate</h3>
          <ul>
            <li>Test with real scenarios</li>
            <li>Gather team feedback</li>
            <li>Refine and improve</li>
          </ul>

          <h2>Integration Example</h2>
          
          <h3>Complete Setup for React Team</h3>
          <pre><code>.copilot/
  ‚îú‚îÄ instructions.md         # Global rules
  ‚îú‚îÄ skills/
  ‚îÇ   ‚îú‚îÄ react.md           # React expertise
  ‚îÇ   ‚îú‚îÄ typescript.md      # TypeScript patterns  
  ‚îÇ   ‚îî‚îÄ testing.md         # Testing standards
  ‚îú‚îÄ prompts/
  ‚îÇ   ‚îú‚îÄ component.md      # Component template
  ‚îÇ   ‚îú‚îÄ test.md           # Test template
  ‚îÇ   ‚îî‚îÄ api.md            # API template
  ‚îú‚îÄ mcp.json              # MCP server config
  ‚îî‚îÄ hooks/
      ‚îú‚îÄ validate.js      # Pre-request validation
      ‚îî‚îÄ log.js           # Response logging</code></pre>

          <h2>Best Practices</h2>
          
          <h3>‚úÖ Effective Customization</h3>
          <ul>
            <li>Start simple, add complexity as needed</li>
            <li>Version control customization files</li>
            <li>Document why each customization exists</li>
            <li>Share customizations across team</li>
            <li>Regular review and updates</li>
            <li>Test customizations thoroughly</li>
          </ul>

          <h3>‚ö†Ô∏è Common Mistakes</h3>
          <ul>
            <li>Over-constraining (too many rules)</li>
            <li>Conflicting instructions</li>
            <li>Hardcoded values (use variables)</li>
            <li>Not testing edge cases</li>
            <li>Ignoring performance impact</li>
          </ul>

          <h2>Customization Patterns</h2>
          
          <h3>Pattern 1: Layered Configuration</h3>
          <pre><code>// Base instructions (global)
Always use TypeScript strict mode
Follow functional programming principles

// Project-specific (workspace)
Use React 18+ features
Prefer hooks over class components

// Context-specific (prompt)
Generate a form component with validation</code></pre>

          <h3>Pattern 2: Conditional Behavior</h3>
          <pre><code>// In instructions.md
IF file.extension === '.test.ts'
  Use Jest and React Testing Library
  Focus on user behavior, not implementation
  Aim for >80% coverage
ELSE IF file.extension === '.tsx'
  Use functional components
  Include TypeScript interfaces
  Add JSDoc comments
END IF</code></pre>

          <h3>Pattern 3: Template Inheritance</h3>
          <pre><code>// Base template: prompts/base-component.md
Create a TypeScript React component with:
- Props interface
- JSDoc documentation
- Proper exports

// Specialized template: prompts/form-component.md
@extends base-component.md
Additional requirements:
- React Hook Form integration
- Zod validation schema
- Error handling</code></pre>

          <h2>Monitoring Customization Impact</h2>
          
          <h3>Effectiveness Metrics</h3>
          <ul>
            <li>Acceptance rate of suggestions</li>
            <li>Time saved per task</li>
            <li>Code quality improvements</li>
            <li>Team satisfaction scores</li>
          </ul>

          <h3>Usage Analytics</h3>
          <pre><code>// Track which customizations are used most
{
  "customizations": {
    "react-component-prompt": { "uses": 145, "acceptance": 0.89 },
    "api-template": { "uses": 83, "acceptance": 0.92 },
    "test-generation": { "uses": 201, "acceptance": 0.76 }
  }
}</code></pre>
        </section>

        <!-- Prompt Files Section -->
        <section id="prompt-files" role="article">
          <h1>üìÑ Prompt Files</h1>
          <span class="badge">prompts</span>
          <span class="badge">files</span>
          
          <p>Prompt files are reusable templates that help you create consistent, high-quality AI interactions. They allow you to save and share effective prompts across your team.</p>

          <div class="callout">
            <strong>üìã Templates for Success</strong><br />
            Prompt files turn your best prompts into reusable assets, ensuring consistency and quality across your team while saving time.
          </div>

          <h2>What are Prompt Files?</h2>
          <ul>
            <li><strong>Markdown templates</strong> stored in your workspace</li>
            <li><strong>Reusable prompts</strong> for common tasks</li>
            <li><strong>Parameterized</strong> to support different inputs</li>
            <li><strong>Version controlled</strong> alongside your code</li>
            <li><strong>Shareable</strong> across teams and projects</li>
          </ul>

          <h2>File Structure</h2>
          
          <h3>Basic Prompt File</h3>
          <pre><code>---
title: React Component Generator
description: Generate a TypeScript React functional component
author: team@company.com
tags: [react, typescript, component]
---

# Component Generator

Create a React functional component in TypeScript with the following specifications:

## Component Name
{{componentName}}

## Props
{{props}}

## Requirements
- Use functional component with hooks
- Include TypeScript interfaces for props
- Add JSDoc documentation
- Include proper exports
- Follow our style guide

## Example Usage
Provide an example of how to use this component.</code></pre>

          <h2>Location & Organization</h2>
          
          <h3>Directory Structure</h3>
          <pre><code>.copilot/
  prompts/
    ‚îú‚îÄ react/
    ‚îÇ   ‚îú‚îÄ component.md
    ‚îÇ   ‚îú‚îÄ hook.md
    ‚îÇ   ‚îî‚îÄ test.md
    ‚îú‚îÄ api/
    ‚îÇ   ‚îú‚îÄ endpoint.md
    ‚îÇ   ‚îî‚îÄ dto.md
    ‚îú‚îÄ database/
    ‚îÇ   ‚îú‚îÄ migration.md
    ‚îÇ   ‚îî‚îÄ model.md
    ‚îî‚îÄ documentation/
        ‚îú‚îÄ readme.md
        ‚îî‚îÄ api-docs.md</code></pre>

          <h2>Using Prompt Files</h2>
          
          <h3>Via Command Palette</h3>
          <pre><code>1. Cmd/Ctrl + Shift + P
2. "Copilot: Use Prompt File"
3. Select prompt from list
4. Fill in parameters
5. Execute</code></pre>

          <h3>Via Chat</h3>
          <pre><code>@workspace /prompt react/component
componentName: UserProfile
props: userId, onUpdate</code></pre>

          <h3>Programmatically</h3>
          <pre><code>const promptFile = await copilot.prompts.load('react/component');
const result = await promptFile.execute({
  componentName: 'UserProfile',
  props: 'userId: string, onUpdate: () => void'
});</code></pre>

          <h2>Variables & Parameters</h2>
          
          <h3>Variable Syntax</h3>
          <pre><code>// Simple variable
{{variableName}}

// With default value
{{variableName | default: "DefaultValue"}}

// Optional variable
{{variableName?}}

// Conditional block
{{#if variableName}}
  This appears if variableName is provided
{{/if}}</code></pre>

          <h3>Example with Variables</h3>
          <pre><code>---
title: API Endpoint Template
---

Create a {{method | default: "GET"}} API endpoint:

**Path:** /api/{{resourceName}}

{{#if authentication}}
**Authentication:** Required ({{authentication}})
{{/if}}

**Request:**
{{#if requestBody}}
```typescript
interface {{resourceName}}Request {
  {{requestBody}}
}
```
{{/if}}

**Response:**
```typescript
interface {{resourceName}}Response {
  {{responseBody}}
}
```</code></pre>

          <h2>Advanced Features</h2>
          
          <h3>Context Injection</h3>
          <pre><code>---
title: Fix Bug with Context
context:
  - currentFile
  - selection
  - diagnostics
---

Analyze and fix the bug in the selected code:

**File:** {{context.currentFile}}
**Code:**
```
{{context.selection}}
```

**Errors:**
{{context.diagnostics}}

Provide a fix with explanation.</code></pre>

          <h3>Multi-Step Prompts</h3>
          <pre><code>---
title: Feature Development Wizard
steps:
  - name: design
    prompt: Design the feature architecture
  - name: implement
    prompt: Implement the feature
  - name: test
    prompt: Create comprehensive tests
  - name: document
    prompt: Write documentation
---

# Step {{currentStep}}: {{steps[currentStep].name}}

{{steps[currentStep].prompt}}

{{#if previousStepResult}}
**Previous step output:**
{{previousStepResult}}
{{/if}}</code></pre>

          <h2>Best Practices</h2>
          
          <h3>‚úÖ Effective Prompt Files</h3>
          <ul>
            <li>Clear, descriptive titles and metadata</li>
            <li>Well-defined parameters with defaults</li>
            <li>Include examples in the template</li>
            <li>Test with various inputs</li>
            <li>Version control and document changes</li>
            <li>Organize by domain or task type</li>
          </ul>

          <h3>üìÑ Template Structure</h3>
          <ul>
            <li>Start with context and goals</li>
            <li>Specify constraints and requirements</li>
            <li>Provide examples</li>
            <li>Request specific output format</li>
            <li>Include validation criteria</li>
          </ul>

          <h2>Sharing Prompt Files</h2>
          
          <h3>Within Organization</h3>
          <pre><code>// settings.json
{
  "github.copilot.prompts.sources": [
    "file://.copilot/prompts",
    "git://github.com/company/copilot-prompts",
    "https://company.com/prompts"
  ]
}</code></pre>

          <h3>Public Sharing</h3>
          <ul>
            <li>Create GitHub repository of prompt files</li>
            <li>Publish as VS Code extension</li>
            <li>Share via team wiki or documentation</li>
          </ul>

          <h2>Example Library</h2>
          
          <h3>Code Generation</h3>
          <ul>
            <li><code>react/component.md</code> - React component generator</li>
            <li><code>api/endpoint.md</code> - REST API endpoint</li>
            <li><code>database/model.md</code> - Database model</li>
          </ul>

          <h3>Code Review</h3>
          <ul>
            <li><code>review/security.md</code> - Security review</li>
            <li><code>review/performance.md</code> - Performance analysis</li>
            <li><code>review/accessibility.md</code> - A11y check</li>
          </ul>

          <h3>Documentation</h3>
          <ul>
            <li><code>docs/readme.md</code> - README generator</li>
            <li><code>docs/api.md</code> - API documentation</li>
            <li><code>docs/architecture.md</code> - Architecture docs</li>
          </ul>

          <h3>Testing</h3>
          <ul>
            <li><code>test/unit.md</code> - Unit test generator</li>
            <li><code>test/integration.md</code> - Integration tests</li>
            <li><code>test/e2e.md</code> - End-to-end tests</li>
          </ul>
        </section>

        <!-- Custom Instructions Section -->
        <section id="custom-instructions" role="article">
          <h1>üìù Custom Instructions</h1>
          <span class="badge">instructions</span>
          <span class="badge">rules</span>
          
          <p>Custom instructions define global rules and guidelines that GitHub Copilot follows across all interactions. They shape agent behavior to align with your preferences, standards, and workflows.</p>

          <div class="callout">
            <strong>üéØ Set the Ground Rules</strong><br />
            Custom instructions act as a persistent system prompt, ensuring every AI interaction follows your team's standards and preferences.
          </div>

          <h2>What are Custom Instructions?</h2>
          <ul>
            <li><strong>Global rules</strong> applied to all Copilot interactions</li>
            <li><strong>Persistent context</strong> across chat sessions</li>
            <li><strong>Team standards</strong> encoded as AI guidelines</li>
            <li><strong>Customizable scope</strong> (user, workspace, organization)</li>
          </ul>

          <h2>Instruction Files</h2>
          
          <h3>User-Level Instructions</h3>
          <pre><code>// ~/.copilot/instructions.md

# Personal Coding Preferences

## Code Style
- Always use TypeScript with strict mode
- Prefer functional programming patterns
- Use descriptive variable names (no abbreviations)

## Documentation
- Include JSDoc for all public functions
- Add TODO comments for future improvements
- Explain complex logic with inline comments

## Testing
- Suggest tests when generating new functions
- Prefer integration tests over unit tests
- Use descriptive test names

## General
- Explain your reasoning
- Provide alternatives when appropriate
- Ask clarifying questions if requirements unclear</code></pre>

          <h3>Workspace Instructions</h3>
          <pre><code>// .copilot/instructions.md

# Project: E-Commerce Platform

## Architecture
- We use microservices architecture
- Each service has its own database (no shared DB)
- Communication via REST APIs and message queues

## Technology Stack
- Backend: Node.js + Express + TypeScript
- Frontend: React 18 + TypeScript
- Database: PostgreSQL
- Message Queue: RabbitMQ
- Cache: Redis

## Coding Standards
- Follow Airbnb style guide
- Maximum function length: 50 lines
- Maximum file length: 300 lines
- Cyclomatic complexity < 10

## Security
- Never log sensitive data (passwords, tokens, PII)
- Always validate user input
- Use parameterized queries (prevent SQL injection)
- Implement rate limiting on all APIs

## Error Handling
- Always catch and handle errors
- Return meaningful error messages
- Log errors with context
- Use custom error classes

## API Design
- RESTful conventions
- Versioned endpoints (/api/v1/...)
- Use HTTP status codes correctly
- Consistent response format

## Don't Do
- Don't use var (use const/let)
- Don't use any type in TypeScript
- Don't bypass authentication checks
- Don't commit secrets or credentials</code></pre>

          <h2>Instruction Patterns</h2>
          
          <h3>Pattern 1: Always Do / Never Do</h3>
          <pre><code>## Always Do
- Use async/await instead of callbacks
- Validate input at API boundaries
- Write tests for business logic
- Handle error cases explicitly

## Never Do
- Use synchronous file operations
- Expose stack traces to users
- Store passwords in plain text
- Bypass type checking with 'as any'</code></pre>

          <h3>Pattern 2: Conditional Guidelines</h3>
          <pre><code>## When Creating API Endpoints
- Add input validation using Zod
- Include OpenAPI documentation
- Implement request/response logging
- Add rate limiting

## When Writing Database Queries
- Use transactions for related updates
- Add appropriate indexes
- Handle connection errors
- Use prepared statements

## When Handling User Data
- Sanitize all inputs
- Encrypt sensitive fields
- Add audit logging
- Comply with GDPR requirements</code></pre>

          <h3>Pattern 3: Role-Based Instructions</h3>
          <pre><code>## You are an Expert Engineer on Our Team

You have deep knowledge of:
- Our codebase architecture and patterns
- Our tech stack and its best practices
- Our team's coding standards
- Common pitfalls in our domain

Your role:
- Guide developers toward best solutions
- Identify potential issues early
- Suggest improvements proactively
- Explain complex concepts clearly

Your communication style:
- Be concise but thorough
- Use examples from our codebase
- Prefer code over lengthy explanations
- Ask questions when requirements are unclear</code></pre>

          <h2>Scoping Instructions</h2>
          
          <h3>Global (User-Level)</h3>
          <pre><code>// ~/.vscode/settings.json
{
  "github.copilot.chat.codeGeneration.instructions": [
    {
      "text": "Always use TypeScript"
    },
    {
      "text": "Prefer functional programming"
    }
  ]
}</code></pre>

          <h3>Workspace-Level</h3>
          <pre><code>// .vscode/settings.json
{
  "github.copilot.chat.codeGeneration.instructions": [
    {
      "file": ".copilot/instructions.md"
    }
  ]
}</code></pre>

          <h3>File-Pattern Specific</h3>
          <pre><code>// .vscode/settings.json
{
  "github.copilot.chat.codeGeneration.instructions": [
    {
      "text": "Use Jest and React Testing Library",
      "pattern": "**/*.test.ts*"
    },
    {
      "text": "Include JSX accessibility props",
      "pattern": "**/*.tsx"
    }
  ]
}</code></pre>

          <h2>Domain-Specific Instructions</h2>
          
          <h3>For React Projects</h3>
          <pre><code># React Development Guidelines

- Use functional components with hooks
- Prefer composition over inheritance
- Keep components small and focused
- Extract custom hooks for reusable logic
- Use TypeScript for prop validation
- Implement proper error boundaries
- Optimize with useMemo/useCallback when needed
- Follow React naming conventions (PascalCase for components)</code></pre>

          <h3>For API Development</h3>
          <pre><code># API Development Standards

- Follow REST principles
- Use HTTP methods semantically (GET, POST, PUT, DELETE)
- Implement proper error responses (4xx, 5xx)
- Include request/response validation
- Add API versioning (/v1/, /v2/)
- Implement pagination for list endpoints
- Use consistent naming (plural nouns for resources)
- Include CORS configuration
- Add rate limiting and throttling</code></pre>

          <h3>For Data Science</h3>
          <pre><code># Data Science & ML Guidelines

- Document data preprocessing steps
- Include reproducibility considerations (random seeds)
- Add data validation and quality checks
- Use vectorized operations (avoid loops)
- Document model assumptions and limitations
- Include performance metrics (accuracy, F1, etc.)
- Add visualization for data exploration
- Handle missing data explicitly</code></pre>

          <h2>Combining Instructions</h2>
          
          <h3>Merge Order (Priority)</h3>
          <ol>
            <li>Inline chat instructions (highest)</li>
            <li>File-pattern specific instructions</li>
            <li>Workspace instructions</li>
            <li>User-level instructions</li>
            <li>Default Copilot behavior (lowest)</li>
          </ol>

          <h3>Example Combination</h3>
          <pre><code>// User instructions
"Always use TypeScript"

// Workspace instructions
"Follow Airbnb style guide"

// File-pattern instructions (*.test.ts)
"Use Jest and Testing Library"

// Final merged instructions for test file:
- Always use TypeScript
- Follow Airbnb style guide  
- Use Jest and Testing Library</code></pre>

          <h2>Best Practices</h2>
          
          <h3>‚úÖ Effective Instructions</h3>
          <ul>
            <li>Be specific and unambiguous</li>
            <li>Use positive language (do X, not don't do Y)</li>
            <li>Provide examples when possible</li>
            <li>Keep instructions concise</li>
            <li>Update regularly based on team feedback</li>
            <li>Document the "why" behind rules</li>
          </ul>

          <h3>‚ö†Ô∏è Avoid</h3>
          <ul>
            <li>Contradictory instructions</li>
            <li>Overly restrictive rules (stifles creativity)</li>
            <li>Vague guidelines ("write good code")</li>
            <li>Too many instructions (information overload)</li>
            <li>Outdated or irrelevant rules</li>
          </ul>

          <h2>Measurement & Iteration</h2>
          
          <h3>Track Effectiveness</h3>
          <ul>
            <li>Monitor code review comments</li>
            <li>Check if generated code follows standards</li>
            <li>Gather developer feedback</li>
            <li>Measure time saved</li>
          </ul>

          <h3>Iterate</h3>
          <ul>
            <li>Review instructions monthly</li>
            <li>Add rules for common issues</li>
            <li>Remove outdated guidelines</li>
            <li>Refine based on team changes</li>
          </ul>
        </section>

        <!-- Agent Skills Section -->
        <section id="agent-skills" role="article">
          <h1>‚öôÔ∏è Agent Skills</h1>
          <span class="badge">skills</span>
          <span class="badge">capabilities</span>
          
          <p>Skills are specialized knowledge packages that extend agent capabilities. A skill is simply a folder with a <code>SKILL.md</code> file containing instructions for the agent.</p>

          <div class="callout">
            <strong>üìñ Official Spec: <a href="https://agentskills.io/" target="_blank">agentskills.io</a></strong><br />
            Agent Skills is an open, lightweight format supported by multiple AI agents and tools.
          </div>

          <p>Long prompts hurt agent performance. Instead of one massive system prompt, agents maintain a small catalog of <strong>skills</strong> ‚Äî reusable playbooks with clear instructions, loaded only when needed.</p>

          <h3>Agent Skills Workflow</h3>
          <ol>
            <li><strong>User Query:</strong> User submits a request (e.g., "Analyze data &amp; draft report")</li>
            <li><strong>Build Prompt + Skills Index:</strong> Agent runtime combines the query with a lightweight Skills metadata index ‚Äî a list of available skills and their short descriptions</li>
            <li><strong>Reason &amp; Select Skill:</strong> The LLM processes the prompt and decides: "I want Skill X"</li>
            <li><strong>Load Skill into Context:</strong> The agent runtime loads the specific <code>SKILL.md</code> file into the LLM's active context window</li>
            <li><strong>Final Output:</strong> The LLM follows the skill instructions, runs necessary scripts, and generates the output</li>
          </ol>

          <div class="callout">
            <strong>‚úÖ Why Agent Skills Matter</strong><br />
            By dynamically loading skills only when needed, Agent Skills keep context small, tokens efficient, and the LLM's behavior consistent across requests.
          </div>

          <h2>Basic Folder Structure</h2>
          <pre><code>my-skill/
‚îú‚îÄ‚îÄ SKILL.md          # Required: frontmatter + instructions
‚îú‚îÄ‚îÄ scripts/          # Optional: executable code
‚îú‚îÄ‚îÄ references/       # Optional: detailed docs (loaded on demand)
‚îî‚îÄ‚îÄ assets/           # Optional: templates, schemas, etc.</code></pre>

          <h2>SKILL.md Format</h2>
          
          <h3>Required Frontmatter (YAML)</h3>
          <pre><code>---
name: skill-name              # lowercase, hyphens, must match folder name
description: What it does and when to use it. Include relevant keywords.
---</code></pre>

          <h3>Optional Frontmatter Fields</h3>
          <ul>
            <li><code>license</code> - License name or reference (e.g., "Apache-2.0")</li>
            <li><code>compatibility</code> - Environment requirements (e.g., "Requires Python 3.8+")</li>
            <li><code>metadata</code> - Custom key-value pairs (author, version, etc.)</li>
          </ul>

          <h3>Body Content (Markdown)</h3>
          <p>Write instructions in plain Markdown. Recommended sections:</p>
          <ul>
            <li><strong>When to use</strong> - Clear triggering scenarios</li>
            <li><strong>How to use</strong> - Step-by-step instructions</li>
            <li><strong>Examples</strong> - Code samples and outputs</li>
            <li><strong>Edge cases</strong> - Common issues and gotchas</li>
          </ul>
          <p><strong>Keep SKILL.md under 500 lines.</strong> Move detailed docs to <code>references/</code>.</p>

          <h2>Quick Example</h2>
          <pre><code>---
name: commit-messages
description: Generate conventional commit messages. Use when user asks about git commits or commit message format.
metadata:
  author: dev-team
  version: "1.0"
---

# Conventional Commit Messages

## Format
```
<type>(<scope>): <subject>
```

## Types
- **feat**: New feature
- **fix**: Bug fix
- **docs**: Documentation
- **refactor**: Code restructuring

## Example
```
feat(auth): add OAuth2 login support
```</code></pre>

          <h2>Where to Put Skills</h2>
          <table class="table table-striped">
            <thead>
              <tr>
                <th>Location</th>
                <th>When to Use</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><code>skills/</code></td>
                <td>‚úÖ Recommended. Visible at project root, easy to manage</td>
              </tr>
              <tr>
                <td><code>.vscode/skills/</code></td>
                <td>Traditional location for VS Code projects</td>
              </tr>
              <tr>
                <td><code>~/.vscode/skills/</code></td>
                <td>Personal skills shared across all your projects</td>
              </tr>
            </tbody>
          </table>

          <h2>Naming Rules</h2>
          <ul>
            <li>‚úÖ Lowercase letters, numbers, hyphens only: <code>pdf-processing</code></li>
            <li>‚úÖ Must match folder name exactly</li>
            <li>‚ùå No uppercase: <code>PDF-Processing</code></li>
            <li>‚ùå No underscores: <code>pdf_processing</code></li>
            <li>‚ùå Can't start/end with hyphen: <code>-pdf</code> or <code>pdf-</code></li>
          </ul>

          <h2>Best Practices</h2>
          <ul>
            <li><strong>One skill, one purpose</strong> - Keep skills focused and specific</li>
            <li><strong>Good descriptions</strong> - Include WHAT it does and WHEN to use it</li>
            <li><strong>Include examples</strong> - Show, don't just tell</li>
            <li><strong>Keep it concise</strong> - Under 500 lines in SKILL.md</li>
            <li><strong>Version control</strong> - Commit skills to git with your codebase</li>
            <li><strong>Validate</strong> - Use <code>skills-ref validate ./skill-name</code></li>
          </ul>

          <h2>Common Skill Types</h2>
          <ul>
            <li><strong>Technology:</strong> react-hooks, sql-queries, api-design</li>
            <li><strong>Process:</strong> code-review, testing-patterns, documentation</li>
            <li><strong>Domain:</strong> security-standards, accessibility, performance</li>
            <li><strong>Project-specific:</strong> company-style-guide, deployment-checklist</li>
          </ul>

          <h2>Validation & Tools</h2>
          <pre><code># Install validator
npm install -g @agentskills/skills-ref

# Validate a skill
skills-ref validate ./my-skill</code></pre>

          <h2>Resources</h2>
          <ul>
            <li><a href="https://agentskills.io/" target="_blank">Official Specification</a></li>
            <li><a href="https://agentskills.io/specification" target="_blank">Complete Format Docs</a></li>
            <li><a href="https://github.com/anthropics/skills" target="_blank">Example Skills (GitHub)</a></li>
            <li><a href="https://github.com/agentskills/agentskills/tree/main/skills-ref" target="_blank">Validation Tools</a></li>
          </ul>
        </section>

        <!-- Agent Capabilities Section -->
        <section id="agent-capabilities" role="article">
          <h1>üéØ Agent Capabilities</h1>
          <span class="badge">capabilities</span>
          <span class="badge">permissions</span>
          <span class="badge">features</span>
          
          <p>Agent capabilities are feature flags that control what actions your agent can perform at runtime. They define the permissions and operational boundaries for your agent, ensuring security while enabling powerful functionality.</p>

          <div class="callout">
            <strong>üîí Security Through Explicit Permissions</strong><br />
            Capabilities follow the principle of least privilege‚Äîagents only receive the permissions they explicitly declare. This prevents unauthorized actions and provides clear visibility into what each agent can do.
          </div>

          <h2>Core Capabilities</h2>

          <table class="table table-striped">
            <thead>
              <tr>
                <th>Capability</th>
                <th>Grants Access To</th>
                <th>Use Cases</th>
                <th>Risk Level</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><code>code-editing</code></td>
                <td>Read, create, modify, delete files</td>
                <td>Refactoring, code generation, migrations</td>
                <td><span style="color: #f59e0b;">‚ö†Ô∏è Medium</span></td>
              </tr>
              <tr>
                <td><code>terminal-access</code></td>
                <td>Execute shell commands</td>
                <td>Build, test, deploy, install dependencies</td>
                <td><span style="color: #ef4444;">‚ùó High</span></td>
              </tr>
              <tr>
                <td><code>web-search</code></td>
                <td>Search the internet</td>
                <td>Documentation lookup, error research</td>
                <td><span style="color: #10b981;">‚úÖ Low</span></td>
              </tr>
              <tr>
                <td><code>git-operations</code></td>
                <td>Git commands (commit, branch, merge)</td>
                <td>Version control automation, PR creation</td>
                <td><span style="color: #f59e0b;">‚ö†Ô∏è Medium</span></td>
              </tr>
              <tr>
                <td><code>api-calls</code></td>
                <td>Make HTTP requests to external APIs</td>
                <td>Third-party integrations, data fetching</td>
                <td><span style="color: #f59e0b;">‚ö†Ô∏è Medium</span></td>
              </tr>
              <tr>
                <td><code>file-system-read</code></td>
                <td>Read files (without edit permissions)</td>
                <td>Code analysis, documentation generation</td>
                <td><span style="color: #10b981;">‚úÖ Low</span></td>
              </tr>
              <tr>
                <td><code>workspace-symbols</code></td>
                <td>Access code symbols and AST</td>
                <td>Code navigation, refactoring assistance</td>
                <td><span style="color: #10b981;">‚úÖ Low</span></td>
              </tr>
              <tr>
                <td><code>environment-variables</code></td>
                <td>Read environment variables</td>
                <td>Configuration detection, deployment</td>
                <td><span style="color: #f59e0b;">‚ö†Ô∏è Medium</span></td>
              </tr>
              <tr>
                <td><code>secrets-access</code></td>
                <td>Access secrets and credentials</td>
                <td>Deployment, authenticated API calls</td>
                <td><span style="color: #ef4444;">‚ùó High</span></td>
              </tr>
              <tr>
                <td><code>extension-api</code></td>
                <td>Call VS Code extension APIs</td>
                <td>Deep IDE integration, custom workflows</td>
                <td><span style="color: #f59e0b;">‚ö†Ô∏è Medium</span></td>
              </tr>
            </tbody>
          </table>

          <h2>Configuration</h2>

          <h3>Declaring Capabilities</h3>
          <p>Capabilities are declared in your agent definition schema (<code>agent.json</code> or <code>.github/copilot/agent.yml</code>):</p>

          <pre><code>{
  "name": "deployment-assistant",
  "description": "Automates deployment workflows",
  "capabilities": [
    "code-editing",
    "terminal-access",
    "git-operations",
    "environment-variables"
  ]
}</code></pre>

          <h3>Runtime Enforcement</h3>
          <p>Capabilities are enforced at runtime. If an agent attempts an action without the required capability, the operation is blocked:</p>

          <pre><code>// Agent without 'terminal-access' capability
await agent.executeCommand('npm install');
// ‚ùå Error: Agent lacks 'terminal-access' capability

// Agent with 'terminal-access' capability
await agent.executeCommand('npm install');
// ‚úÖ Success: Command executed</code></pre>

          <h2>Capability Details</h2>

          <h3>code-editing</h3>
          <p><strong>What it enables:</strong> Full read/write access to workspace files</p>
          <p><strong>Common use cases:</strong></p>
          <ul>
            <li>Automated refactoring and code improvements</li>
            <li>Generating boilerplate code and templates</li>
            <li>Migrating code between frameworks or versions</li>
            <li>Fixing bugs and applying patches</li>
            <li>Creating new files and project scaffolding</li>
          </ul>

          <p><strong>Security considerations:</strong></p>
          <ul>
            <li>Can modify production code‚Äîensure proper testing</li>
            <li>Recommend requiring user confirmation for destructive changes</li>
            <li>Consider read-only mode (<code>file-system-read</code>) for analysis tasks</li>
            <li>Implement undo/rollback mechanisms</li>
          </ul>

          <pre><code>// Example: Code editing agent
{
  "name": "refactor-assistant",
  "capabilities": ["code-editing"],
  "instructions": [
    { "content": "Always create backup before modifying files" },
    { "content": "Require user confirmation for multi-file changes" }
  ]
}</code></pre>

          <h3>terminal-access</h3>
          <p><strong>What it enables:</strong> Execute shell commands in the workspace terminal</p>
          <p><strong>Common use cases:</strong></p>
          <ul>
            <li>Running build and test scripts</li>
            <li>Installing dependencies (<code>npm install</code>, <code>pip install</code>)</li>
            <li>Database migrations and seed commands</li>
            <li>Deployment scripts</li>
            <li>Running linters, formatters, and analyzers</li>
          </ul>

          <p><strong>Security considerations:</strong></p>
          <ul>
            <li><strong>Highest risk capability</strong>‚Äîcan execute arbitrary code</li>
            <li>Only grant to trusted agents</li>
            <li>Implement command whitelisting when possible</li>
            <li>Log all executed commands for audit trail</li>
            <li>Consider sandboxing or container isolation</li>
          </ul>

          <pre><code>// Example: Build automation agent
{
  "name": "build-runner",
  "capabilities": ["terminal-access"],
  "commands": [
    {
      "name": "build",
      "description": "Build the project",
      "arguments": [
        {
          "name": "mode",
          "type": "string",
          "options": ["development", "production"]
        }
      ]
    }
  ]
}</code></pre>

          <h3>web-search</h3>
          <p><strong>What it enables:</strong> Search the internet and access web content</p>
          <p><strong>Common use cases:</strong></p>
          <ul>
            <li>Looking up documentation and API references</li>
            <li>Researching error messages and stack traces</li>
            <li>Finding code examples and best practices</li>
            <li>Checking library versions and compatibility</li>
            <li>Staying updated with latest framework changes</li>
          </ul>

          <p><strong>Security considerations:</strong></p>
          <ul>
            <li>Low security risk‚Äîread-only external access</li>
            <li>May leak query information to search engines</li>
            <li>Verify sources for credibility</li>
            <li>Consider rate limiting to prevent abuse</li>
          </ul>

          <h3>git-operations</h3>
          <p><strong>What it enables:</strong> Perform Git version control operations</p>
          <p><strong>Common use cases:</strong></p>
          <ul>
            <li>Creating feature branches automatically</li>
            <li>Committing changes with descriptive messages</li>
            <li>Opening pull requests</li>
            <li>Managing merge conflicts</li>
            <li>Tagging releases</li>
          </ul>

          <p><strong>Security considerations:</strong></p>
          <ul>
            <li>Can modify version history‚Äîuse with caution</li>
            <li>Ensure commits are attributed correctly</li>
            <li>Implement branch protection rules</li>
            <li>Require code review for agent-generated PRs</li>
          </ul>

          <h3>api-calls</h3>
          <p><strong>What it enables:</strong> Make HTTP requests to external services</p>
          <p><strong>Common use cases:</strong></p>
          <ul>
            <li>Integrating with project management tools (Jira, Linear)</li>
            <li>Sending notifications (Slack, Teams, email)</li>
            <li>Fetching data from REST/GraphQL APIs</li>
            <li>Triggering CI/CD pipelines</li>
            <li>Accessing cloud service APIs</li>
          </ul>

          <p><strong>Security considerations:</strong></p>
          <ul>
            <li>Can leak workspace data to external services</li>
            <li>Whitelist allowed API endpoints when possible</li>
            <li>Handle API credentials securely</li>
            <li>Implement rate limiting</li>
            <li>Log all outbound requests</li>
          </ul>

          <h3>secrets-access</h3>
          <p><strong>What it enables:</strong> Read secrets, API keys, and credentials</p>
          <p><strong>Common use cases:</strong></p>
          <ul>
            <li>Deployment to cloud environments</li>
            <li>Authenticated API calls</li>
            <li>Database connections</li>
            <li>Third-party service integrations</li>
          </ul>

          <p><strong>Security considerations:</strong></p>
          <ul>
            <li><strong>Critical security risk</strong>‚Äîhandle with extreme care</li>
            <li>Only grant to essential agents</li>
            <li>Never log or display secrets in responses</li>
            <li>Implement secret rotation policies</li>
            <li>Use temporary, scoped credentials when possible</li>
            <li>Audit all secret access</li>
          </ul>

          <h2>Capability Combinations</h2>

          <h3>Read-Only Analysis Agent</h3>
          <pre><code>{
  "name": "code-analyzer",
  "capabilities": [
    "file-system-read",
    "workspace-symbols",
    "web-search"
  ]
}</code></pre>
          <p><strong>Best for:</strong> Code reviews, documentation, learning tools</p>

          <h3>Development Assistant</h3>
          <pre><code>{
  "name": "dev-helper",
  "capabilities": [
    "code-editing",
    "terminal-access",
    "git-operations",
    "workspace-symbols"
  ]
}</code></pre>
          <p><strong>Best for:</strong> Feature development, refactoring, testing</p>

          <h3>Deployment Agent</h3>
          <pre><code>{
  "name": "deployer",
  "capabilities": [
    "terminal-access",
    "git-operations",
    "environment-variables",
    "secrets-access",
    "api-calls"
  ]
}</code></pre>
          <p><strong>Best for:</strong> CI/CD automation, infrastructure management</p>

          <h3>Documentation Generator</h3>
          <pre><code>{
  "name": "doc-generator",
  "capabilities": [
    "file-system-read",
    "code-editing",
    "workspace-symbols",
    "web-search"
  ]
}</code></pre>
          <p><strong>Best for:</strong> Generating docs, README files, API references</p>

          <h2>Dynamic Capability Assignment</h2>

          <p>Some use cases require requesting capabilities at runtime based on user actions:</p>

          <pre><code>// Request capability escalation
async function requestTerminalAccess(agent: Agent) {
  const granted = await agent.requestCapability('terminal-access', {
    reason: 'User requested build execution',
    scope: 'current-session'
  });
  
  if (granted) {
    await agent.executeCommand('npm run build');
  } else {
    await agent.sendMessage('Terminal access required for build. Please grant permission.');
  }
}</code></pre>

          <h2>Best Practices</h2>

          <h3>‚úÖ Principle of Least Privilege</h3>
          <ul>
            <li>Grant only the minimum capabilities needed for the agent's purpose</li>
            <li>Start with read-only capabilities, add write permissions only when necessary</li>
            <li>Use specific capabilities instead of broad permissions</li>
            <li>Review and audit capability grants regularly</li>
          </ul>

          <h3>üîí Security Guidelines</h3>
          <ul>
            <li><strong>Never grant <code>terminal-access</code> + <code>secrets-access</code></strong> without strict controls</li>
            <li>Implement user confirmation for high-risk operations</li>
            <li>Log all capability usage for audit trails</li>
            <li>Use time-limited capability grants when possible</li>
            <li>Implement rollback mechanisms for destructive operations</li>
          </ul>

          <h3>üéØ Capability Design Patterns</h3>
          <ul>
            <li><strong>Layered Agents:</strong> Create specialized agents with narrow capabilities, compose them via subagents</li>
            <li><strong>Approval Workflows:</strong> Require user confirmation before executing high-risk capabilities</li>
            <li><strong>Capability Inference:</strong> Detect required capabilities from agent commands automatically</li>
            <li><strong>Sandboxing:</strong> Run agents with elevated capabilities in isolated environments</li>
            <li><strong>Gradual Escalation:</strong> Start with minimal permissions, request more as needed</li>
          </ul>

          <h3>üìä Monitoring & Compliance</h3>
          <ul>
            <li>Track capability usage metrics (which agents use which capabilities)</li>
            <li>Alert on unusual capability patterns (e.g., sudden secrets access)</li>
            <li>Generate compliance reports for capability grants</li>
            <li>Implement capability approval workflows for production agents</li>
            <li>Maintain a capability audit log</li>
          </ul>

          <h2>Capability Matrix by Agent Type</h2>

          <table class="table table-striped">
            <thead>
              <tr>
                <th>Agent Type</th>
                <th>Recommended Capabilities</th>
                <th>Avoid</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Code Review</strong></td>
                <td><code>file-system-read</code>, <code>workspace-symbols</code>, <code>web-search</code></td>
                <td><code>code-editing</code>, <code>terminal-access</code></td>
              </tr>
              <tr>
                <td><strong>Refactoring</strong></td>
                <td><code>code-editing</code>, <code>workspace-symbols</code>, <code>git-operations</code></td>
                <td><code>terminal-access</code>, <code>secrets-access</code></td>
              </tr>
              <tr>
                <td><strong>Testing</strong></td>
                <td><code>code-editing</code>, <code>terminal-access</code>, <code>file-system-read</code></td>
                <td><code>secrets-access</code>, <code>git-operations</code></td>
              </tr>
              <tr>
                <td><strong>Deployment</strong></td>
                <td><code>terminal-access</code>, <code>git-operations</code>, <code>environment-variables</code>, <code>api-calls</code></td>
                <td>None (requires all for function)</td>
              </tr>
              <tr>
                <td><strong>Documentation</strong></td>
                <td><code>file-system-read</code>, <code>code-editing</code>, <code>workspace-symbols</code>, <code>web-search</code></td>
                <td><code>terminal-access</code>, <code>secrets-access</code></td>
              </tr>
              <tr>
                <td><strong>Learning/Training</strong></td>
                <td><code>file-system-read</code>, <code>workspace-symbols</code>, <code>web-search</code></td>
                <td><code>code-editing</code>, <code>terminal-access</code>, <code>git-operations</code></td>
              </tr>
            </tbody>
          </table>

          <div class="callout">
            <strong>üí° Capability Discovery</strong><br />
            VS Code provides a <code>@capabilities</code> command to inspect what capabilities an agent has been granted. Use this for debugging and security audits.
          </div>

          <h2>Future Capabilities</h2>
          <p>The capabilities system is extensible. Future additions may include:</p>
          <ul>
            <li><code>debugger-control</code> - Start/stop debugging sessions</li>
            <li><code>profiler-access</code> - Performance profiling and analysis</li>
            <li><code>network-proxy</code> - Intercept and modify HTTP traffic</li>
            <li><code>container-management</code> - Docker/Kubernetes operations</li>
            <li><code>ai-model-training</code> - Fine-tune models on workspace data</li>
          </ul>
        </section>

        <!-- Language Models Section -->
        <section id="language-models" role="article">
          <h1>üß† Language Models</h1>
          <span class="badge">models</span>
          <span class="badge">llm</span>
          
          <p>Language models power GitHub Copilot agents, providing the AI capabilities for code generation, understanding, and interaction. Agents can use different models based on task requirements, balancing performance, cost, and capabilities.</p>

          <div class="callout">
            <strong>‚ö° Choose the Right Brain</strong><br />
            Different tasks require different models. Select the optimal model for your use case, balancing speed, cost, and capability.
          </div>

          <h2>Available Models</h2>
          
          <h3>GitHub Copilot Models</h3>
          <table class="table table-striped">
            <thead>
              <tr>
                <th>Model</th>
                <th>Capabilities</th>
                <th>Best For</th>
                <th>Context Window</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>GPT-4</strong></td>
                <td>Advanced reasoning, complex tasks</td>
                <td>Architecture design, complex problem solving</td>
                <td>8K - 128K tokens</td>
              </tr>
              <tr>
                <td><strong>GPT-3.5 Turbo</strong></td>
                <td>Fast, efficient responses</td>
                <td>Code completion, quick questions</td>
                <td>4K - 16K tokens</td>
              </tr>
              <tr>
                <td><strong>Claude 3</strong></td>
                <td>Long context, detailed analysis</td>
                <td>Document analysis, large codebases</td>
                <td>200K tokens</td>
              </tr>
              <tr>
                <td><strong>Codex</strong></td>
                <td>Code-specialized</td>
                <td>Code generation, translation</td>
                <td>8K tokens</td>
              </tr>
            </tbody>
          </table>

          <h2>Model Selection</h2>
          
          <h3>By Task Type</h3>
          <table class="table table-striped">
            <thead>
              <tr>
                <th>Task</th>
                <th>Recommended Model</th>
                <th>Reason</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Code completion</td>
                <td>GPT-3.5 Turbo / Codex</td>
                <td>Fast, low latency</td>
              </tr>
              <tr>
                <td>Complex refactoring</td>
                <td>GPT-4</td>
                <td>Better reasoning</td>
              </tr>
              <tr>
                <td>Documentation</td>
                <td>GPT-4 / Claude 3</td>
                <td>Better writing quality</td>
              </tr>
              <tr>
                <td>Code review</td>
                <td>GPT-4</td>
                <td>Deep understanding</td>
              </tr>
              <tr>
                <td>Large codebase analysis</td>
                <td>Claude 3</td>
                <td>Large context window</td>
              </tr>
              <tr>
                <td>Quick questions</td>
                <td>GPT-3.5 Turbo</td>
                <td>Speed + cost efficiency</td>
              </tr>
            </tbody>
          </table>

          <h2>Using Models in Agents</h2>
          
          <h3>Default Model</h3>
          <pre><code>// agent-config.json
{
  "name": "code-assistant",
  "model": "gpt-4",
  "temperature": 0.7
}</code></pre>

          <h3>Model per Function</h3>
          <pre><code>const agent = {
  functions: {
    quickAnswer: {
      model: 'gpt-3.5-turbo',
      temperature: 0.3
    },
    complexAnalysis: {
      model: 'gpt-4',
      temperature: 0.7
    },
    codebaseSearch: {
      model: 'claude-3',
      temperature: 0.5
    }
  }
};</code></pre>

          <h3>Dynamic Model Selection</h3>
          <pre><code>async function selectModel(request: AgentRequest): Promise<ModelConfig> {
  // Use fast model for simple completions
  if (request.type === 'completion' && request.context.length < 100) {
    return { model: 'gpt-3.5-turbo', maxTokens: 500 };
  }
  
  // Use powerful model for complex tasks
  if (request.type === 'refactor' || request.complexity === 'high') {
    return { model: 'gpt-4', maxTokens: 2000 };
  }
  
  // Use long-context model for large codebases
  if (request.context.length > 10000) {
    return { model: 'claude-3', maxTokens: 4000 };
  }
  
  return { model: 'gpt-4', maxTokens: 1000 };
}</code></pre>

          <h2>Model Configuration</h2>
          
          <h3>Temperature</h3>
          <p>Controls randomness in responses (0.0 - 2.0):</p>
          <ul>
            <li><strong>0.0 - 0.3:</strong> Deterministic, focused (code generation)</li>
            <li><strong>0.4 - 0.7:</strong> Balanced (general conversations)</li>
            <li><strong>0.8 - 1.5:</strong> Creative (brainstorming, exploration)</li>
          </ul>

          <pre><code>{
  "model": "gpt-4",
  "temperature": 0.2,  // Low for consistent code generation
}</code></pre>

          <h3>Max Tokens</h3>
          <p>Limits response length:</p>
          <pre><code>{
  "model": "gpt-4",
  "maxTokens": 1000,  // Limit response size
  "stopSequences": ["\n\n\n"]  // Stop at triple newline
}</code></pre>

          <h3>Top P (Nucleus Sampling)</h3>
          <p>Alternative to temperature (0.0 - 1.0):</p>
          <pre><code>{
  "model": "gpt-4",
  "topP": 0.9,  // Consider top 90% probability mass
}</code></pre>

          <h2>Model API Access</h2>
          
          <h3>Using Language Model API</h3>
          <pre><code>import * as vscode from 'vscode';

// Request access to models
const models = await vscode.lm.selectChatModels({
  vendor: 'copilot',
  family: 'gpt-4'
});

if (models.length === 0) {
  throw new Error('No models available');
}

const model = models[0];

// Create messages
const messages = [
  vscode.LanguageModelChatMessage.User('Explain this code'),
  vscode.LanguageModelChatMessage.Assistant('I\'ll analyze the code...'),
];

// Send request
const response = await model.sendRequest(messages, {}, token);

// Stream response
for await (const chunk of response.text) {
  console.log(chunk);
}</code></pre>

          <h3>Model Selection</h3>
          <pre><code>// Select specific model family
const gpt4Models = await vscode.lm.selectChatModels({
  vendor: 'copilot',
  family: 'gpt-4'
});

// Select by capabilities
const largeContextModels = await vscode.lm.selectChatModels({
  vendor: 'copilot',
  maxInputTokens: 100000  // Need large context
});

// Get model info
const model = models[0];
console.log(model.id);              // e.g., "gpt-4"
console.log(model.vendor);          // "copilot"
console.log(model.family);          // "gpt-4"
console.log(model.maxInputTokens);  // e.g., 8000</code></pre>

          <h2>Token Management</h2>
          
          <h3>Counting Tokens</h3>
          <pre><code>import { countTokens } from '@github/copilot';

const code = `
function factorial(n: number): number {
  return n <= 1 ? 1 : n * factorial(n - 1);
}
`;

const tokenCount = await countTokens(code, 'gpt-4');
console.log(`Code uses ${tokenCount} tokens`);

// Ensure we don't exceed limits
if (tokenCount > model.maxInputTokens) {
  // Truncate or chunk the content
  code = truncateToTokenLimit(code, model.maxInputTokens);
}</code></pre>

          <h3>Context Window Management</h3>
          <pre><code>function buildContext(request: AgentRequest, model: Model): string[] {
  const maxTokens = model.maxInputTokens;
  const reserved = 1000; // Reserve for response
  const available = maxTokens - reserved;
  
  let messages: string[] = [];
  let currentTokens = 0;
  
  // Add system prompt
  const systemPrompt = "You are a helpful coding assistant";
  currentTokens += countTokens(systemPrompt);
  messages.push(systemPrompt);
  
  // Add user message
  const userMessage = request.message;
  currentTokens += countTokens(userMessage);
  messages.push(userMessage);
  
  // Add context files (newest first)
  for (const file of request.contextFiles.reverse()) {
    const fileTokens = countTokens(file.content);
    
    if (currentTokens + fileTokens > available) {
      break; // Out of space
    }
    
    messages.push(file.content);
    currentTokens += fileTokens;
  }
  
  return messages;
}</code></pre>

          <h2>Cost Optimization</h2>
          
          <h3>Model Switching Strategy</h3>
          <pre><code>class AdaptiveAgent {
  async processRequest(request: Request) {
    // Try fast/cheap model first
    const quickResponse = await this.tryModel('gpt-3.5-turbo', request);
    
    // Check if response is adequate
    if (this.isGoodEnough(quickResponse)) {
      return quickResponse;
    }
    
    // Fall back to more capable model
    console.log('Retrying with more powerful model');
    return await this.tryModel('gpt-4', request);
  }
  
  isGoodEnough(response: Response): boolean {
    return response.confidence > 0.8 
        && response.hasCodeSamples
        && response.length > 100;
  }
}</code></pre>

          <h3>Caching Responses</h3>
          <pre><code>const responseCache = new Map<string, Response>();

async function getCachedResponse(prompt: string, model: string): Promise<Response> {
  const cacheKey = `${model}:${hash(prompt)}`;
  
  if (responseCache.has(cacheKey)) {
    console.log('Cache hit!');
    return responseCache.get(cacheKey)!;
  }
  
  const response = await model.sendRequest(prompt);
  responseCache.set(cacheKey, response);
  
  return response;
}</code></pre>

          <h2>Model Limitations</h2>
          
          <h3>Context Window</h3>
          <ul>
            <li>Limited by max tokens</li>
            <li>Must fit: system prompt + context + user message + response</li>
            <li>Need to truncate or chunk large inputs</li>
          </ul>

          <h3>Knowledge Cutoff</h3>
          <ul>
            <li>Models trained on data up to specific date</li>
            <li>May not know about recent APIs or libraries</li>
            <li>Provide recent context explicitly</li>
          </ul>

          <h3>Hallucinations</h3>
          <ul>
            <li>May generate plausible but incorrect code</li>
            <li>Always validate generated code</li>
            <li>Use lower temperature for factual tasks</li>
          </ul>

          <h2>Best Practices</h2>
          
          <h3>‚úÖ Model Selection</h3>
          <ul>
            <li>Use fastest model that meets requirements</li>
            <li>Consider cost vs. quality tradeoffs</li>
            <li>Test with different models for your use case</li>
            <li>Monitor performance and adjust</li>
          </ul>

          <h3>‚ö° Performance</h3>
          <ul>
            <li>Cache responses for repeated queries</li>
            <li>Use streaming for better UX</li>
            <li>Manage context window efficiently</li>
            <li>Implement timeouts and retries</li>
          </ul>

          <h3>üìä Monitoring</h3>
          <ul>
            <li>Track token usage</li>
            <li>Monitor response times</li>
            <li>Measure quality metrics</li>
            <li>Log errors and edge cases</li>
          </ul>
        </section>

        <!-- MCP Servers Section -->
        <section id="mcp-servers" role="article">
          <h1>üîó MCP Servers</h1>
          <span class="badge">mcp</span>
          <span class="badge">protocol</span>
          
          <p>Model Context Protocol (MCP) servers extend agent capabilities by providing external data sources, tools, and integrations. They enable agents to access databases, APIs, file systems, and other resources in a standardized way.</p>

          <div class="callout">
            <strong>üåê Connect to Anything</strong><br />
            MCP servers bridge the gap between AI agents and external systems, enabling real-world data access and actions.
          </div>

          <h2>What is MCP?</h2>
          <ul>
            <li><strong>Standardized protocol</strong> for AI-to-system communication</li>
            <li><strong>Server-based architecture</strong> for scalability</li>
            <li><strong>Tool and resource providers</strong> for agents</li>
            <li><strong>Security layer</strong> for controlled access</li>
            <li><strong>Extensible</strong> - build custom servers for any integration</li>
          </ul>

          <h2>Architecture</h2>
          <div style="background: #f8f9fa; border: 1px solid #dee2e6; border-radius: 8px; padding: 30px; margin: 20px 0; font-family: monospace; text-align: center;">
            <div style="background: #e3f2fd; border: 2px solid #2196f3; border-radius: 6px; padding: 15px; margin-bottom: 20px; display: inline-block; min-width: 250px;">
              <strong style="font-size: 16px;">ü§ñ AI Agent / GitHub Copilot</strong>
            </div>
            
            <div style="margin: 15px 0; font-size: 24px; color: #666;">‚ÜïÔ∏è</div>
            
            <div style="background: #fff3e0; border: 2px solid #ff9800; border-radius: 6px; padding: 15px; margin-bottom: 20px; display: inline-block; min-width: 250px;">
              <strong style="font-size: 16px;">üîó Model Context Protocol</strong><br/>
              <span style="font-size: 12px; color: #666;">Standardized communication layer</span>
            </div>
            
            <div style="margin: 15px 0; font-size: 24px; color: #666;">‚ÜïÔ∏è</div>
            
            <div style="background: #f3e5f5; border: 2px solid #9c27b0; border-radius: 6px; padding: 15px; margin-bottom: 20px; display: inline-block; min-width: 250px;">
              <strong style="font-size: 16px;">‚öôÔ∏è MCP Servers</strong><br/>
              <span style="font-size: 12px; color: #666;">File System ‚Ä¢ Database ‚Ä¢ APIs ‚Ä¢ Custom</span>
            </div>
            
            <div style="margin: 15px 0; font-size: 24px; color: #666;">‚ÜïÔ∏è</div>
            
            <div style="display: flex; justify-content: center; gap: 15px; flex-wrap: wrap;">
              <div style="background: #e8f5e9; border: 2px solid #4caf50; border-radius: 6px; padding: 10px 15px; font-size: 14px;">
                üìÅ Files
              </div>
              <div style="background: #e8f5e9; border: 2px solid #4caf50; border-radius: 6px; padding: 10px 15px; font-size: 14px;">
                üóÑÔ∏è Database
              </div>
              <div style="background: #e8f5e9; border: 2px solid #4caf50; border-radius: 6px; padding: 10px 15px; font-size: 14px;">
                üåê APIs
              </div>
              <div style="background: #e8f5e9; border: 2px solid #4caf50; border-radius: 6px; padding: 10px 15px; font-size: 14px;">
                ‚òÅÔ∏è Cloud
              </div>
            </div>
          </div>

          <p style="text-align: center; font-style: italic; color: #666; margin-top: 10px;">
            MCP servers act as bridges, translating agent requests into system-specific actions
          </p>

          <h2>Built-in MCP Servers</h2>
          
          <h3>File System Server</h3>
          <pre><code>// mcp-config.json
{
  "mcpServers": {
    "filesystem": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-filesystem", "/workspace"]
    }
  }
}</code></pre>

          <h3>Database Server</h3>
          <pre><code>{
  "mcpServers": {
    "postgres": {
      "command": "npx",
      "args": ["-y", "@modelcontextprotocol/server-postgres"],
      "env": {
        "DATABASE_URL": "postgresql://user:pass@localhost:5432/db"
      }
    }
  }
}</code></pre>

          <h2>Using MCP Servers in Agents</h2>
          
          <h3>Agent Configuration</h3>
          <pre><code>// agent-config.json
{
  "name": "database-agent",
  "mcpServers": ["postgres", "filesystem"],
  "allowedTools": [
    "query_database",
    "read_file",
    "list_tables"
  ]
}</code></pre>

          <h2>Best Practices</h2>
          <ul>
            <li>Provide clear tool descriptions</li>
            <li>Use strict input schemas</li>
            <li>Implement proper authentication</li>
            <li>Handle errors gracefully</li>
            <li>Cache frequent queries</li>
          </ul>
        </section>

        <!-- Hooks Section -->
        <section id="hooks" role="article">
          <h1>ü™ù Hooks</h1>
          <span class="badge">hooks</span>
          <span class="badge">events</span>
          
          <p>Hooks allow you to intercept and customize agent behavior at various points in the execution lifecycle. They enable logging, validation, transformation, and advanced customization of agent interactions.</p>

          <div class="callout">
            <strong>‚ö° Intercept & Customize</strong><br />
            Hooks give you fine-grained control over agent behavior, enabling monitoring, validation, and custom logic at every stage.
          </div>

          <h2>Lifecycle Hooks</h2>
          
          <table class="table table-striped">
            <thead>
              <tr>
                <th>Hook</th>
                <th>When Called</th>
                <th>Use Cases</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>onSessionStart</strong></td>
                <td>Session begins</td>
                <td>Initialize context, load user preferences</td>
              </tr>
              <tr>
                <td><strong>onMessageReceived</strong></td>
                <td>User sends message</td>
                <td>Input validation, preprocessing, logging</td>
              </tr>
              <tr>
                <td><strong>onBeforeToolCall</strong></td>
                <td>Before tool execution</td>
                <td>Permission checks, parameter validation</td>
              </tr>
              <tr>
                <td><strong>onAfterToolCall</strong></td>
                <td>After tool execution</td>
                <td>Result transformation, caching, auditing</td>
              </tr>
              <tr>
                <td><strong>onBeforeResponse</strong></td>
                <td>Before sending response</td>
                <td>Content filtering, formatting, compliance checks</td>
              </tr>
              <tr>
                <td><strong>onSessionEnd</strong></td>
                <td>Session terminates</td>
                <td>Cleanup, save state, generate summary</td>
              </tr>
              <tr>
                <td><strong>onError</strong></td>
                <td>Error occurs</td>
                <td>Error handling, logging, recovery</td>
              </tr>
            </tbody>
          </table>

          <h2>Common Use Cases</h2>

          <h3>1. Input Validation</h3>
          <p><strong>Purpose:</strong> Validate and sanitize user messages before processing</p>
          <ul>
            <li>Block messages containing sensitive keywords (passwords, API keys)</li>
            <li>Enforce message length limits</li>
            <li>Check for malicious content or injection attempts</li>
            <li>Log message metadata for monitoring</li>
          </ul>

          <h3>2. Tool Permission Checking</h3>
          <p><strong>Purpose:</strong> Control which tools users can access and how often</p>
          <ul>
            <li>Verify user has permission to use specific tools</li>
            <li>Enforce tool-specific security requirements (e.g., sandbox for code execution)</li>
            <li>Implement rate limiting per tool</li>
            <li>Track tool usage statistics</li>
          </ul>

          <h3>3. Result Transformation & Caching</h3>
          <p><strong>Purpose:</strong> Optimize performance and standardize tool outputs</p>
          <ul>
            <li>Cache results from expensive operations</li>
            <li>Normalize data formats (e.g., file paths)</li>
            <li>Add metadata (timestamps, session IDs)</li>
            <li>Transform results for consistency</li>
          </ul>

          <h3>4. Response Filtering & Compliance</h3>
          <p><strong>Purpose:</strong> Ensure responses meet security and compliance requirements</p>
          <ul>
            <li>Remove or redact sensitive information (PII, credentials)</li>
            <li>Add disclaimers for AI-generated content</li>
            <li>Enforce content policy rules</li>
            <li>Apply organization-specific formatting</li>
          </ul>

          <h3>5. Error Handling & Recovery</h3>
          <p><strong>Purpose:</strong> Provide graceful error handling and user-friendly messages</p>
          <ul>
            <li>Log detailed error information for debugging</li>
            <li>Track error frequency per session</li>
            <li>Translate technical errors into user-friendly messages</li>
            <li>Implement retry logic for recoverable errors</li>
          </ul>

          <h3>6. Session State Management</h3>
          <p><strong>Purpose:</strong> Initialize, maintain, and cleanup session data</p>
          <ul>
            <li>Initialize session state with user preferences</li>
            <li>Load conversation history</li>
            <li>Track session metrics (duration, message count, tool usage)</li>
            <li>Save conversation state and analytics on session end</li>
          </ul>

          <h3>7. Logging & Monitoring</h3>
          <p><strong>Purpose:</strong> Comprehensive observability for agent operations</p>
          <ul>
            <li>Log all message interactions with metadata</li>
            <li>Track tool execution start/completion</li>
            <li>Monitor error rates and patterns</li>
            <li>Send alerts for critical failures</li>
          </ul>

          <h3>8. Multi-Hook Composition</h3>
          <p><strong>Purpose:</strong> Combine multiple concerns in organized, reusable modules</p>
          <ul>
            <li>Create security hook bundles (validation, permissions, PII filtering)</li>
            <li>Build analytics hook packages (tracking, metrics, reporting)</li>
            <li>Compose hooks for complex workflows</li>
            <li>Share common hook patterns across agents</li>
          </ul>

          <h2>Hook Patterns</h2>

          <h3>Pattern 1: Middleware Chain</h3>
          <p>Process messages through a series of sequential steps, where each step can modify the data or terminate the chain.</p>
          <p><strong>Use for:</strong> Multi-step validation, preprocessing pipelines, ordered transformations</p>

          <h3>Pattern 2: Event Broadcasting</h3>
          <p>Broadcast hook events to multiple independent handlers that run in parallel.</p>
          <p><strong>Use for:</strong> Multiple logging systems, parallel metrics collection, distributed monitoring</p>

          <h3>Pattern 3: Conditional Hooks</h3>
          <p>Execute hook logic only when specific conditions are met.</p>
          <p><strong>Use for:</strong> Environment-specific behavior (dev vs. prod), user role-based actions, tool-specific handling</p>

          <h2>Best Practices</h2>
          <ul>
            <li>‚úÖ <strong>Single responsibility</strong> - Each hook should do one thing well</li>
            <li>‚úÖ <strong>Non-blocking</strong> - Use async operations, avoid heavy computation</li>
            <li>‚úÖ <strong>Error handling</strong> - Always catch and handle errors gracefully</li>
            <li>‚úÖ <strong>Composable</strong> - Build reusable hook modules</li>
            <li>‚úÖ <strong>Monitor performance</strong> - Track execution time and optimize</li>
            <li>‚úÖ <strong>Cross-cutting concerns</strong> - Use for auth, logging, validation</li>
            <li>‚úÖ <strong>Document behavior</strong> - Explain side effects and dependencies</li>
            <li>‚ö†Ô∏è <strong>Avoid state mutation</strong> - Don't modify session state unpredictably</li>
            <li>‚ö†Ô∏è <strong>No synchronous I/O</strong> - Don't block execution with sync operations</li>
            <li>‚ö†Ô∏è <strong>Prevent circular dependencies</strong> - Keep hooks independent</li>
          </ul>
        </section>

        <!-- Tutorial Section -->
        <section id="tutorial" role="article">
          <h1>üöÄ Getting Started Tutorial</h1>
          <span class="badge">tutorial</span>
          <span class="badge">guide</span>
          <span class="badge">start</span>
          
          <p>This tutorial walks you through creating your first GitHub Copilot agent from scratch, covering the essentials of agent development.</p>

          <div class="callout">
            <strong>üéØ Build Your First Agent</strong><br />
            Follow this step-by-step guide to create, test, and deploy a functional GitHub Copilot agent in minutes.
          </div>

          <h2>Step 1: Setup</h2>
          
          <h3>Prerequisites</h3>
          <ul>
            <li>VS Code (latest version)</li>
            <li>Node.js 18+ and npm</li>
            <li>GitHub Copilot subscription</li>
            <li>TypeScript knowledge (basic)</li>
          </ul>

          <h3>Create Project</h3>
          <pre><code># Create extension project
npm install -g yo generator-code
yo code

# Select: New Extension (TypeScript)
# Name: my-first-agent
# Identifier: my-first-agent
# Description: My first Copilot agent

cd my-first-agent
npm install</code></pre>

          <h2>Step 2: Create the Agent</h2>
          
          <h3>Update package.json</h3>
          <pre><code>{
  "name": "my-first-agent",
  "contributes": {
    "chatParticipants": [
      {
        "id": "my-first-agent.helper",
        "name": "helper",
        "description": "A helpful coding assistant",
        "isSticky": true
      }
    ]
  }
}</code></pre>

          <h3>Implement Agent (src/extension.ts)</h3>
          <pre><code>import * as vscode from 'vscode';

export function activate(context: vscode.ExtensionContext) {
  // Create the chat agent
  const agent = vscode.chat.createChatParticipant(
    'my-first-agent.helper',
    async (request, context, response, token) => {
      const userMessage = request.prompt;

      // Simple response
      response.markdown(`Hello! You asked: "${userMessage}"

I'm a helpful coding assistant. I can:
- Answer coding questions
- Explain code
- Suggest improvements`);

      return;
    }
  );

  context.subscriptions.push(agent);
}</code></pre>

          <h2>Step 3: Test the Agent</h2>
          
          <h3>Run Extension</h3>
          <ol>
            <li>Press <strong>F5</strong> to launch Extension Development Host</li>
            <li>Open Copilot Chat</li>
            <li>Type <code>@helper What is TypeScript?</code></li>
            <li>See the agent respond!</li>
          </ol>

          <h2>Step 4: Add Tools</h2>
          
          <h3>Create a File Analysis Tool</h3>
          <pre><code>const agent = vscode.chat.createChatParticipant(
  'my-first-agent.helper',
  async (request, context, response, token) => {
    const userMessage = request.prompt;

    // Command: /analyze
    if (request.command === 'analyze') {
      const editor = vscode.window.activeTextEditor;
      if (!editor) {
        response.markdown('No file open!');
        return;
      }

      const document = editor.document;
      const text = document.getText();
      const lines = text.split('\n').length;
      const chars = text.length;

      response.markdown(`üìä **File Analysis**

- **File:** ${document.fileName}
- **Language:** ${document.languageId}
- **Lines:** ${lines}
- **Characters:** ${chars}
`);
      return;
    }

    // Default response
    response.markdown(`Hello! Ask me to analyze a file with \`/analyze\``);
  }
);

// Register the /analyze command
agent.commands = [
  {
    name: 'analyze',
    description: 'Analyze the current file'
  }
];</code></pre>

          <h2>Step 5: Add LLM Integration</h2>
          
          <h3>Use Language Model for Smart Responses</h3>
          <pre><code>async function generateResponse(prompt: string): Promise<string> {
  // Get available models
  const models = await vscode.lm.selectChatModels({ vendor: 'copilot' });
  if (models.length === 0) {
    throw new Error('No models available');
  }

  const model = models[0];
  const messages = [
    vscode.LanguageModelChatMessage.User(prompt)
  ];

  const response = await model.sendRequest(messages, {}, new vscode.CancellationTokenSource().token);
  
  let result = '';
  for await (const chunk of response.text) {
    result += chunk;
  }
  
  return result;
}

// Use in agent
const agent = vscode.chat.createChatParticipant(
  'my-first-agent.helper',
  async (request, context, response, token) => {
    response.progress('Thinking...');
    
    const aiResponse = await generateResponse(request.prompt);
    response.markdown(aiResponse);
  }
);</code></pre>

          <h2>Step 6: Package & Share</h2>
          
          <h3>Package Extension</h3>
          <pre><code># Install vsce
npm install -g @vscode/vsce

# Package extension
vsce package

# Creates: my-first-agent-0.0.1.vsix</code></pre>

          <h3>Install Locally</h3>
          <pre><code># In VS Code:
# Command Palette > Extensions: Install from VSIX
# Select the .vsix file</code></pre>

          <h2>Next Steps</h2>
          <ul>
            <li>‚úÖ Add more commands</li>
            <li>‚úÖ Integrate with APIs</li>
            <li>‚úÖ Add MCP servers for data access</li>
            <li>‚úÖ Implement custom skills</li>
            <li>‚úÖ Publish to VS Code Marketplace</li>
          </ul>
        </section>

        <!-- Best Practices Section -->
        <section id="best-practices" role="article">
          <h1>‚úÖ Best Practices</h1>
          <span class="badge">best practices</span>
          <span class="badge">guidelines</span>
          
          <p>Follow these best practices to build effective, maintainable, and user-friendly GitHub Copilot agents.</p>

          <div class="callout">
            <strong>üèÜ Build Better Agents</strong><br />
            These proven practices will help you create agents that users love and teams can maintain.
          </div>

          <h2>Agent Design</h2>
          
          <h3>‚úÖ Do</h3>
          <ul>
            <li>Focus on a specific domain or use case</li>
            <li>Use clear, descriptive names (@code-reviewer, @api-helper)</li>
            <li>Provide helpful descriptions and examples</li>
            <li>Make agents discoverable with good metadata</li>
            <li>Support both chat and inline interactions</li>
          </ul>

          <h3>‚ùå Don't</h3>
          <ul>
            <li>Create overly generic agents ("does everything")</li>
            <li>Use cryptic names or abbreviations</li>
            <li>Assume users know how to use your agent</li>
            <li>Ignore accessibility and usability</li>
            <li>Build without user feedback</li>
          </ul>

          <h2>User Experience</h2>
          
          <h3>Progressive Disclosure</h3>
          <pre><code>// Start simple
@myagent help

// Then introduce features
@myagent /analyze file.ts

// Advanced usage  
@myagent /analyze file.ts --depth=detailed --format=json</code></pre>

          <h3>Clear Feedback</h3>
          <pre><code>// Show progress for long operations
response.progress('Analyzing codebase...');
response.progress('Found 23 files...');
response.progress('Checking for issues...');

// Provide actionable responses
response.markdown(`Found 3 issues:

1. üî¥ **Security**: SQL injection risk at [line 45](file.ts#L45)
   - Click to view
   - [Quick fix](command:fix.sql.injection)

2. üü° **Performance**: O(n¬≤) algorithm at [line 78](file.ts#L78)

3. üü¢ **Style**: Missing JSDoc at [line 12](file.ts#L12)`);</code></pre>

          <h2>Performance</h2>
          
          <h3>Response Time</h3>
          <ul>
            <li><strong>< 100ms:</strong> Instant (simple lookups)</li>
            <li><strong>< 1s:</strong> Fast (most operations)</li>
            <li><strong>< 5s:</strong> Acceptable (complex analysis)</li>
            <li><strong>> 5s:</strong> Provide progress updates</li>
          </ul>

          <h3>Optimization Techniques</h3>
          <pre><code>// Cache expensive operations
const cache = new Map();

async function getProjectInfo(workspaceUri: string) {
  if (cache.has(workspaceUri)) {
    return cache.get(workspaceUri);
  }
  
  const info = await analyzeProject(workspaceUri);
  cache.set(workspaceUri, info);
  return info;
}

// Use streaming for large responses
for await (const chunk of response.text) {
  response.markdown(chunk);
}

// Implement timeouts
const timeout = 10000; // 10s
const result = await Promise.race([
  performAnalysis(),
  new Promise((_, reject) => 
    setTimeout(() => reject(new Error('Timeout')), timeout)
  )
]);</code></pre>

          <h2>Error Handling</h2>
          
          <h3>User-Friendly Errors</h3>
          <pre><code>try {
  const result = await performOperation();
  response.markdown(result);
} catch (error) {
  if (error.code === 'ENOENT') {
    response.markdown('‚ö†Ô∏è **File not found**

Make sure you have a file open and try again.');
  } else if (error.code === 'UNAUTHORIZED') {
    response.markdown('üîí **Authentication required**

Please sign in: [Sign In](command:signin)');
  } else {
    response.markdown(`‚ùå **Something went wrong**

${error.message}

Please try again or [report an issue](https://github.com/...)`);
  }
}</code></pre>

          <h2>Security</h2>
          
          <h3>Input Validation</h3>
          <pre><code>function validateInput(input: string): boolean {
  // Length check
  if (input.length > 10000) {
    throw new Error('Input too long');
  }
  
  // Pattern validation
  if (!/^[a-zA-Z0-9\s._-]+$/.test(input)) {
    throw new Error('Invalid characters');
  }
  
  return true;
}

// Sanitize file paths
function sanitizePath(path: string): string {
  // Prevent directory traversal
  if (path.includes('..')) {
    throw new Error('Invalid path');
  }
  return path;
}</code></pre>

          <h3>Secrets Management</h3>
          <pre><code>// Use VS Code secret storage
await context.secrets.store('api-key', apiKey);
const apiKey = await context.secrets.get('api-key');

// Never log secrets
console.log('API call with key:', '***');</code></pre>

          <h2>Testing</h2>
          
          <h3>Unit Tests</h3>
          <pre><code>import * as assert from 'assert';
import { parseCommand } from '../src/agent';

suite('Agent Tests', () => {
  test('Parse simple command', () => {
    const result = parseCommand('@myagent hello');
    assert.strictEqual(result.command, 'hello');
  });

  test('Parse command with args', () => {
    const result = parseCommand('@myagent /analyze file.ts --depth=2');
    assert.strictEqual(result.command, 'analyze');
    assert.strictEqual(result.args.depth, '2');
  });
});</code></pre>

          <h2>Documentation</h2>
          
          <h3>In-Agent Help</h3>
          <pre><code>if (request.prompt === 'help') {
  response.markdown(`# @myagent - Code Helper

## Commands
- \`/analyze [file]\` - Analyze code quality
- \`/fix [issue]\` - Suggest fixes
- \`/explain\` - Explain selected code

## Examples
\`\`\`
@myagent /analyze src/index.ts
@myagent /fix security-issues
@myagent /explain
\`\`\`

## Tips
- Select code before using /explain
- Use /analyze on large files for best results`);
}</code></pre>

          <h3>README</h3>
          <ul>
            <li>Clear description of what agent does</li>
            <li>Installation instructions</li>
            <li>Usage examples with screenshots</li>
            <li>List of commands and features</li>
            <li>Troubleshooting section</li>
          </ul>

          <h2>Maintenance</h2>
          
          <h3>Versioning</h3>
          <ul>
            <li>Use semantic versioning (1.2.3)</li>
            <li>Maintain changelog</li>
            <li>Communicate breaking changes</li>
            <li>Provide migration guides</li>
          </ul>

          <h3>Monitoring</h3>
          <pre><code>// Track usage metrics
const metrics = {
  totalRequests: 0,
  successfulResponses: 0,
  errors: 0,
  averageResponseTime: 0
};

// Log to monitoring service
await monitoring.track({
  event: 'agent_used',
  command: request.command,
  duration: responseDuration,
  success: !hadError
});</code></pre>

          <h2>Accessibility</h2>
          
          <h3>Screen Reader Support</h3>
          <ul>
            <li>Use semantic markdown</li>
            <li>Provide alt text for images</li>
            <li>Use descriptive link text</li>
            <li>Structure content with headings</li>
          </ul>

          <h2>Summary Checklist</h2>
          <ul>
            <li>‚òëÔ∏è Clear, focused purpose</li>
            <li>‚òëÔ∏è Good error handling</li>
            <li>‚òëÔ∏è Fast response times</li>
            <li>‚òëÔ∏è Comprehensive documentation</li>
            <li>‚òëÔ∏è Security best practices</li>
            <li>‚òëÔ∏è Thorough testing</li>
            <li>‚òëÔ∏è User feedback integration</li>
            <li>‚òëÔ∏è Accessibility considerations</li>
          </ul>
        </section>

        <!-- Use Cases Section -->
        <section id="use-cases" role="article">
          <h1>üíº Use Cases</h1>
          <span class="badge">examples</span>
          <span class="badge">scenarios</span>
          <span class="badge">applications</span>
          
          <p>GitHub Copilot agents can be tailored for countless scenarios. Here are proven use cases across different domains and team needs.</p>

          <div class="callout">
            <strong>üéØ Real-World Applications</strong><br />
            These use cases demonstrate how teams are leveraging custom agents to boost productivity and code quality.
          </div>

          <h2>Developer Productivity</h2>
          
          <h3>üí° Code Review Assistant</h3>
          <p><strong>Purpose:</strong> Automate code review checks and provide instant feedback</p>
          <ul>
            <li>Check code against team standards</li>
            <li>Flag security vulnerabilities</li>
            <li>Suggest performance improvements</li>
            <li>Verify test coverage</li>
          </ul>
          <pre><code>@code-reviewer analyze PR #123
# Reviews: security, performance, style, test coverage
# Provides: Issues list, suggestions, approval recommendation</code></pre>

          <h3>üõ†Ô∏è Refactoring Helper</h3>
          <p><strong>Purpose:</strong> Assist with code modernization and refactoring</p>
          <ul>
            <li>Convert class components to hooks (React)</li>
            <li>Migrate to async/await</li>
            <li>Update deprecated API usage</li>
            <li>Extract reusable functions</li>
          </ul>
          <pre><code>@refactor convert this class to functional component
@refactor extract common logic into utils
@refactor update deprecated APIs in /src</code></pre>

          <h3>üìù Documentation Generator</h3>
          <p><strong>Purpose:</strong> Create and maintain documentation automatically</p>
          <ul>
            <li>Generate JSDoc/TSDoc comments</li>
            <li>Create README files</li>
            <li>Build API documentation</li>
            <li>Update changelog</li>
          </ul>
          <pre><code>@docs generate README for this project
@docs add JSDoc for all public functions
@docs create API documentation</code></pre>

          <h2>Domain-Specific Agents</h2>
          
          <h3>üîí Security Auditor</h3>
          <p><strong>Purpose:</strong> Identify security issues proactively</p>
          <ul>
            <li>Scan for SQL injection risks</li>
            <li>Check for XSS vulnerabilities</li>
            <li>Verify authentication/authorization</li>
            <li>Audit dependencies for CVEs</li>
            <li>Ensure secrets aren't exposed</li>
          </ul>
          <pre><code>@security audit authentication flow
@security check for SQL injection
@security scan dependencies</code></pre>

          <h3>üöÄ DevOps Assistant</h3>
          <p><strong>Purpose:</strong> Help with CI/CD and infrastructure</p>
          <ul>
            <li>Generate GitHub Actions workflows</li>
            <li>Create Dockerfile and docker-compose</li>
            <li>Build Kubernetes manifests</li>
            <li>Write Terraform configurations</li>
          </ul>
          <pre><code>@devops create deployment pipeline
@devops generate Dockerfile for Node.js app
@devops create k8s deployment for microservice</code></pre>

          <h3>üìä Data Science Helper</h3>
          <p><strong>Purpose:</strong> Assist with data analysis and ML</p>
          <ul>
            <li>Suggest data transformations</li>
            <li>Generate visualization code</li>
            <li>Create model training pipelines</li>
            <li>Help with feature engineering</li>
          </ul>
          <pre><code>@datascience analyze this dataset
@datascience create visualization for trends
@datascience build classification model</code></pre>

          <h2>Team Collaboration</h2>
          
          <h3>üìö Onboarding Buddy</h3>
          <p><strong>Purpose:</strong> Help new team members get up to speed</p>
          <ul>
            <li>Explain codebase architecture</li>
            <li>Point to relevant documentation</li>
            <li>Guide through setup process</li>
            <li>Answer common questions</li>
          </ul>
          <pre><code>@onboarding explain user authentication flow
@onboarding how do I set up local environment?
@onboarding where is the API documentation?</code></pre>

          <h3>üìÑ Standards Enforcer</h3>
          <p><strong>Purpose:</strong> Ensure team conventions are followed</p>
          <ul>
            <li>Check naming conventions</li>
            <li>Verify file organization</li>
            <li>Enforce code style</li>
            <li>Validate commit messages</li>
          </ul>
          <pre><code>@standards check naming in this module
@standards verify project structure
@standards validate commit message format</code></pre>

          <h2>Specialized Tasks</h2>
          
          <h3>üåê i18n Helper</h3>
          <p><strong>Purpose:</strong> Assist with internationalization</p>
          <ul>
            <li>Extract hardcoded strings</li>
            <li>Generate translation files</li>
            <li>Suggest locale-appropriate formatting</li>
            <li>Check for missing translations</li>
          </ul>

          <h3>‚ôø Accessibility Checker</h3>
          <p><strong>Purpose:</strong> Ensure WCAG compliance</p>
          <ul>
            <li>Check ARIA attributes</li>
            <li>Verify keyboard navigation</li>
            <li>Validate color contrast</li>
            <li>Suggest alt text for images</li>
          </ul>

          <h3>üß™ Test Generator</h3>
          <p><strong>Purpose:</strong> Create comprehensive test suites</p>
          <ul>
            <li>Generate unit tests</li>
            <li>Create integration tests</li>
            <li>Build E2E test scenarios</li>
            <li>Suggest edge cases</li>
          </ul>
          <pre><code>@test create unit tests for UserService
@test generate E2E tests for checkout flow
@test suggest edge cases for this function</code></pre>

          <h2>Industry-Specific</h2>
          
          <h3>üè¶ Financial Services</h3>
          <ul>
            <li>Compliance checking (PCI-DSS, SOX)</li>
            <li>Audit trail generation</li>
            <li>Calculation verification</li>
            <li>Regulatory reporting</li>
          </ul>

          <h3>üè• Healthcare</h3>
          <ul>
            <li>HIPAA compliance validation</li>
            <li>PHI detection and masking</li>
            <li>HL7/FHIR integration help</li>
            <li>Audit logging verification</li>
          </ul>

          <h3>üõçÔ∏è E-Commerce</h3>
          <ul>
            <li>Cart and checkout optimization</li>
            <li>Payment integration help</li>
            <li>Inventory management logic</li>
            <li>Performance optimization</li>
          </ul>

          <h2>Example: Complete Agent</h2>
          
          <h3>API Development Assistant</h3>
          <pre><code>// @api-helper - Full-featured API development agent

Commands:
  /create endpoint    - Generate REST endpoint with boilerplate
  /validate schema    - Validate OpenAPI schema
  /test               - Generate API tests
  /secure             - Security analysis
  /document           - Generate API docs

Features:
  - OpenAPI spec generation
  - Authentication/authorization patterns
  - Rate limiting configuration
  - Error handling templates
  - Versioning guidance
  - Database integration
  - Caching strategies

Example Usage:
@api-helper /create endpoint POST /users
# Generates: route, controller, service, model, validation, tests

@api-helper /secure check authentication
# Analyzes: JWT handling, token validation, permission checks

@api-helper /document generate OpenAPI spec
# Creates: Complete OpenAPI 3.0 specification</code></pre>

          <h2>Measurable Benefits</h2>
          
          <table class="table table-striped">
            <thead>
              <tr>
                <th>Use Case</th>
                <th>Time Saved</th>
                <th>Quality Impact</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Code Review</td>
                <td>30-50% faster reviews</td>
                <td>Consistent standards, fewer bugs</td>
              </tr>
              <tr>
                <td>Documentation</td>
                <td>60-80% time reduction</td>
                <td>Up-to-date, comprehensive docs</td>
              </tr>
              <tr>
                <td>Testing</td>
                <td>40-60% faster test creation</td>
                <td>Better coverage, edge cases</td>
              </tr>
              <tr>
                <td>Refactoring</td>
                <td>50-70% faster</td>
                <td>Fewer regressions</td>
              </tr>
              <tr>
                <td>Onboarding</td>
                <td>Weeks to days</td>
                <td>Faster productivity</td>
              </tr>
            </tbody>
          </table>

          <h2>Building Your Use Case</h2>
          
          <h3>Identify Pain Points</h3>
          <ul>
            <li>What repetitive tasks slow your team?</li>
            <li>What knowledge is hard to find/share?</li>
            <li>What errors happen frequently?</li>
            <li>What standards are hard to enforce?</li>
          </ul>

          <h3>Start Small</h3>
          <ul>
            <li>Pick one specific problem</li>
            <li>Build minimum viable agent</li>
            <li>Get team feedback</li>
            <li>Iterate and expand</li>
          </ul>
        </section>

        <!-- Practical Example Section -->
        <section id="practical-example-todo-app" role="article">
          <h1>üéØ Practical Example: Full-Stack Orchestrator with TODO App Demo</h1>
          <span class="badge">practical</span>
          <span class="badge">orchestrator</span>
          <span class="badge">example</span>
          <span class="badge">.github/agents</span>
          
          <p>This section demonstrates building a <strong>generic Full-Stack Orchestrator Agent</strong> that can build any feature using .NET 10 backend and React.js frontend, with TODO application as a practical demo. The orchestrator coordinates multiple specialized subagents, all defined as markdown files (.md) in the .github/agents folder, enabling a simple, declarative approach to agent development.</p>

          <div class="callout">
            <strong>üéì Learning Objectives</strong><br />
            Learn how to create a <strong>generic orchestrator</strong> that accepts user prompts for any feature while maintaining consistent technology choices (.NET 10 + React.js). Understand how to use the <code>user-invokable</code> property to control agent visibility, leverage Instructions and Prompt files for consistency, and coordinate planning, design, coding, review, testing, security, and infrastructure subagents.
          </div>

          <h2>Project Overview</h2>
          
          <h3>Orchestrator Capabilities</h3>
          <ul>
            <li><strong>Generic Feature Development:</strong> Accepts user prompts to build any full-stack feature</li>
            <li><strong>Consistent Technology Stack:</strong> Always uses .NET 10 backend + React.js frontend</li>
            <li><strong>Specialized Instructions:</strong> Applies coding standards, security policies, and best practices</li>
            <li><strong>Reusable Prompts:</strong> Uses prompt files for consistent feature generation</li>
            <li><strong>Multi-Agent Coordination:</strong> Orchestrates 7 specialized subagents through the complete SDLC</li>
          </ul>

          <h3>Technology Stack (Pre-Configured)</h3>
          <div class="callout">
            <strong>üèóÔ∏è Fixed Architecture Choices</strong><br />
            The orchestrator always uses these technologies regardless of the feature being built:
            <ul style="margin-bottom: 0; margin-top: 8px;">
              <li><strong>Backend:</strong> .NET 10, ASP.NET Core Web API, Entity Framework Core, SQL Server/PostgreSQL</li>
              <li><strong>Frontend:</strong> React 18+, TypeScript 5+, Redux Toolkit/Zustand, Material-UI/Tailwind CSS</li>
              <li><strong>API:</strong> RESTful with Swagger/OpenAPI documentation</li>
              <li><strong>Auth:</strong> ASP.NET Core Identity + JWT tokens</li>
              <li><strong>Testing:</strong> xUnit (backend), Jest + React Testing Library (frontend)</li>
              <li><strong>DevOps:</strong> Docker containerization, GitHub Actions CI/CD</li>
            </ul>
          </div>

          <h3>Demo: TODO Application Requirements</h3>
          <p>We'll demonstrate the orchestrator by building a full-stack TODO application with these requirements:</p>
          <ul>
            <li>User authentication and authorization (ASP.NET Core Identity)</li>
            <li>CRUD operations for tasks with Entity Framework Core</li>
            <li>Task management: categories, tags, priorities, due dates</li>
            <li>RESTful API with Swagger/OpenAPI documentation</li>
            <li>React UI with Material-UI components</li>
            <li>Unit and integration tests (xUnit for .NET, Jest for React)</li>
            <li>Security best practices (JWT tokens, HTTPS, CORS)</li>
            <li>Docker containerization and CI/CD pipeline</li>
          </ul>

          <h3>Orchestrator Architecture</h3>
          
          <div class="mermaid">
%%{ init: { "theme": "base", "fontFamily": "Segoe UI Semibold", "fontSize": "18px" }}%%
graph TB
    User[üë§ Developer] -->|Request| Orch[üéØ Orchestrator Agent]
    
    Orch -->|1. Plan| Plan[üìã Planning Agent]
    Orch -->|2. Design| Design[üé® Design Agent]
    Orch -->|3. Code| Code[üíª Coding Agent]
    Orch -->|4. Review| Review[üëÄ Review Agent]
    Orch -->|5. Test| Test[üß™ Testing Agent]
    Orch -->|6. Secure| Sec[üîê Security Agent]
    Orch -->|7. Deploy| Infra[üèóÔ∏è Infrastructure Agent]
    
    Plan -->|Architecture| Orch
    Design -->|Models & APIs| Orch
    Code -->|Implementation| Orch
    Review -->|Feedback| Orch
    Test -->|Test Results| Orch
    Sec -->|Security Report| Orch
    Infra -->|Deployment Config| Orch
    
    Orch -->|Integrated Solution| User
    
    style Orch fill:#0078d4,color:#fff
    style Plan fill:#10a37f,color:#fff
    style Design fill:#10a37f,color:#fff
    style Code fill:#10a37f,color:#fff
    style Review fill:#10a37f,color:#fff
    style Test fill:#10a37f,color:#fff
    style Sec fill:#10a37f,color:#fff
    style Infra fill:#10a37f,color:#fff
          </div>

          <h2>Setting Up .github/agents Folder</h2>
          
          <h3>Complete Folder Structure</h3>
          <pre><code>.github/
‚îú‚îÄ‚îÄ agents/
‚îÇ   ‚îú‚îÄ‚îÄ orchestrator.md             # Main orchestrator (user-invokable: true)
‚îÇ   ‚îú‚îÄ‚îÄ planning.md                 # Planning subagent (user-invokable: false)
‚îÇ   ‚îú‚îÄ‚îÄ design.md                   # Design subagent (user-invokable: false)
‚îÇ   ‚îú‚îÄ‚îÄ coding.md                   # Coding subagent (user-invokable: false)
‚îÇ   ‚îú‚îÄ‚îÄ review.md                   # Code review subagent (user-invokable: false)
‚îÇ   ‚îú‚îÄ‚îÄ testing.md                  # Testing subagent (user-invokable: false)
‚îÇ   ‚îú‚îÄ‚îÄ security.md                 # Security subagent (user-invokable: false)
‚îÇ   ‚îî‚îÄ‚îÄ infrastructure.md           # Infrastructure subagent (user-invokable: false)
‚îú‚îÄ‚îÄ instructions/
‚îÇ   ‚îú‚îÄ‚îÄ fullstack-standards.md      # Global full-stack development standards
‚îÇ   ‚îú‚îÄ‚îÄ dotnet-standards.md         # .NET coding standards
‚îÇ   ‚îî‚îÄ‚îÄ react-standards.md          # React/TypeScript coding standards
‚îú‚îÄ‚îÄ prompts/
‚îÇ   ‚îú‚îÄ‚îÄ feature-template.md         # Generic feature generation prompt
‚îÇ   ‚îú‚îÄ‚îÄ crud-api.md                 # CRUD endpoint generation prompt
‚îÇ   ‚îú‚îÄ‚îÄ react-component.md          # React component generation prompt
‚îÇ   ‚îî‚îÄ‚îÄ testing-template.md         # Test generation prompt
‚îî‚îÄ‚îÄ copilot-instructions.md         # Optional: Global workspace instructions (applies to ALL agents)</code></pre>

          <div class="callout">
            <strong>üí° Key Concept: user-invokable Property</strong><br />
            <ul style="margin-bottom: 0;">
              <li><strong>user-invokable: true</strong> - Agent can be directly invoked by users in chat (e.g., @orchestrator)</li>
              <li><strong>user-invokable: false</strong> - Agent can only be invoked by other agents, not directly by users</li>
              <li>This provides better separation and controlled delegation in multi-agent systems</li>
            </ul>
          </div>

          <h2>Model Selection for Agents</h2>

          <p>
            Each agent can specify which AI model to use via the <code>model</code> property in frontmatter.
            Choose models based on the agent's task complexity, reasoning requirements, and cost considerations.
          </p>

          <h3>Recommended Models by Agent Type</h3>

          <table class="table table-striped">
            <thead>
              <tr>
                <th>Agent Type</th>
                <th>Recommended Model</th>
                <th>Reasoning</th>
                <th>Example</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Orchestrator</strong></td>
                <td>claude-sonnet-4.5</td>
                <td>Needs advanced reasoning to coordinate multiple agents, parse complex requirements, and manage workflow</td>
                <td>orchestrator.md</td>
              </tr>
              <tr>
                <td><strong>Planning</strong></td>
                <td>claude-sonnet-4.5</td>
                <td>Requires deep architectural thinking, requirement analysis, and strategic planning</td>
                <td>planning.md</td>
              </tr>
              <tr>
                <td><strong>Design</strong></td>
                <td>gpt-4o</td>
                <td>Good balance of design expertise and cost; handles data modeling and API design well</td>
                <td>design.md</td>
              </tr>
              <tr>
                <td><strong>Coding</strong></td>
                <td>claude-sonnet-4.5</td>
                <td>Superior code generation, understands complex patterns, produces cleaner code</td>
                <td>coding.md</td>
              </tr>
              <tr>
                <td><strong>Review</strong></td>
                <td>gpt-4.5-turbo</td>
                <td>Excellent at pattern recognition, finding bugs, and code analysis; cost-effective for reviews</td>
                <td>review.md</td>
              </tr>
              <tr>
                <td><strong>Testing</strong></td>
                <td>gpt-4o-mini</td>
                <td>Fast and cost-effective for generating repetitive test cases; good edge case coverage</td>
                <td>testing.md</td>
              </tr>
              <tr>
                <td><strong>Security</strong></td>
                <td>claude-sonnet-4.5</td>
                <td>Deep reasoning needed for vulnerability analysis and security threat modeling</td>
                <td>security.md</td>
              </tr>
              <tr>
                <td><strong>Infrastructure</strong></td>
                <td>gpt-4o</td>
                <td>Good at templating and configuration; handles Docker, CI/CD, and IaC effectively</td>
                <td>infrastructure.md</td>
              </tr>
            </tbody>
          </table>

          <h3>Available Models (Examples)</h3>

          <div class="callout">
            <strong>ü§ñ Model Options</strong><br />
            <ul style="margin-bottom: 0;">
              <li><code>claude-sonnet-4.5</code> - Best for complex reasoning, code generation, orchestration</li>
              <li><code>gpt-4.5-turbo</code> - Fast, cost-effective, good for analysis and reviews</li>
              <li><code>gpt-4o</code> - Balanced performance and cost, versatile for most tasks</li>
              <li><code>gpt-4o-mini</code> - Fastest and cheapest, ideal for simple/repetitive tasks</li>
              <li><code>o1-preview</code> - Advanced reasoning model for complex problem-solving</li>
              <li><code>o1-mini</code> - Reasoning model optimized for speed</li>
            </ul>
            <p style="margin-top: 8px; margin-bottom: 0;"><strong>Note:</strong> Model availability depends on your GitHub Copilot subscription and organization settings.</p>
          </div>

          <h3>Model Selection Strategy</h3>

          <pre><code># High-Value, Complex Tasks ‚Üí Premium Models
Orchestrator:  claude-sonnet-4.5  # Coordinates everything
Planning:      claude-sonnet-4.5  # Strategic thinking
Coding:        claude-sonnet-4.5  # Code quality critical
Security:      claude-sonnet-4.5  # Security is non-negotiable

# Balanced Tasks ‚Üí Mid-Tier Models
Design:        gpt-4o             # Good balance
Review:        gpt-4.5-turbo      # Fast analysis
Infrastructure: gpt-4o            # Config generation

# Repetitive/Simple Tasks ‚Üí Cost-Effective Models
Testing:       gpt-4o-mini        # Generate test cases
Documentation: gpt-4o-mini        # Write docs</code></pre>

          <div class="callout" style="background-color: #fff3cd; border-color: #ffc107;">
            <strong>üí° Pro Tip: Model Fallback</strong><br />
            <p style="margin-bottom: 0;">If a specified model is unavailable, GitHub Copilot will fall back to the default model for your organization. Always test your agents to ensure they work with available models.</p>
          </div>

          <h2>Global Instructions for Consistency</h2>

          <div class="callout">
            <strong>üìÅ Folder Naming Convention</strong><br />
            <ul style="margin-bottom: 0;">
              <li><strong>.github/instructions/</strong> - Standard folder for instruction files referenced by agents</li>
              <li><strong>.github/copilot-instructions.md</strong> - Optional single file for global workspace instructions</li>
              <li><strong>.github/prompts/</strong> - Reusable prompt templates</li>
              <li>Agents reference instruction files via the <code>instructions</code> property in their frontmatter</li>
            </ul>
          </div>

          <h3>Master Instructions (.github/instructions/fullstack-standards.md)</h3>
          <pre><code>---
applyTo: '**'
priority: high
---

# Global Development Instructions

These instructions apply to all agents and ensure consistency across the full-stack development process.

## Technology Stack (Mandatory)

### Backend: .NET 10
- Use ASP.NET Core 10.0 Web API
- Entity Framework Core 10.0 for data access
- ASP.NET Core Identity for authentication
- FluentValidation for input validation
- Serilog for structured logging
- xUnit for testing

### Frontend: React 18+
- React 18+ with TypeScript 5+
- Redux Toolkit for state management
- Material-UI (MUI) or Tailwind CSS for styling
- Axios for HTTP requests
- React Hook Form for forms
- Jest + React Testing Library for testing

### Database
- SQL Server 2022 or PostgreSQL 16
- EF Core Code-First migrations
- Repository pattern for data access

## Coding Standards

### .NET Standards
- Use Clean Architecture (3-layer: API, Business, Data)
- Apply async/await for all I/O operations
- Use record types for DTOs (immutable)
- Follow naming conventions: PascalCase for public members
- Use nullable reference types (enable in .csproj)
- Apply [ApiController] and route attributes
- Use dependency injection via IServiceCollection
- Return appropriate HTTP status codes (200, 201, 400, 401, 404, 500)

### React/TypeScript Standards
- Use functional components with hooks
- Define TypeScript interfaces for all props
- Use const for all variables unless reassignment needed
- Apply proper typing (avoid `any`)
- Use arrow functions for consistency
- Implement error boundaries
- Follow React best practices (keys in lists, avoid inline functions in JSX)
- Use custom hooks for reusable logic

### Security Requirements
- NEVER commit secrets, API keys, or passwords
- Use environment variables for configuration
- Apply [Authorize] attribute to protected endpoints
- Validate all user input (backend + frontend)
- Use parameterized queries (never string concatenation)
- Configure CORS properly (specific origins only)
- Enable HTTPS in production
- Hash passwords with ASP.NET Core Identity
- Use JWT with proper expiration (15-60 mins)

### Testing Requirements
- Aim for 80%+ code coverage
- Test all business logic
- Mock external dependencies
- Test both success and error paths
- Use meaningful test names (describe what's being tested)
- Follow AAA pattern (Arrange, Act, Assert)

## File Organization

### .NET Project Structure
```
src/
‚îú‚îÄ‚îÄ API/                    # ASP.NET Core Web API
‚îÇ   ‚îú‚îÄ‚îÄ Controllers/
‚îÇ   ‚îú‚îÄ‚îÄ DTOs/
‚îÇ   ‚îú‚îÄ‚îÄ Middleware/
‚îÇ   ‚îî‚îÄ‚îÄ Program.cs
‚îú‚îÄ‚îÄ Business/               # Business Logic
‚îÇ   ‚îú‚îÄ‚îÄ Services/
‚îÇ   ‚îú‚îÄ‚îÄ Interfaces/
‚îÇ   ‚îî‚îÄ‚îÄ Models/
‚îî‚îÄ‚îÄ Data/                   # Data Access
    ‚îú‚îÄ‚îÄ Repositories/
    ‚îú‚îÄ‚îÄ Entities/
    ‚îú‚îÄ‚îÄ DbContext/
    ‚îî‚îÄ‚îÄ Migrations/
```

### React Project Structure
```
src/
‚îú‚îÄ‚îÄ components/             # Reusable UI components
‚îú‚îÄ‚îÄ pages/                  # Page-level components
‚îú‚îÄ‚îÄ features/               # Feature-specific components
‚îú‚îÄ‚îÄ hooks/                  # Custom hooks
‚îú‚îÄ‚îÄ services/               # API services
‚îú‚îÄ‚îÄ store/                  # Redux slices
‚îú‚îÄ‚îÄ types/                  # TypeScript interfaces
‚îî‚îÄ‚îÄ utils/                  # Utility functions
```

## API Design Principles

1. Use RESTful conventions (GET, POST, PUT, DELETE)
2. Version APIs in URL (/api/v1/...)
3. Return consistent response format
4. Include OpenAPI/Swagger documentation
5. Use plural resource names (/api/tasks, not /api/task)
6. Return 201 Created for POST with Location header
7. Return 204 No Content for successful DELETE
8. Return 400 Bad Request for validation errors

## Error Handling

### Backend
- Use global exception handling middleware
- Return ProblemDetails format for errors
- Log all exceptions with context
- Never expose stack traces to clients
- Return appropriate HTTP status codes

### Frontend
- Use error boundaries for component errors
- Display user-friendly error messages
- Log errors to console (dev) or monitoring service (prod)
- Show loading and error states in UI
- Retry failed requests when appropriate

## Performance Guidelines

- Use async/await for all I/O operations
- Implement pagination for list endpoints (default page size: 20)
- Add database indexes for frequently queried fields
- Use EF Core .AsNoTracking() for read-only queries
- Implement client-side caching where appropriate
- Lazy load images and components
- Use React.memo for expensive components

## Documentation Requirements

- Add XML comments to all public APIs
- Document complex algorithms
- Include usage examples for components
- Maintain README.md with setup instructions
- Document environment variables
- Provide API examples in Swagger</code></pre>

          <h3>.NET Coding Standards (.github/instructions/dotnet-standards.md)</h3>
          <pre><code>---
applyTo: '**/*.cs'
priority: high
---

# .NET 10 Coding Standards

## Controller Best Practices

### Always Apply These Attributes
```csharp
[ApiController]
[Route("api/[controller]")]
[Authorize]  // On protected controllers
public class TasksController : ControllerBase
```

### Action Method Patterns
```csharp
// GET /api/tasks
[HttpGet]
[ProducesResponseType(typeof(IEnumerable<TaskDto>), StatusCodes.Status200OK)]
public async Task<ActionResult<IEnumerable<TaskDto>>> GetTasks()

// GET /api/tasks/{id}
[HttpGet("{id}")]
[ProducesResponseType(typeof(TaskDto), StatusCodes.Status200OK)]
[ProducesResponseType(StatusCodes.Status404NotFound)]
public async Task<ActionResult<TaskDto>> GetTask(Guid id)

// POST /api/tasks
[HttpPost]
[ProducesResponseType(typeof(TaskDto), StatusCodes.Status201Created)]
[ProducesResponseType(StatusCodes.Status400BadRequest)]
public async Task<ActionResult<TaskDto>> CreateTask(CreateTaskRequest request)
{
    if (!ModelState.IsValid)
        return BadRequest(ModelState);
    
    var task = await _taskService.CreateAsync(request);
    return CreatedAtAction(nameof(GetTask), new { id = task.Id }, task);
}

// PUT /api/tasks/{id}
[HttpPut("{id}")]
[ProducesResponseType(typeof(TaskDto), StatusCodes.Status200OK)]
[ProducesResponseType(StatusCodes.Status404NotFound)]
public async Task<ActionResult<TaskDto>> UpdateTask(Guid id, UpdateTaskRequest request)

// DELETE /api/tasks/{id}
[HttpDelete("{id}")]
[ProducesResponseType(StatusCodes.Status204NoContent)]
[ProducesResponseType(StatusCodes.Status404NotFound)]
public async Task<IActionResult> DeleteTask(Guid id)
{
    await _taskService.DeleteAsync(id);
    return NoContent();
}
```

## Entity Framework Patterns

### DbContext Configuration
```csharp
public class ApplicationDbContext : DbContext
{
    public DbSet<TodoTask> Tasks { get; set; }
    public DbSet<Category> Categories { get; set; }
    
    protected override void OnModelCreating(ModelBuilder modelBuilder)
    {
        // Configure relationships
        modelBuilder.Entity<TodoTask>()
            .HasOne(t => t.User)
            .WithMany(u => u.Tasks)
            .HasForeignKey(t => t.UserId)
            .OnDelete(DeleteBehavior.Cascade);
        
        // Configure indexes
        modelBuilder.Entity<TodoTask>()
            .HasIndex(t => t.UserId);
        
        // Configure constraints
        modelBuilder.Entity<TodoTask>()
            .Property(t => t.Title)
            .IsRequired()
            .HasMaxLength(200);
    }
}
```

### Repository Pattern
```csharp
public interface IRepository<T> where T : class
{
    Task<T?> GetByIdAsync(Guid id);
    Task<IEnumerable<T>> GetAllAsync();
    Task<T> AddAsync(T entity);
    Task UpdateAsync(T entity);
    Task DeleteAsync(Guid id);
}

public class Repository<T> : IRepository<T> where T : class
{
    private readonly ApplicationDbContext _context;
    private readonly DbSet<T> _dbSet;
    
    public Repository(ApplicationDbContext context)
    {
        _context = context;
        _dbSet = context.Set<T>();
    }
    
    public async Task<T?> GetByIdAsync(Guid id)
    {
        return await _dbSet.FindAsync(id);
    }
    
    public async Task<IEnumerable<T>> GetAllAsync()
    {
        return await _dbSet.AsNoTracking().ToListAsync();
    }
    
    public async Task<T> AddAsync(T entity)
    {
        await _dbSet.AddAsync(entity);
        await _context.SaveChangesAsync();
        return entity;
    }
    
    public async Task UpdateAsync(T entity)
    {
        _context.Entry(entity).State = EntityState.Modified;
        await _context.SaveChangesAsync();
    }
    
    public async Task DeleteAsync(Guid id)
    {
        var entity = await GetByIdAsync(id);
        if (entity != null)
        {
            _dbSet.Remove(entity);
            await _context.SaveChangesAsync();
        }
    }
}
```

## DTO Patterns (Use Record Types)

```csharp
// Request DTOs
public record CreateTaskRequest(
    [Required, MaxLength(200)] string Title,
    [MaxLength(2000)] string? Description,
    DateTime? DueDate,
    Priority Priority,
    Guid? CategoryId
);

public record UpdateTaskRequest(
    [Required, MaxLength(200)] string Title,
    [MaxLength(2000)] string? Description,
    DateTime? DueDate,
    Priority Priority,
    Guid? CategoryId,
    bool IsCompleted
);

// Response DTOs
public record TaskDto(
    Guid Id,
    string Title,
    string? Description,
    bool IsCompleted,
    DateTime? DueDate,
    Priority Priority,
    DateTime CreatedAt,
    CategoryDto? Category
);

public record CategoryDto(
    Guid Id,
    string Name,
    string Color
);
```

## Service Layer Pattern

```csharp
public interface ITaskService
{
    Task<IEnumerable<TaskDto>> GetUserTasksAsync(Guid userId);
    Task<TaskDto?> GetTaskAsync(Guid id, Guid userId);
    Task<TaskDto> CreateTaskAsync(Guid userId, CreateTaskRequest request);
    Task<TaskDto> UpdateTaskAsync(Guid id, Guid userId, UpdateTaskRequest request);
    Task DeleteTaskAsync(Guid id, Guid userId);
}

public class TaskService : ITaskService
{
    private readonly IRepository<TodoTask> _taskRepository;
    private readonly IMapper _mapper;
    private readonly ILogger<TaskService> _logger;
    
    public TaskService(
        IRepository<TodoTask> taskRepository,
        IMapper mapper,
        ILogger<TaskService> logger)
    {
        _taskRepository = taskRepository;
        _mapper = mapper;
        _logger = logger;
    }
    
    public async Task<IEnumerable<TaskDto>> GetUserTasksAsync(Guid userId)
    {
        var tasks = await _taskRepository
            .GetAllAsync()
            .Where(t => t.UserId == userId)
            .Include(t => t.Category)
            .ToListAsync();
        
        return _mapper.Map<IEnumerable<TaskDto>>(tasks);
    }
    
    // Implement other methods...
}
```

## Dependency Injection Registration

```csharp
// Program.cs
builder.Services.AddDbContext<ApplicationDbContext>(options =>
    options.UseSqlServer(builder.Configuration.GetConnectionString("DefaultConnection")));

builder.Services.AddScoped(typeof(IRepository<>), typeof(Repository<>));
builder.Services.AddScoped<ITaskService, TaskService>();
builder.Services.AddScoped<ICategoryService, CategoryService>();

builder.Services.AddAutoMapper(typeof(Program));

builder.Services.AddAuthentication(JwtBearerDefaults.AuthenticationScheme)
    .AddJwtBearer(options => { /* JWT config */ });

builder.Services.AddCors(options =>
{
    options.AddPolicy("AllowReactApp", policy =>
    {
        policy.WithOrigins(builder.Configuration["CorsOrigins"]!)
              .AllowAnyMethod()
              .AllowAnyHeader()
              .AllowCredentials();
    });
});
```</code></pre>

          <h3>React/TypeScript Standards (.github/instructions/react-standards.md)</h3>
          <pre><code>---
applyTo: '**/*.{ts,tsx}'
priority: high
---

# React + TypeScript Coding Standards

## Component Patterns

### Functional Component with TypeScript
```typescript
import React, { useState, useCallback } from 'react';

interface TaskCardProps {
  task: Task;
  onUpdate: (task: Task) => void;
  onDelete: (id: string) => void;
}

export const TaskCard: React.FC<TaskCardProps> = ({ 
  task, 
  onUpdate, 
  onDelete 
}) => {
  const [isEditing, setIsEditing] = useState(false);

  const handleComplete = useCallback(() => {
    onUpdate({ ...task, isCompleted: !task.isCompleted });
  }, [task, onUpdate]);

  const handleDelete = useCallback(() => {
    onDelete(task.id);
  }, [task.id, onDelete]);

  return (
    <div className="task-card">
      {/* Component JSX */}
    </div>
  );
};
```

## TypeScript Interfaces

### Type Definitions (types/index.ts)
```typescript
export interface Task {
  id: string;
  title: string;
  description?: string;
  isCompleted: boolean;
  dueDate: Date | null;
  priority: Priority;
  categoryId?: string;
  category?: Category;
  tags: Tag[];
  createdAt: Date;
}

export interface Category {
  id: string;
  name: string;
  color: string;
}

export interface Tag {
  id: string;
  name: string;
}

export type Priority = 'low' | 'medium' | 'high' | 'urgent';

export interface CreateTaskRequest {
  title: string;
  description?: string;
  dueDate?: Date;
  priority: Priority;
  categoryId?: string;
}

export interface UpdateTaskRequest extends CreateTaskRequest {
  isCompleted: boolean;
}

export interface ApiResponse<T> {
  data: T;
  success: boolean;
  message?: string;
}

export interface PaginatedResponse<T> {
  data: T[];
  page: number;
  pageSize: number;
  totalCount: number;
  totalPages: number;
}
```

## Redux Toolkit Patterns

### Slice Definition (store/taskSlice.ts)
```typescript
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import { taskService } from '../services/taskService';
import type { Task, CreateTaskRequest } from '../types';

interface TaskState {
  tasks: Task[];
  selectedTask: Task | null;
  isLoading: boolean;
  error: string | null;
}

const initialState: TaskState = {
  tasks: [],
  selectedTask: null,
  isLoading: false,
  error: null,
};

export const fetchTasks = createAsyncThunk(
  'tasks/fetchTasks',
  async (_, { rejectWithValue }) => {
    try {
      const response = await taskService.getTasks();
      return response.data;
    } catch (error: any) {
      return rejectWithValue(error.response?.data || 'Failed to fetch tasks');
    }
  }
);

export const createTask = createAsyncThunk(
  'tasks/createTask',
  async (request: CreateTaskRequest, { rejectWithValue }) => {
    try {
      const response = await taskService.createTask(request);
      return response.data;
    } catch (error: any) {
      return rejectWithValue(error.response?.data || 'Failed to create task');
    }
  }
);

const taskSlice = createSlice({
  name: 'tasks',
  initialState,
  reducers: {
    selectTask: (state, action: PayloadAction<Task | null>) => {
      state.selectedTask = action.payload;
    },
    clearError: (state) => {
      state.error = null;
    },
  },
  extraReducers: (builder) => {
    builder
      .addCase(fetchTasks.pending, (state) => {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(fetchTasks.fulfilled, (state, action) => {
        state.isLoading = false;
        state.tasks = action.payload;
      })
      .addCase(fetchTasks.rejected, (state, action) => {
        state.isLoading = false;
        state.error = action.payload as string;
      })
      .addCase(createTask.fulfilled, (state, action) => {
        state.tasks.push(action.payload);
      });
  },
});

export const { selectTask, clearError } = taskSlice.actions;
export default taskSlice.reducer;
```

## API Service Pattern

### API Client (services/apiClient.ts)
```typescript
import axios, { AxiosInstance, AxiosRequestConfig } from 'axios';

class ApiClient {
  private client: AxiosInstance;

  constructor() {
    this.client = axios.create({
      baseURL: import.meta.env.VITE_API_URL || 'http://localhost:5000/api',
      timeout: 10000,
      headers: {
        'Content-Type': 'application/json',
      },
    });

    // Request interceptor for auth token
    this.client.interceptors.request.use(
      (config) => {
        const token = localStorage.getItem('accessToken');
        if (token) {
          config.headers.Authorization = `Bearer ${token}`;
        }
        return config;
      },
      (error) => Promise.reject(error)
    );

    // Response interceptor for error handling
    this.client.interceptors.response.use(
      (response) => response,
      async (error) => {
        if (error.response?.status === 401) {
          // Handle token refresh or redirect to login
          localStorage.removeItem('accessToken');
          window.location.href = '/login';
        }
        return Promise.reject(error);
      }
    );
  }

  async get<T>(url: string, config?: AxiosRequestConfig) {
    return this.client.get<T>(url, config);
  }

  async post<T>(url: string, data?: any, config?: AxiosRequestConfig) {
    return this.client.post<T>(url, data, config);
  }

  async put<T>(url: string, data?: any, config?: AxiosRequestConfig) {
    return this.client.put<T>(url, data, config);
  }

  async delete<T>(url: string, config?: AxiosRequestConfig) {
    return this.client.delete<T>(url, config);
  }
}

export const apiClient = new ApiClient();
```

### Task Service (services/taskService.ts)
```typescript
import { apiClient } from './apiClient';
import type { Task, CreateTaskRequest, UpdateTaskRequest, ApiResponse } from '../types';

class TaskService {
  private baseUrl = '/tasks';

  async getTasks(): Promise<ApiResponse<Task[]>> {
    const response = await apiClient.get<ApiResponse<Task[]>>(this.baseUrl);
    return response.data;
  }

  async getTask(id: string): Promise<ApiResponse<Task>> {
    const response = await apiClient.get<ApiResponse<Task>>(`${this.baseUrl}/${id}`);
    return response.data;
  }

  async createTask(request: CreateTaskRequest): Promise<ApiResponse<Task>> {
    const response = await apiClient.post<ApiResponse<Task>>(this.baseUrl, request);
    return response.data;
  }

  async updateTask(id: string, request: UpdateTaskRequest): Promise<ApiResponse<Task>> {
    const response = await apiClient.put<ApiResponse<Task>>(`${this.baseUrl}/${id}`, request);
    return response.data;
  }

  async deleteTask(id: string): Promise<void> {
    await apiClient.delete(`${this.baseUrl}/${id}`);
  }

  async completeTask(id: string): Promise<ApiResponse<Task>> {
    const response = await apiClient.patch<ApiResponse<Task>>(`${this.baseUrl}/${id}/complete`);
    return response.data;
  }
}

export const taskService = new TaskService();
```

## Custom Hooks

### useTask Hook (hooks/useTask.ts)
```typescript
import { useEffect } from 'react';
import { useAppDispatch, useAppSelector } from '../store/hooks';
import { fetchTasks, createTask, updateTask, deleteTask } from '../store/taskSlice';
import type { CreateTaskRequest, UpdateTaskRequest } from '../types';

export const useTasks = () => {
  const dispatch = useAppDispatch();
  const { tasks, isLoading, error } = useAppSelector(state => state.tasks);

  useEffect(() => {
    dispatch(fetchTasks());
  }, [dispatch]);

  const handleCreateTask = async (request: CreateTaskRequest) => {
    await dispatch(createTask(request)).unwrap();
  };

  const handleUpdateTask = async (id: string, request: UpdateTaskRequest) => {
    await dispatch(updateTask({ id, request })).unwrap();
  };

  const handleDeleteTask = async (id: string) => {
    await dispatch(deleteTask(id)).unwrap();
  };

  return {
    tasks,
    isLoading,
    error,
    createTask: handleCreateTask,
    updateTask: handleUpdateTask,
    deleteTask: handleDeleteTask,
  };
};
```

## Form Handling with React Hook Form

```typescript
import { useForm, Controller } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';

const taskSchema = z.object({
  title: z.string().min(1, 'Title is required').max(200),
  description: z.string().max(2000).optional(),
  dueDate: z.date().nullable(),
  priority: z.enum(['low', 'medium', 'high', 'urgent']),
  categoryId: z.string().uuid().optional(),
});

type TaskFormData = z.infer<typeof taskSchema>;

export const TaskForm: React.FC<TaskFormProps> = ({ onSubmit, initialData }) => {
  const { control, handleSubmit, formState: { errors } } = useForm<TaskFormData>({
    resolver: zodResolver(taskSchema),
    defaultValues: initialData,
  });

  return (
    <form onSubmit={handleSubmit(onSubmit)}>
      <Controller
        name="title"
        control={control}
        render={({ field }) => (
          <TextField
            {...field}
            label="Title"
            error={!!errors.title}
            helperText={errors.title?.message}
            fullWidth
          />
        )}
      />
      {/* Other form fields */}
    </form>
  );
};
```</code></pre>

          <h2>Implementing the Orchestrator Agent</h2>
          
          <h3>Main Orchestrator (.github/agents/orchestrator.md)</h3>
          <pre><code>---
name: orchestrator
description: Full-stack orchestrator that builds ANY feature using .NET 10 + React.js based on user prompts
model: claude-sonnet-4.5
user-invokable: true
commands:
  - name: build-feature
    description: Build complete full-stack application for the specified feature using .NET 10 backend and React.js frontend
    arguments:
      - name: feature_description
        description: Detailed description of the feature to build (e.g., "TODO app with task management", "Blog platform with comments", "E-commerce with shopping cart")
        required: true
  - name: add-feature
    description: Add a new feature to an existing application
    arguments:
      - name: feature_description
        description: Description of the feature to add
        required: true
  - name: fix
    description: Fix a bug in the application
  - name: deploy
    description: Deploy application to production
subagents:
  - planning
  - design
  - coding
  - review
  - testing
  - security
  - infrastructure
instructions:
  - .github/instructions/fullstack-standards.md
  - .github/instructions/dotnet-standards.md
  - .github/instructions/react-standards.md
prompts:
  - .github/prompts/feature-template.md
  - .github/prompts/crud-api.md
  - .github/prompts/react-component.md
---

# Full-Stack Orchestrator Agent

I am a **generic full-stack orchestrator** that builds ANY feature you describe using a pre-configured .NET 10 + React.js technology stack.

**ü§ñ Why Claude Sonnet 4.5 for Orchestrator?**

The orchestrator uses `claude-sonnet-4.5` because it requires:
- **Advanced reasoning** - Parse complex user prompts and extract requirements
- **Strategic coordination** - Decide which subagents to invoke and in what order
- **Context management** - Track state across multiple agent interactions
- **Error recovery** - Handle failures and retry logic intelligently
- **Quality integration** - Combine outputs from multiple agents coherently

This is the "brain" of your multi-agent system, so investing in a premium model pays off.

## What Makes Me Generic

üéØ **You provide the feature requirements** - I accept ANY feature description as a prompt  
üõ†Ô∏è **Technology stack is fixed** - Always uses .NET 10 backend + React.js frontend  
üìã **Global Instructions ensure consistency** - All features follow the same architectural patterns  
üîÑ **Reusable Prompt templates** - Standardized workflows for common patterns (CRUD, authentication, etc.)

## My Responsibilities

1. **Accept User Feature Prompts** - Take your feature description and translate it into requirements
2. **Coordinate Development Workflow** - Manage the end-to-end development process
3. **Delegate to Specialized SubAgents** - Route tasks to the right experts
4. **Apply Global Instructions** - Ensure all features follow coding standards and best practices
5. **Track Progress** - Monitor and report on overall project status
6. **Integrate Results** - Combine outputs from all subagents into a cohesive solution
7. **Ensure Quality** - Validate that all phases complete successfully

## Technology Stack (Always Applied)

### Backend: .NET 10
- ASP.NET Core 10.0 Web API
- Entity Framework Core 10.0
- ASP.NET Core Identity (authentication)
- Clean Architecture (API, Business, Data layers)
- xUnit for testing

### Frontend: React 18+
- React 18+ with TypeScript 5+
- Redux Toolkit (state management)
- Material-UI or Tailwind CSS
- React Hook Form
- Jest + React Testing Library

### Database
- SQL Server or PostgreSQL
- EF Core Code-First migrations
- Repository pattern

## Development Process

When you invoke `/build-feature "your feature description"`, I will:

### Phase 1: Planning (delegate to @planning)
- Parse the **user's feature description** (e.g., "TODO app with task management")
- Create comprehensive project plan tailored to that feature
- Define architecture: Clean Architecture with .NET 10 Web API
- Extract entities and relationships from feature description
- Define development milestones and timeline
- **Apply global instructions** from `.github/instructions/fullstack-standards.md`

### Phase 2: Design (delegate to @design)
- Design data models based on **feature requirements**
- Define API endpoints specific to the feature (e.g., `/api/tasks` for TODO app)
- Create React component architecture for the feature's UI
- Design authentication flow (JWT tokens)
- Database schema design with relationships
- **Use prompt templates** from `.github/prompts/crud-api.md` for standard patterns

### Phase 3: Implementation (delegate to @coding)
- Generate .NET 10 backend code (Controllers, Services, Models, DbContext)
- Generate React.js frontend code (Components, Hooks, API client)
- Implement authentication and authorization
- Create database migrations
- Configure dependency injection
- **Follow coding standards** from `.github/instructions/dotnet-standards.md` and `react-standards.md`

### Phase 4: Code Review (delegate to @review)
- Analyze code quality and best practices
- Check for SOLID principles adherence
- Verify proper async/await usage
- Validate error handling patterns
- Review naming conventions
- **Ensure compliance with global instructions**

### Phase 5: Testing (delegate to @testing)
- Generate xUnit tests for .NET backend
- Generate Jest tests for React frontend
- Create integration tests for API endpoints
- Setup test fixtures and mocking
- Aim for 80%+ code coverage
- **Use testing templates** from `.github/prompts/testing-template.md`

### Phase 6: Security Analysis (delegate to @security)
- Check for SQL injection vulnerabilities
- Validate JWT token implementation
- Verify CORS configuration
- Check for hardcoded secrets
- Scan dependencies for known vulnerabilities
- Validate HTTPS enforcement
- **Apply security policies** from global instructions

### Phase 7: Infrastructure (delegate to @infrastructure)
- Create Dockerfile for .NET API
- Create Dockerfile for React app
- Generate docker-compose.yml
- Setup GitHub Actions CI/CD pipeline
- Configure environment variables

## Output

I will provide a comprehensive summary showing:
- ‚úÖ Status of each phase
- üìä Statistics (files created, test coverage, security score)
- üöÄ Next steps for deployment
- ‚ö†Ô∏è Any issues requiring attention
- üìù Feature-specific implementation notes

## Example Usage

### Example 1: TODO Application (Demo)
```
@orchestrator /build-feature "Create a TODO application with task management, categories, due dates, and priority levels"
```

**Result:** Full-stack TODO app with:
- Backend: TasksController, TaskService, Task entity, Category entity
- Frontend: TaskList, TaskCard, CreateTaskForm components
- Database: Tasks, Categories, TaskCategories tables
- Auth: User-specific tasks with JWT authentication

### Example 2: Blog Platform
```
@orchestrator /build-feature "Build a blog platform with posts, comments, author profiles, and markdown support"
```

**Result:** Full-stack blog app with:
- Backend: PostsController, CommentsController, AuthorsController
- Frontend: PostList, PostDetail, CommentThread, MarkdownEditor components
- Database: Posts, Comments, Authors, Tags tables

### Example 3: E-commerce
```
@orchestrator /build-feature "Create an e-commerce system with products, shopping cart, checkout, and order history"
```

**Result:** Full-stack e-commerce app with:
- Backend: ProductsController, CartController, OrdersController
- Frontend: ProductCatalog, ShoppingCart, Checkout components
- Database: Products, CartItems, Orders, OrderDetails tables

### Example 4: User Management
```
@orchestrator /build-feature "Build a user management system with roles, permissions, and audit logging"
```

**Result:** Full-stack user management app with:
- Backend: UsersController, RolesController, AuditController
- Frontend: UserList, RoleAssignment, AuditLog components
- Database: Users, Roles, Permissions, AuditLogs tables

I will coordinate all subagents to deliver a production-ready application with .NET 10 and React.js based on YOUR feature description.</code></pre>

          <h2>Prompt Files for Feature Generation</h2>

          <p>
            Prompt files provide reusable templates that help agents generate consistent, high-quality code for common patterns.
            The orchestrator references these templates to ensure standardized implementations across different features.
          </p>

          <h3>Feature Planning Template (.github/prompts/feature-template.md)</h3>
          <pre><code>---
name: feature-planning-template
description: Generic template for planning any full-stack feature
version: 1.0
---

# Feature Planning Template

Use this template when planning ANY feature for the full-stack application.

## Feature Analysis Checklist

### 1. Understand the Feature Requirements
- [ ] Extract key entities from feature description
- [ ] Identify relationships between entities  
- [ ] Determine CRUD operations needed
- [ ] List business rules and validations
- [ ] Define authentication/authorization requirements
- [ ] Identify integration points with existing features

### 2. Backend Planning (.NET 10)

#### Entities to Create
```
For each entity in the feature:
- Entity name (PascalCase, singular)
- Properties (name, type, nullable, max length)
- Relationships (OneToMany, ManyToMany, etc.)
- Indexes needed
- Cascading deletes
```

#### API Endpoints to Implement
```
For each entity:
GET    /api/{entities}              - List all (with pagination)
GET    /api/{entities}/{id}         - Get by ID
POST   /api/{entities}              - Create
PUT    /api/{entities}/{id}         - Update
DELETE /api/{entities}/{id}         - Delete
GET    /api/{entities}/search?q=    - Search (if applicable)
```

#### Services &amp; Business Logic
```
For each entity:
- I{Entity}Service interface
- {Entity}Service implementation
- Validation logic (FluentValidation)
- Business rules
- Authorization checks
```

### 3. Frontend Planning (React + TypeScript)

#### TypeScript Interfaces
```
For each entity:
- {Entity} interface (matches backend DTO)
- Create{Entity}Request interface
- Update{Entity}Request interface
- {Entity}ListItem interface (if different from full entity)
```

#### Components to Create
```
- {Entity}List.tsx           - Display list of items (table/grid)
- {Entity}Card.tsx           - Individual item display
- {Entity}Form.tsx           - Create/Edit form
- {Entity}Detail.tsx         - Full detail view (if needed)
- {Entity}Filters.tsx        - Search/filter controls (if needed)
```

#### Redux Slices
```
- {entity}Slice.ts with:
  - Initial state  
  - Async thunks (fetch, create, update, delete)
  - Reducers
  - Selectors
```

#### API Services
```
- {entity}Service.ts with:
  - get{Entities}()
  - get{Entity}(id)
  - create{Entity}(request)
  - update{Entity}(id, request)
  - delete{Entity}(id)
```

### 4. Database Schema

```sql
-- For each entity, generate:
CREATE TABLE {Entities} (
    Id UNIQUEIDENTIFIER PRIMARY KEY DEFAULT NEWID(),
    -- entity-specific fields
    CreatedAt DATETIME2 NOT NULL DEFAULT GETUTCDATE(),
    CreatedBy NVARCHAR(100),
    UpdatedAt DATETIME2,
    UpdatedBy NVARCHAR(100),
    IsDeleted BIT NOT NULL DEFAULT 0
);

-- Indexes
CREATE INDEX IX_{Entity}_{Field} ON {Entities}({Field});

-- Relationships
ALTER TABLE {ChildEntity} 
ADD CONSTRAINT FK_{ChildEntity}_{ParentEntity}
FOREIGN KEY ({ParentEntity}Id) REFERENCES {ParentEntities}(Id)
ON DELETE CASCADE;
```

### 5. Testing Strategy

#### Unit Tests
```
- {Entity}ServiceTests.cs - Business logic tests
- {Entity}ControllerTests.cs - Controller tests
- {entity}Slice.test.ts - Redux logic tests
- {Entity}Form.test.tsx - Component tests
```

#### Integration Tests
```
- {Entity}ApiTests.cs - End-to-end API tests
```

## Output Format

After analysis, provide:

1. **Feature Summary** (2-3 sentences)
2. **Entities** (list with properties)
3. **Relationships** (entity relationship diagram in text)
4. **API Endpoints** (complete list)
5. **UI Components** (component tree)
6. **Success Criteria** (how to verify feature works)</code></pre>

          <h3>CRUD API Generation Prompt (.github/prompts/crud-api.md)</h3>
          <pre><code>---
name: crud-api-generation
description: Generate RESTful CRUD API for any entity
version: 1.0
---

# CRUD API Generation Prompt

Use this prompt to generate a complete CRUD API for any entity in .NET 10.

## Variables (Replace These)

- `{Entity}` = Singular entity name (e.g., "Task", "Product", "Post")
- `{Entities}` = Plural entity name (e.g., "Tasks", "Products", "Posts")
- `{entity}` = Camel-case singular (e.g., "task", "product", "post")
- `{EntityProperties}` = List of properties from planning phase

## 1. Entity Class (Data/Entities/{Entity}.cs)

```csharp
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace TodoApp.Data.Entities
{
    public class {Entity}
    {
        [Key]
        public Guid Id { get; set; } = Guid.NewGuid();
        
        // {EntityProperties} - ADD BASED ON FEATURE REQUIREMENTS
        [Required]
        [MaxLength(200)]
        public string Title { get; set; } = string.Empty;
        
        public string? Description { get; set; }
        
        public bool IsActive { get; set; } = true;
        
        // Audit fields
        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;
        public string? CreatedBy { get; set; }
        public DateTime? UpdatedAt { get; set; }
        public string? UpdatedBy { get; set; }
        
        // Relationships - ADD BASED ON FEATURE REQUIREMENTS
        // public Guid UserId { get; set; }
        // [ForeignKey(nameof(UserId))]
        // public User User { get; set; } = null!;
    }
}
```

## 2. DTOs (API/DTOs/{Entity}Dtos.cs)

```csharp
using System.ComponentModel.DataAnnotations;

namespace TodoApp.API.DTOs
{
    public record {Entity}Dto(
        Guid Id,
        string Title,
        string? Description,
        bool IsActive,
        DateTime CreatedAt
        // Add other properties from entity
    );

    public record Create{Entity}Request(
        [Required, MaxLength(200)] string Title,
        [MaxLength(2000)] string? Description
        // Add other properties needed for creation
    );

    public record Update{Entity}Request(
        [Required, MaxLength(200)] string Title,
        [MaxLength(2000)] string? Description,
        bool IsActive
        // Add other properties needed for update
    );
}
```

## 3. Service Interface (Business/Interfaces/I{Entity}Service.cs)

```csharp
using TodoApp.API.DTOs;

namespace TodoApp.Business.Interfaces
{
    public interface I{Entity}Service
    {
        Task&lt;IEnumerable&lt;{Entity}Dto&gt;&gt; GetAllAsync();
        Task&lt;{Entity}Dto?&gt; GetByIdAsync(Guid id);
        Task&lt;{Entity}Dto&gt; CreateAsync(Create{Entity}Request request);
        Task&lt;{Entity}Dto?&gt; UpdateAsync(Guid id, Update{Entity}Request request);
        Task&lt;bool&gt; DeleteAsync(Guid id);
    }
}
```

## 4. Service Implementation (Business/Services/{Entity}Service.cs)

```csharp
using AutoMapper;
using Microsoft.EntityFrameworkCore;
using TodoApp.API.DTOs;
using TodoApp.Business.Interfaces;
using TodoApp.Data;
using TodoApp.Data.Entities;

namespace TodoApp.Business.Services
{
    public class {Entity}Service : I{Entity}Service
    {
        private readonly ApplicationDbContext _context;
        private readonly IMapper _mapper;
        private readonly ILogger&lt;{Entity}Service&gt; _logger;

        public {Entity}Service(
            ApplicationDbContext context,
            IMapper mapper,
            ILogger&lt;{Entity}Service&gt; logger)
        {
            _context = context;
            _mapper = mapper;
            _logger = logger;
        }

        public async Task&lt;IEnumerable&lt;{Entity}Dto&gt;&gt; GetAllAsync()
        {
            var entities = await _context.{Entities}
                .AsNoTracking()
                .ToListAsync();
            
            return _mapper.Map&lt;IEnumerable&lt;{Entity}Dto&gt;&gt;(entities);
        }

        public async Task&lt;{Entity}Dto?&gt; GetByIdAsync(Guid id)
        {
            var entity = await _context.{Entities}
                .AsNoTracking()
                .FirstOrDefaultAsync(x => x.Id == id);
            
            return entity != null ? _mapper.Map&lt;{Entity}Dto&gt;(entity) : null;
        }

        public async Task&lt;{Entity}Dto&gt; CreateAsync(Create{Entity}Request request)
        {
            var entity = _mapper.Map&lt;{Entity}&gt;(request);
            
            _context.{Entities}.Add(entity);
            await _context.SaveChangesAsync();
            
            _logger.LogInformation("{Entity} created with ID: {Id}", entity.Id);
            
            return _mapper.Map&lt;{Entity}Dto&gt;(entity);
        }

        public async Task&lt;{Entity}Dto?&gt; UpdateAsync(Guid id, Update{Entity}Request request)
        {
            var entity = await _context.{Entities}.FindAsync(id);
            if (entity == null)
                return null;
            
            _mapper.Map(request, entity);
            entity.UpdatedAt = DateTime.UtcNow;
            
            await _context.SaveChangesAsync();
            
            _logger.LogInformation("{Entity} updated: {Id}", id);
            
            return _mapper.Map&lt;{Entity}Dto&gt;(entity);
        }

        public async Task&lt;bool&gt; DeleteAsync(Guid id)
        {
            var entity = await _context.{Entities}.FindAsync(id);
            if (entity == null)
                return false;
            
            _context.{Entities}.Remove(entity);
            await _context.SaveChangesAsync();
            
            _logger.LogInformation("{Entity} deleted: {Id}", id);
            
            return true;
        }
    }
}
```

## 5. Controller (API/Controllers/{Entities}Controller.cs)

```csharp
using Microsoft.AspNetCore.Authorization;
using Microsoft.AspNetCore.Mvc;
using TodoApp.API.DTOs;
using TodoApp.Business.Interfaces;

namespace TodoApp.API.Controllers
{
    [ApiController]
    [Route("api/[controller]")]
    [Authorize]
    public class {Entities}Controller : ControllerBase
    {
        private readonly I{Entity}Service _{entity}Service;
        private readonly ILogger&lt;{Entities}Controller&gt; _logger;

        public {Entities}Controller(
            I{Entity}Service {entity}Service,
            ILogger&lt;{Entities}Controller&gt; logger)
        {
            _{entity}Service = {entity}Service;
            _logger = logger;
        }

        [HttpGet]
        [ProducesResponseType(typeof(IEnumerable&lt;{Entity}Dto&gt;), StatusCodes.Status200OK)]
        public async Task&lt;ActionResult&lt;IEnumerable&lt;{Entity}Dto&gt;&gt;&gt; Get{Entities}()
        {
            var entities = await _{entity}Service.GetAllAsync();
            return Ok(entities);
        }

        [HttpGet("{id}")]
        [ProducesResponseType(typeof({Entity}Dto), StatusCodes.Status200OK)]
        [ProducesResponseType(StatusCodes.Status404NotFound)]
        public async Task&lt;ActionResult&lt;{Entity}Dto&gt;&gt; Get{Entity}(Guid id)
        {
            var entity = await _{entity}Service.GetByIdAsync(id);
            if (entity == null)
                return NotFound();
            
            return Ok(entity);
        }

        [HttpPost]
        [ProducesResponseType(typeof({Entity}Dto), StatusCodes.Status201Created)]
        [ProducesResponseType(StatusCodes.Status400BadRequest)]
        public async Task&lt;ActionResult&lt;{Entity}Dto&gt;&gt; Create{Entity}(Create{Entity}Request request)
        {
            if (!ModelState.IsValid)
                return BadRequest(ModelState);
            
            var entity = await _{entity}Service.CreateAsync(request);
            
            return CreatedAtAction(
                nameof(Get{Entity}),
                new { id = entity.Id },
                entity);
        }

        [HttpPut("{id}")]
        [ProducesResponseType(typeof({Entity}Dto), StatusCodes.Status200OK)]
        [ProducesResponseType(StatusCodes.Status404NotFound)]
        public async Task&lt;ActionResult&lt;{Entity}Dto&gt;&gt; Update{Entity}(
            Guid id,
            Update{Entity}Request request)
        {
            if (!ModelState.IsValid)
                return BadRequest(ModelState);
            
            var entity = await _{entity}Service.UpdateAsync(id, request);
            if (entity == null)
                return NotFound();
            
            return Ok(entity);
        }

        [HttpDelete("{id}")]
        [ProducesResponseType(StatusCodes.Status204NoContent)]
        [ProducesResponseType(StatusCodes.Status404NotFound)]
        public async Task&lt;IActionResult&gt; Delete{Entity}(Guid id)
        {
            var deleted = await _{entity}Service.DeleteAsync(id);
            if (!deleted)
                return NotFound();
            
            return NoContent();
        }
    }
}
```

## 6. AutoMapper Profile (API/Mappings/{Entity}Profile.cs)

```csharp
using AutoMapper;
using TodoApp.API.DTOs;
using TodoApp.Data.Entities;

namespace TodoApp.API.Mappings
{
    public class {Entity}Profile : Profile
    {
        public {Entity}Profile()
        {
            CreateMap&lt;{Entity}, {Entity}Dto&gt;();
            CreateMap&lt;Create{Entity}Request, {Entity}&gt;();
            CreateMap&lt;Update{Entity}Request, {Entity}&gt;()
                .ForMember(dest => dest.Id, opt => opt.Ignore())
                .ForMember(dest => dest.CreatedAt, opt => opt.Ignore());
        }
    }
}
```</code></pre>

          <h3>React Component Generation Prompt (.github/prompts/react-component.md)</h3>
          <pre><code>---
name: react-component-generation
description: Generate React components with TypeScript for any feature
version: 1.0
---

# React Component Generation Prompt

Use this prompt to generate complete React components for any entity.

## Variables (Replace These)

- `{Entity}` = Singular entity name (e.g., "Task", "Product", "Post")
- `{Entities}` = Plural entity name (e.g., "Tasks", "Products", "Posts")
- `{entity}` = Camel-case singular (e.g., "task", "product", "post")

## 1. TypeScript Interfaces (types/{entity}.ts)

```typescript
export interface {Entity} {
  id: string;
  title: string;
  description?: string;
  isActive: boolean;
  createdAt: Date;
  updatedAt?: Date;
  // Add other properties from backend DTO
}

export interface Create{Entity}Request {
  title: string;
  description?: string;
  // Add other properties needed for creation
}

export interface Update{Entity}Request extends Create{Entity}Request {
  isActive: boolean;
  // Add other update-specific properties
}

export interface {Entity}ListFilters {
  search?: string;
  isActive?: boolean;
  sortBy?: 'title' | 'createdAt' | 'updatedAt';
  sortOrder?: 'asc' | 'desc';
}
```

## 2. API Service (services/{entity}Service.ts)

```typescript
import { apiClient } from './apiClient';
import type { {Entity}, Create{Entity}Request, Update{Entity}Request } from '../types/{entity}';

class {Entity}Service {
  private baseUrl = '/{entities}';

  async getAll(): Promise&lt;{Entity}[]&gt; {
    const response = await apiClient.get&lt;{Entity}[]&gt;(this.baseUrl);
    return response.data;
  }

  async getById(id: string): Promise&lt;{Entity}&gt; {
    const response = await apiClient.get&lt;{Entity}&gt;(`${this.baseUrl}/${id}`);
    return response.data;
  }

  async create(request: Create{Entity}Request): Promise&lt;{Entity}&gt; {
    const response = await apiClient.post&lt;{Entity}&gt;(this.baseUrl, request);
    return response.data;
  }

  async update(id: string, request: Update{Entity}Request): Promise&lt;{Entity}&gt; {
    const response = await apiClient.put&lt;{Entity}&gt;(`${this.baseUrl}/${id}`, request);
    return response.data;
  }

  async delete(id: string): Promise&lt;void&gt; {
    await apiClient.delete(`${this.baseUrl}/${id}`);
  }
}

export const {entity}Service = new {Entity}Service();
```

## 3. Redux Slice (store/{entity}Slice.ts)

```typescript
import { createSlice, createAsyncThunk, PayloadAction } from '@reduxjs/toolkit';
import { {entity}Service } from '../services/{entity}Service';
import type { {Entity}, Create{Entity}Request, Update{Entity}Request } from '../types/{entity}';

interface {Entity}State {
  {entities}: {Entity}[];
  selected{Entity}: {Entity} | null;
  isLoading: boolean;
  error: string | null;
}

const initialState: {Entity}State = {
  {entities}: [],
  selected{Entity}: null,
  isLoading: false,
  error: null,
};

export const fetch{Entities} = createAsyncThunk(
  '{entities}/fetchAll',
  async (_, { rejectWithValue }) =&gt; {
    try {
      return await {entity}Service.getAll();
    } catch (error: any) {
      return rejectWithValue(error.response?.data || 'Failed to fetch {entities}');
    }
  }
);

export const fetch{Entity} = createAsyncThunk(
  '{entities}/fetchOne',
  async (id: string, { rejectWithValue }) =&gt; {
    try {
      return await {entity}Service.getById(id);
    } catch (error: any) {
      return rejectWithValue(error.response?.data || 'Failed to fetch {entity}');
    }
  }
);

export const create{Entity} = createAsyncThunk(
  '{entities}/create',
  async (request: Create{Entity}Request, { rejectWithValue }) =&gt; {
    try {
      return await {entity}Service.create(request);
    } catch (error: any) {
      return rejectWithValue(error.response?.data || 'Failed to create {entity}');
    }
  }
);

export const update{Entity} = createAsyncThunk(
  '{entities}/update',
  async ({ id, request }: { id: string; request: Update{Entity}Request }, { rejectWithValue }) =&gt; {
    try {
      return await {entity}Service.update(id, request);
    } catch (error: any) {
      return rejectWithValue(error.response?.data || 'Failed to update {entity}');
    }
  }
);

export const delete{Entity} = createAsyncThunk(
  '{entities}/delete',
  async (id: string, { rejectWithValue }) =&gt; {
    try {
      await {entity}Service.delete(id);
      return id;
    } catch (error: any) {
      return rejectWithValue(error.response?.data || 'Failed to delete {entity}');
    }
  }
);

const {entity}Slice = createSlice({
  name: '{entities}',
  initialState,
  reducers: {
    select{Entity}: (state, action: PayloadAction&lt;{Entity} | null&gt;) =&gt; {
      state.selected{Entity} = action.payload;
    },
    clearError: (state) =&gt; {
      state.error = null;
    },
  },
  extraReducers: (builder) =&gt; {
    builder
      // Fetch all {entities}
      .addCase(fetch{Entities}.pending, (state) =&gt; {
        state.isLoading = true;
        state.error = null;
      })
      .addCase(fetch{Entities}.fulfilled, (state, action) =&gt; {
        state.isLoading = false;
        state.{entities} = action.payload;
      })
      .addCase(fetch{Entities}.rejected, (state, action) =&gt; {
        state.isLoading = false;
        state.error = action.payload as string;
      })
      // Fetch single {entity}
      .addCase(fetch{Entity}.fulfilled, (state, action) =&gt; {
        state.selected{Entity} = action.payload;
      })
      // Create {entity}
      .addCase(create{Entity}.fulfilled, (state, action) =&gt; {
        state.{entities}.push(action.payload);
      })
      // Update {entity}
      .addCase(update{Entity}.fulfilled, (state, action) =&gt; {
        const index = state.{entities}.findIndex(t =&gt; t.id === action.payload.id);
        if (index !== -1) {
          state.{entities}[index] = action.payload;
        }
        if (state.selected{Entity}?.id === action.payload.id) {
          state.selected{Entity} = action.payload;
        }
      })
      // Delete {entity}
      .addCase(delete{Entity}.fulfilled, (state, action) =&gt; {
        state.{entities} = state.{entities}.filter(t =&gt; t.id !== action.payload);
        if (state.selected{Entity}?.id === action.payload) {
          state.selected{Entity} = null;
        }
      });
  },
});

export const { select{Entity}, clearError } = {entity}Slice.actions;
export default {entity}Slice.reducer;
```

## 4. List Component (components/{Entity}List.tsx)

```typescript
import React, { useEffect } from 'react';
import { useAppDispatch, useAppSelector } from '../hooks/redux';
import { fetch{Entities}, delete{Entity} } from '../store/{entity}Slice';
import { {Entity}Card } from './{Entity}Card';
import { CircularProgress, Alert, Grid } from '@mui/material';

export const {Entity}List: React.FC = () =&gt; {
  const dispatch = useAppDispatch();
  const { {entities}, isLoading, error } = useAppSelector(state =&gt; state.{entities});

  useEffect(() =&gt; {
    dispatch(fetch{Entities}());
  }, [dispatch]);

  const handleDelete = async (id: string) =&gt; {
    if (window.confirm('Are you sure you want to delete this {entity}?')) {
      await dispatch(delete{Entity}(id));
    }
  };

  if (isLoading) {
    return &lt;CircularProgress /&gt;;
  }

  if (error) {
    return &lt;Alert severity="error"&gt;{error}&lt;/Alert&gt;;
  }

  return (
    &lt;Grid container spacing={2}&gt;
      {{entities}.map(({entity}) =&gt; (
        &lt;Grid item xs={12} sm={6} md={4} key={{entity}.id}&gt;
          &lt;{Entity}Card {entity}={{entity}} onDelete={handleDelete} /&gt;
        &lt;/Grid&gt;
      ))}
    &lt;/Grid&gt;
  );
};
```

## 5. Card Component (components/{Entity}Card.tsx)

```typescript
import React from 'react';
import { Card, CardContent, CardActions, Typography, Button, IconButton } from '@mui/material';
import { Edit as EditIcon, Delete as DeleteIcon } from '@mui/icons-material';
import type { {Entity} } from '../types/{entity}';

interface {Entity}CardProps {
  {entity}: {Entity};
  onEdit?: (id: string) =&gt; void;
  onDelete?: (id: string) =&gt; void;
}

export const {Entity}Card: React.FC&lt;{Entity}CardProps&gt; = ({ 
  {entity}, 
  onEdit, 
  onDelete 
}) =&gt; {
  return (
    &lt;Card&gt;
      &lt;CardContent&gt;
        &lt;Typography variant="h6" gutterBottom&gt;
          {{entity}.title}
        &lt;/Typography&gt;
        {{{entity}.description &amp;&amp; (
          &lt;Typography variant="body2" color="text.secondary"&gt;
            {{entity}.description}
          &lt;/Typography&gt;
        )}}
        &lt;Typography variant="caption" display="block" sx={{ mt: 2 }}&gt;
          Created: {new Date({entity}.createdAt).toLocaleDateString()}
        &lt;/Typography&gt;
      &lt;/CardContent&gt;
      &lt;CardActions&gt;
        {onEdit &amp;&amp; (
          &lt;IconButton onClick={() =&gt; onEdit({entity}.id)} aria-label="edit"&gt;
            &lt;EditIcon /&gt;
          &lt;/IconButton&gt;
        )}
        {onDelete &amp;&amp; (
          &lt;IconButton onClick={() =&gt; onDelete({entity}.id)} color="error" aria-label="delete"&gt;
            &lt;DeleteIcon /&gt;
          &lt;/IconButton&gt;
        )}
      &lt;/CardActions&gt;
    &lt;/Card&gt;
  );
};
```

## 6. Form Component (components/{Entity}Form.tsx)

```typescript
import React from 'react';
import { useForm, Controller } from 'react-hook-form';
import { zodResolver } from '@hookform/resolvers/zod';
import { z } from 'zod';
import { TextField, Button, Stack } from '@mui/material';
import type { Create{Entity}Request } from '../types/{entity}';

const {entity}Schema = z.object({
  title: z.string().min(1, 'Title is required').max(200),
  description: z.string().max(2000).optional(),
  // Add other fields
});

type {Entity}FormData = z.infer&lt;typeof {entity}Schema&gt;;

interface {Entity}FormProps {
  initialData?: Partial&lt;Create{Entity}Request&gt;;
  onSubmit: (data: Create{Entity}Request) =&gt; void;
  onCancel?: () =&gt; void;
}

export const {Entity}Form: React.FC&lt;{Entity}FormProps&gt; = ({
  initialData,
  onSubmit,
  onCancel,
}) =&gt; {
  const { control, handleSubmit, formState: { errors, isSubmitting } } = useForm&lt;{Entity}FormData&gt;({
    resolver: zodResolver({entity}Schema),
    defaultValues: initialData,
  });

  return (
    &lt;form onSubmit={handleSubmit(onSubmit)}&gt;
      &lt;Stack spacing={2}&gt;
        &lt;Controller
          name="title"
          control={control}
          render={({ field }) =&gt; (
            &lt;TextField
              {...field}
              label="Title"
              error={!!errors.title}
              helperText={errors.title?.message}
              fullWidth
              required
            /&gt;
          )}
        /&gt;
        
        &lt;Controller
          name="description"
          control={control}
          render={({ field }) =&gt; (
            &lt;TextField
              {...field}
              label="Description"
              multiline
              rows={4}
              error={!!errors.description}
              helperText={errors.description?.message}
              fullWidth
            /&gt;
          )}
        /&gt;

        &lt;Stack direction="row" spacing={2}&gt;
          &lt;Button
            type="submit"
            variant="contained"
            disabled={isSubmitting}
          &gt;
            {initialData ? 'Update' : 'Create'}
          &lt;/Button&gt;
          {onCancel &amp;&amp; (
            &lt;Button
              type="button"
              variant="outlined"
              onClick={onCancel}
            &gt;
              Cancel
            &lt;/Button&gt;
          )}
        &lt;/Stack&gt;
      &lt;/Stack&gt;
    &lt;/form&gt;
  );
};
```</code></pre>

          <h2>How Prompt Files Enable Generic Features</h2>

          <div class="callout">
            <strong>üéØ Key Insight: Variable Substitution Makes It Generic</strong><br /><br />
            <p>The prompt files use <strong>variable placeholders</strong> like <code>{Entity}</code>, <code>{Entities}</code>, and <code>{entity}</code> that get replaced with actual values from the user's feature description:</p>
            <ul>
              <li><strong>TODO App:</strong> <code>{Entity}</code> = "Task", <code>{Entities}</code> = "Tasks"</li>
              <li><strong>Blog Platform:</strong> <code>{Entity}</code> = "Post", <code>{Entities}</code> = "Posts"</li>
              <li><strong>E-commerce:</strong> <code>{Entity}</code> = "Product", <code>{Entities}</code> = "Products"</li>
            </ul>
            <p>This allows the same prompt templates to generate completely different applications based on user input while maintaining consistent architecture and coding standards.</p>
          </div
>

          <h3>Example: From User Prompt to Generated Code</h3>

          <h4>User Input</h4>
          <pre><code>@orchestrator /build-feature "Create a TODO application with task management, categories, due dates, and priority levels"</code></pre>

          <h4>What the Orchestrator Does</h4>
          <ol>
            <li><strong>Parse Feature Description</strong>
              <ul>
                <li>Extract main entity: "Task"</li>
                <li>Extract properties: title, description, category, dueDate, priority</li>
                <li>Identify relationships: Tasks belong to Categories</li>
              </ul>
            </li>
            <li><strong>Apply Prompt Templates</strong>
              <ul>
                <li>Load <code>crud-api.md</code> template</li>
                <li>Replace <code>{Entity}</code> with "Task"</li>
                <li>Replace <code>{Entities}</code> with "Tasks"</li>
                <li>Replace <code>{entity}</code> with "task"</li>
              </ul>
            </li>
            <li><strong>Apply Global Instructions</strong>
              <ul>
                <li>Follow .NET 10 coding standards</li>
                <li>Use Clean Architecture pattern</li>
                <li>Apply security best practices</li>
                <li>Include comprehensive testing</li>
              </ul>
            </li>
            <li><strong>Delegate to Specialized Agents</strong>
              <ul>
                <li>@planning: Creates architecture plan</li>
                <li>@design: Designs database schema and API</li>
                <li>@coding: Generates actual code files</li>
                <li>@review: Reviews for quality</li>
                <li>@testing: Creates unit and integration tests</li>
              </ul>
            </li>
          </ol>

          <h4>Generated Files (Sample)</h4>
          <pre><code># Backend (.NET 10)
Data/Entities/Task.cs
Data/Entities/Category.cs
API/DTOs/TaskDtos.cs
Business/Interfaces/ITaskService.cs
Business/Services/TaskService.cs
API/Controllers/TasksController.cs
API/Controllers/CategoriesController.cs

# Frontend (React + TypeScript)
types/task.ts
types/category.ts
services/taskService.ts
store/taskSlice.ts
components/TaskList.tsx
components/TaskCard.tsx
components/TaskForm.tsx

# Tests
Tests/TaskServiceTests.cs
Tests/TaskControllerTests.cs
src/__tests__/taskSlice.test.ts
src/__tests__/TaskForm.test.tsx</code></pre>

          <h3>Alternative Example: Blog Platform</h3>

          <h4>User Input</h4>
          <pre><code>@orchestrator /build-feature "Build a blog platform with posts, comments, and author profiles"</code></pre>

          <h4>How Variables Change</h4>
          <ul>
            <li><code>{Entity}</code> = "Post" (for posts), "Comment" (for comments), "Author" (for authors)</li>
            <li><code>{Entities}</code> = "Posts", "Comments", "Authors"</li>
            <li>Same templates, different output!</li>
          </ul>

          <h4>Generated Files (Sample)</h4>
          <pre><code># Backend
Data/Entities/Post.cs
Data/Entities/Comment.cs
Data/Entities/Author.cs
API/Controllers/PostsController.cs
API/Controllers/CommentsController.cs

# Frontend
types/post.ts
components/PostList.tsx
components/CommentThread.tsx
components/AuthorProfile.tsx</code></pre>

          <h2>SubAgent Implementations</h2>

          <p>
            Now let's look at how the specialized subagents use these prompt templates and instructions to perform their specific tasks.
            Each agent specifies its preferred model based on the complexity and nature of its work.
          </p>

          <h3>Agent Examples with Model Specifications</h3>

          <div class="callout">
            <strong>üí° Model Assignment Pattern</strong><br />
            <p>Notice how each agent specifies the <code>model</code> property in its frontmatter. This allows you to optimize cost and performance by using:</p>
            <ul style="margin-bottom: 0;">
              <li><strong>Premium models</strong> (claude-sonnet-4.5) for complex reasoning tasks (orchestration, planning, coding, security)</li>
              <li><strong>Balanced models</strong> (gpt-4o, gpt-4.5-turbo) for analysis and design tasks</li>
              <li><strong>Fast models</strong> (gpt-4o-mini) for repetitive or simple tasks (testing, documentation)</li>
            </ul>
          </div>

          <h4>Coding Agent Example (.github/agents/coding.md)</h4>
          <pre><code>---
name: coding
description: Generates production-ready code following best practices and coding standards
model: claude-sonnet-4.5
user-invokable: false
instructions:
  - .github/instructions/fullstack-standards.md
  - .github/instructions/dotnet-standards.md
  - .github/instructions/react-standards.md
prompts:
  - .github/prompts/crud-api.md
  - .github/prompts/react-component.md
---

# Coding SubAgent

I generate clean, maintainable, production-ready code following established patterns.

## Responsibilities
- Generate backend .NET code (Controllers, Services, Entities, DTOs)
- Generate frontend React components (TypeScript, hooks, Redux)
- Apply coding standards from instruction files
- Use prompt templates for consistency
- Ensure proper error handling and validation</code></pre>

          <h4>Review Agent Example (.github/agents/review.md)</h4>
          <pre><code>---
name: review
description: Performs comprehensive code review for quality, best practices, and potential issues
model: gpt-4.5-turbo
user-invokable: false
instructions:
  - .github/instructions/fullstack-standards.md
---

# Review SubAgent

I analyze code for quality, correctness, and adherence to best practices.

## Review Checklist
- ‚úÖ SOLID principles adherence
- ‚úÖ Proper async/await usage
- ‚úÖ Error handling patterns
- ‚úÖ Naming conventions
- ‚úÖ Security vulnerabilities
- ‚úÖ Performance issues
- ‚úÖ Code duplication
- ‚úÖ Missing validations</code></pre>

          <h4>Testing Agent Example (.github/agents/testing.md)</h4>
          <pre><code>---
name: testing
description: Generates comprehensive unit and integration tests
model: gpt-4o-mini
user-invokable: false
instructions:
  - .github/instructions/fullstack-standards.md
prompts:
  - .github/prompts/testing-template.md
---

# Testing SubAgent

I create comprehensive test suites with high coverage.

## Test Generation
- xUnit tests for .NET backend
- Jest + React Testing Library for frontend
- Integration tests for API endpoints
- Mock external dependencies
- Aim for 80%+ code coverage
- Test both success and error paths</code></pre>

          <h4>Security Agent Example (.github/agents/security.md)</h4>
          <pre><code>---
name: security
description: Performs security analysis and vulnerability scanning
model: claude-sonnet-4.5
user-invokable: false
instructions:
  - .github/instructions/fullstack-standards.md
---

# Security SubAgent

I perform comprehensive security analysis to identify vulnerabilities.

## Security Checks
- üîí SQL injection vulnerabilities
- üîí Cross-Site Scripting (XSS)
- üîí Authentication/authorization flaws
- üîí Hardcoded secrets
- üîí Dependency vulnerabilities
- üîí CORS misconfigurations
- üîí Input validation gaps
- üîí Insecure cryptography</code></pre>

          <h3>Planning SubAgent (.github/agents/planning.md)</h3>
          <pre><code>---
name: planning
description: Creates comprehensive project plans for any feature based on user requirements
model: claude-sonnet-4.5
user-invokable: false
instructions:
  - .github/instructions/fullstack-standards.md
prompts:
  - .github/prompts/feature-template.md
---

# Planning SubAgent

I analyze feature requirements and create comprehensive project plans.
    response: vscode.ChatResponseStream,
    token: vscode.CancellationToken
  ): Promise<AgentResult> {
    
    response.markdown('Delegating to Planning Agent...\n');
    
    const result = await this.planningAgent.execute({
      projectType: 'fullstack-todo',
      requirements: context.requirements,
      constraints: ['RESTful API', 'React', 'Node.js', 'PostgreSQL']
    }, token);

    response.markdown('‚úÖ Planning complete:\n');
    response.markdown(`- Architecture: ${result.data.architecture}\n`);
    response.markdown(`- Tech Stack: ${result.data.techStack.join(', ')}\n`);
    response.markdown(`- Milestones: ${result.data.milestones.length}\n`);

    return result;
  }

  private async executeDesignPhase(
    plan: AgentResult,
    response: vscode.ChatResponseStream,
    token: vscode.CancellationToken
  ): Promise<AgentResult> {
    
    response.markdown('Delegating to Design Agent...\n');
    
    const result = await this.designAgent.execute({
      architecture: plan.data.architecture,
      requirements: plan.data.requirements
    }, token);

    response.markdown('‚úÖ Design complete:\n');
    response.markdown(`- Data Models: ${result.data.models.length}\n`);
    response.markdown(`- API Endpoints: ${result.data.endpoints.length}\n`);
    response.markdown(`- Components: ${result.data.components.length}\n`);

    // Create design documentation
    await this.createDesignDocs(result.data);

    return result;
  }

  private async executeCodingPhase(
    design: AgentResult,
    response: vscode.ChatResponseStream,
    token: vscode.CancellationToken
  ): Promise<AgentResult> {
    
    response.markdown('Delegating to Coding Agent...\n');
    
    const result = await this.codingAgent.execute({
      design: design.data,
      outputPath: 'src/'
    }, token);

    response.markdown('‚úÖ Implementation complete:\n');
    response.markdown(`- Files created: ${result.data.filesCreated.length}\n`);
    response.markdown(`- Lines of code: ${result.data.linesOfCode}\n`);

    return result;
  }

  private async executeReviewPhase(
    code: AgentResult,
    response: vscode.ChatResponseStream,
    token: vscode.CancellationToken
  ): Promise<AgentResult> {
    
    response.markdown('Delegating to Review Agent...\n');
    
    const result = await this.reviewAgent.execute({
      files: code.data.filesCreated,
      checkTypes: ['syntax', 'style', 'best-practices', 'complexity']
    }, token);

    response.markdown('‚úÖ Review complete:\n');
    response.markdown(`- Issues found: ${result.data.issues.length}\n`);
    response.markdown(`- Suggestions: ${result.data.suggestions.length}\n`);
    
    if (result.data.issues.length > 0) {
      response.markdown('\n‚ö†Ô∏è Issues to address:\n');
      result.data.issues.slice(0, 5).forEach((issue: any) => {
        response.markdown(`  - ${issue.severity}: ${issue.message}\n`);
      });
    }

    return result;
  }

  private async executeTestingPhase(
    code: AgentResult,
    response: vscode.ChatResponseStream,
    token: vscode.CancellationToken
  ): Promise<AgentResult> {
    
    response.markdown('Delegating to Testing Agent...\n');
    
    const result = await this.testingAgent.execute({
      files: code.data.filesCreated,
      testTypes: ['unit', 'integration'],
      framework: 'jest'
    }, token);

    response.markdown('‚úÖ Testing complete:\n');
    response.markdown(`- Tests generated: ${result.data.testsGenerated}\n`);
    response.markdown(`- Coverage: ${result.data.coverage}%\n`);
    response.markdown(`- Test files: ${result.data.testFiles.length}\n`);

    return result;
  }

  private async executeSecurityPhase(
    code: AgentResult,
    response: vscode.ChatResponseStream,
    token: vscode.CancellationToken
  ): Promise<AgentResult> {
    
    response.markdown('Delegating to Security Agent...\n');
    
    const result = await this.securityAgent.execute({
      files: code.data.filesCreated,
      checks: [
        'injection',
        'authentication',
        'authorization',
        'secrets',
        'dependencies'
      ]
    }, token);

    response.markdown('‚úÖ Security analysis complete:\n');
    response.markdown(`- Vulnerabilities: ${result.data.vulnerabilities.length}\n`);
    response.markdown(`- Security score: ${result.data.score}/100\n`);
    
    if (result.data.vulnerabilities.length > 0) {
      response.markdown('\nüîê Security recommendations:\n');
      result.data.vulnerabilities.slice(0, 3).forEach((vuln: any) => {
        response.markdown(`  - ${vuln.severity}: ${vuln.description}\n`);
      });
    }

    return result;
  }

  private async executeInfrastructurePhase(
    code: AgentResult,
    response: vscode.ChatResponseStream,
    token: vscode.CancellationToken
  ): Promise<AgentResult> {
    
    response.markdown('Delegating to Infrastructure Agent...\n');
    
    const result = await this.infrastructureAgent.execute({
      application: code.data,
      platform: 'docker',
      cicd: 'github-actions'
    }, token);

    response.markdown('‚úÖ Infrastructure setup complete:\n');
    response.markdown(`- Docker files: ${result.data.dockerFiles.length}\n`);
    response.markdown(`- CI/CD pipelines: ${result.data.pipelines.length}\n`);
    response.markdown(`- Configuration files: ${result.data.configFiles.length}\n`);

    return result;
  }

  private generateSummary(
    response: vscode.ChatResponseStream,
    results: any
  ): void {
    response.markdown('\n\n---\n\n');
    response.markdown('# üéâ TODO Application Complete!\n\n');
    
    response.markdown('## üìä Summary\n\n');
    response.markdown('| Phase | Status | Output |\n');
    response.markdown('|-------|--------|--------|\n');
    response.markdown(`| Planning | ‚úÖ | ${results.plan.data.milestones.length} milestones |\n`);
    response.markdown(`| Design | ‚úÖ | ${results.design.data.models.length} models, ${results.design.data.endpoints.length} endpoints |\n`);
    response.markdown(`| Coding | ‚úÖ | ${results.code.data.filesCreated.length} files |\n`);
    response.markdown(`| Review | ${results.reviewResult.data.issues.length === 0 ? '‚úÖ' : '‚ö†Ô∏è'} | ${results.reviewResult.data.issues.length} issues |\n`);
    response.markdown(`| Testing | ‚úÖ | ${results.testResult.data.coverage}% coverage |\n`);
    response.markdown(`| Security | ${results.securityResult.data.vulnerabilities.length === 0 ? '‚úÖ' : '‚ö†Ô∏è'} | ${results.securityResult.data.score}/100 score |\n`);
    response.markdown(`| Infrastructure | ‚úÖ | Docker + CI/CD ready |\n`);
    
    response.markdown('\n## üöÄ Next Steps\n\n');
    response.markdown('1. Review generated code in `src/` directory\n');
    response.markdown('2. Run tests: `npm test`\n');
    response.markdown('3. Start development server: `npm run dev`\n');
    response.markdown('4. Address any review comments or security issues\n');
    response.markdown('5. Deploy using: `docker-compose up`\n');
  }

  private parseRequirements(prompt: string): string[] {
    // Parse user requirements from prompt
    return [
      'User authentication',
      'CRUD operations for tasks',
      'Task categories and tags',
      'Due dates and priorities',
      'Search and filter functionality'
    ];
  }

  private async createDesignDocs(design: any): Promise<void> {
    // Create design documentation files
    // Implementation details...
  }
}

// Register the agent
export function activate(context: vscode.ExtensionContext) {
  const orchestrator = new OrchestratorAgent();
  
  const agent = vscode.chat.createChatParticipant(
    'todoapp.orchestrator',
    async (request, chatContext, response, token) => {
      
      if (request.command === 'build') {
        await orchestrator.buildTodoApp(request, chatContext, response, token);
      } else {
        response.markdown('Available commands:\n');
        response.markdown('- `/build` - Build complete TODO application\n');
        response.markdown('- `/feature` - Add a new feature\n');
        response.markdown('- `/fix` - Fix a bug\n');
        response.markdown('- `/deploy` - Deploy application\n');
      }
    }
  );

  agent.iconPath = new vscode.ThemeIcon('rocket');
  context.subscriptions.push(agent);
}</code></pre>

          <h2>Implementing SubAgents</h2>
          
          <h3>Planning Agent (.github/agents/planning.md)</h3>
          <pre><code>---
name: planning
description: Creates comprehensive technical plans for application development
user-invokable: false
---

# Planning Agent

I am a specialized planning agent. I create detailed technical plans for software projects.

**Note:** I have `user-invokable: false`, which means developers cannot invoke me directly. Only other agents (like the orchestrator) can delegate tasks to me.

## My Expertise

- System architecture design (Clean Architecture, Layered Architecture, Microservices)
- Technology stack selection and justification
- Database schema planning
- API design strategies (REST, GraphQL)
- Project milestone planning
- Risk assessment and mitigation strategies

## Planning Process

When invoked by the orchestrator, I will:

1. **Analyze Requirements** - Review all user requirements and constraints
2. **Design Architecture** - Recommend appropriate architectural patterns
3. **Select Technology Stack** - Choose optimal technologies with justification
4. **Plan Database** - Outline database schema and relationships
5. **Define API Strategy** - Plan RESTful endpoints and data contracts
6. **Create Milestones** - Break down development into achievable phases
7. **Assess Risks** - Identify potential challenges and mitigation strategies

## Technology Stack for TODO App

For a .NET 10 and React.js TODO application, I recommend:

### Backend (.NET 10)
- **Framework:** ASP.NET Core 10.0 Web API
- **ORM:** Entity Framework Core 10.0
- **Database:** SQL Server 2022 or PostgreSQL 16
- **Authentication:** ASP.NET Core Identity + JWT Bearer tokens
- **API Documentation:** Swashbuckle (Swagger/OpenAPI 3.0)
- **Validation:** FluentValidation
- **Logging:** Serilog
- **Testing:** xUnit, Moq, FluentAssertions

### Frontend (React.js)
- **Framework:** React 18.x with TypeScript 5.x
- **State Management:** Redux Toolkit or Zustand
- **UI Library:** Material-UI (MUI) or Tailwind CSS
- **HTTP Client:** Axios with TypeScript support
- **Form Handling:** React Hook Form
- **Testing:** Jest + React Testing Library
- **Build Tool:** Vite

### Architecture
- **Pattern:** Clean Architecture (3-layer)
  - **API Layer:** Controllers, DTOs, Middleware
  - **Business Layer:** Services, Domain Models, Interfaces
  - **Data Layer:** DbContext, Repositories, Migrations

### Database Schema
```csharp
// User Entity
public class User
{
    public Guid Id { get; set; }
    public string Email { get; set; }
    public string PasswordHash { get; set; }
    public DateTime CreatedAt { get; set; }
    public ICollection<TodoTask> Tasks { get; set; }
}

// TodoTask Entity
public class TodoTask
{
    public Guid Id { get; set; }
    public string Title { get; set; }
    public string Description { get; set; }
    public bool IsCompleted { get; set; }
    public DateTime? DueDate { get; set; }
    public Priority Priority { get; set; }
    public Guid UserId { get; set; }
    public User User { get; set; }
    public Guid? CategoryId { get; set; }
    public Category Category { get; set; }
    public ICollection<Tag> Tags { get; set; }
}

// Category Entity
public class Category
{
    public Guid Id { get; set; }
    public string Name { get; set; }
    public string Color { get; set; }
    public Guid UserId { get; set; }
    public User User { get; set; }
}

// Tag Entity
public class Tag
{
    public Guid Id { get; set; }
    public string Name { get; set; }
    public ICollection<TodoTask> Tasks { get; set; }
}
```

## Development Milestones

1. **Project Setup** (Day 1)
   - Initialize .NET 10 Web API project
   - Setup React with Vite
   - Configure ESLint, Prettier
   - Setup Git repository

2. **Authentication** (Days 2-3)
   - Implement user registration
   - Setup JWT authentication
   - Create login/logout endpoints
   - Build auth UI components

3. **CRUD Operations** (Days 4-6)
   - Implement task CRUD endpoints
   - Create EF Core migrations
   - Build React components for task management
   - Implement category and tag management

4. **Testing & Quality** (Days 7-8)
   - Write unit tests (xUnit + Jest)
   - Integration tests for API
   - Setup code coverage reporting
   - Code review and refactoring

5. **Deployment** (Days 9-10)
   - Docker containerization
   - CI/CD pipeline setup
   - Production configuration
   - Documentation

## Risk Assessment

| Risk | Impact | Mitigation |
|------|--------|------------|
| Authentication vulnerabilities | High | Use ASP.NET Core Identity, validate JWT properly |
| SQL injection | High | Use EF Core parameterized queries, never raw SQL |
| CORS issues | Medium | Configure CORS policy correctly for React app |
| State management complexity | Medium | Use Redux Toolkit for predictable state |
| Database performance | Medium | Add proper indexes, use async queries |

## Output Format

I provide results in structured JSON format for the orchestrator to consume:

```json
{
  "architecture": "Clean Architecture (3-layer)",
  "techStack": {
    "backend": [".NET 10", "ASP.NET Core", "EF Core", "SQL Server"],
    "frontend": ["React 18", "TypeScript", "Redux Toolkit", "Material-UI"]
  },
  "database": "SQL Server with EF Core migrations",
  "api": "RESTful API with Swagger/OpenAPI 3.0",
  "milestones": ["Project Setup", "Authentication", "CRUD Operations", "Testing", "Deployment"],
  "risks": ["Authentication vulnerabilities", "SQL injection", "CORS configuration"]
}
```</code></pre>

          <h3>Design Agent (.github/agents/design.md)</h3>
          <pre><code>---
name: design
description: Designs data models, API endpoints, and React component architecture
user-invokable: false
---

# Design Agent

I am a specialized design agent focusing on data modeling, API design, and frontend architecture.

**Note:** I have `user-invokable: false`, which means I can only be invoked by other agents, not directly by developers.

## My Expertise

- **Data Modeling:** C# entities with EF Core relationships
- **API Design:** RESTful endpoints with proper HTTP verbs and status codes
- **Frontend Architecture:** React component hierarchies and state management
- **Database Schema:** Table design, indexes, constraints, and migrations
- **API Documentation:** OpenAPI/Swagger specifications

## Design Process

### 1. Data Models (C# Entities)

Design C# entity classes for Entity Framework Core with:

**User Entity:**
- Guid Id (Primary Key)
- Email (required, max 256 chars, EmailAddress validation)
- PasswordHash (required, never expose in DTOs)
- CreatedAt, UpdatedAt timestamps
- Navigation properties to Tasks and Categories (one-to-many)

**TodoTask Entity:**
- Guid Id (Primary Key)
- Title (required, max 200 chars)
- Description (optional, max 2000 chars)
- IsCompleted (boolean)
- DueDate (nullable DateTime)
- Priority (enum: Low, Medium, High, Urgent)
- CreatedAt, CompletedAt timestamps
- UserId (Foreign Key, required)
- CategoryId (Foreign Key, optional)
- Navigation properties to User, Category, and Tags (many-to-many)

**Category Entity:**
- Guid Id (Primary Key)
- Name (required, max 100 chars)
- Color (hex color code, 7 chars)
- UserId (Foreign Key)
- Navigation property to Tasks (one-to-many)

**Tag Entity:**
- Guid Id (Primary Key)
- Name (required, max 50 chars)
- Navigation property to Tasks (many-to-many via join table)

**Design Guidelines:**
- Use Guid for all IDs (better for distributed systems)
- Apply Data Annotations ([Required], [MaxLength], etc.)
- Use virtual keyword for navigation properties (lazy loading)
- Define proper foreign key relationships
- Use nullable types appropriately (DateTime?, Guid?)
- Create enum for Priority levels

### 2. API Endpoints

I design RESTful API endpoints following ASP.NET Core conventions:

#### Authentication Endpoints
```
POST   /api/auth/register          - Register new user
POST   /api/auth/login             - Login and get JWT token
POST   /api/auth/refresh           - Refresh access token
POST   /api/auth/logout            - Logout user
GET    /api/auth/me                - Get current user profile
```

#### Task Endpoints (Requires Authorization)
```
GET    /api/tasks                  - Get all tasks for current user
GET    /api/tasks/{id}             - Get task by ID
POST   /api/tasks                  - Create new task
PUT    /api/tasks/{id}             - Update task
DELETE /api/tasks/{id}             - Delete task
PATCH  /api/tasks/{id}/complete    - Mark task as complete
GET    /api/tasks/search?q={query} - Search tasks
```

#### Category Endpoints
```
GET    /api/categories             - Get all categories
GET    /api/categories/{id}        - Get category by ID
POST   /api/categories             - Create category
PUT    /api/categories/{id}        - Update category
DELETE /api/categories/{id}        - Delete category
```

#### Tag Endpoints
```
GET    /api/tags                   - Get all tags
POST   /api/tags                   - Create tag
DELETE /api/tags/{id}              - Delete tag
```

### 3. DTOs (Data Transfer Objects)

Create record types for clean, immutable DTOs:

**Authentication DTOs:**
- RegisterRequest: Email, Password, ConfirmPassword
- LoginRequest: Email, Password
- AuthResponse: Token, RefreshToken, ExpiresAt, UserDto
- UserDto: Id, Email, CreatedAt (never include PasswordHash)

**Task DTOs:**
- CreateTaskRequest: Title, Description, DueDate, Priority, CategoryId, Tags
- UpdateTaskRequest: Title, Description, DueDate, Priority, CategoryId, Tags  
- TaskDto: Id, Title, Description, IsCompleted, DueDate, Priority, CreatedAt, Category, Tags
- TaskListDto: Simplified version for list views (fewer properties)

**Category/Tag DTOs:**
- CategoryDto: Id, Name, Color
- TagDto: Id, Name

**DTO Best Practices:**
- Use C# record types for immutability
- Never expose entities directly to API
- Exclude sensitive data (passwords, internal IDs)
- Use different DTOs for create/update/read operations
- Apply validation attributes to request DTOs

### 4. React Component Architecture

Design a hierarchical component structure:

**Root Level:**
- App: Main entry point
- AuthProvider: Context for authentication state
- ThemeProvider: Context for dark/light theme
- Router: React Router setup

**Public Routes (No Auth Required):**
- LoginPage: Email/password form with validation
- RegisterPage: User registration form

**Private Routes (Auth Required):**
- DashboardLayout: Main layout with Header, Sidebar, MainContent

**Layout Components:**
- Header: Logo, SearchBar, UserMenu
- Sidebar: CategoryList, TagFilter
- MainContent: Route-based page rendering

**Page Components:**
- TaskListPage: Shows all tasks with filters
- TaskDetailPage: View/edit single task
- SettingsPage: User preferences and categories

**Feature Components:**
- TaskCard: Display individual task with actions
- TaskForm: Create/edit task form with validation
- TaskFilters: Filter by status, priority, date range
- CategoryList: Display and select categories
- TagFilter: Multi-select tag filtering

**Component Design Principles:**
- Keep components small and focused (Single Responsibility)
- Use TypeScript interfaces for all props
- Implement proper prop validation
- Use React hooks (useState, useEffect, useContext)
- Lift state up when needed
- Use custom hooks for reusable logic
- Implement error boundaries for resilience

### 5. State Management (Redux Toolkit)

Define Redux slices for state management:

**Auth Slice:**
- User, Token, IsAuthenticated, IsLoading states
- Actions: login, logout, refreshToken, setUser
- Async thunks for API calls

**Tasks Slice:**
- Tasks array, FilteredTasks, SelectedTask states
- Filters (status, priority, category, search query)
- IsLoading and Error states
- Actions: fetchTasks, createTask, updateTask, deleteTask, setFilters
- Selectors for filtered and sorted tasks

**Categories Slice:**
- Categories array, SelectedCategoryId
- Actions: fetchCategories, createCategory, updateCategory, deleteCategory

**Redux Best Practices:**
- Use Redux Toolkit (createSlice, createAsyncThunk)
- Define TypeScript types for all state
- Use createSelector for memoized selectors
- Handle loading and error states
- Normalize state shape when needed
- Keep business logic in thunks, not components

## Design Principles

1. **Separation of Concerns:** Clear boundaries between layers
2. **DRY (Don't Repeat Yourself):** Reusable components and services
3. **Single Responsibility:** Each component/class has one purpose
4. **Type Safety:** Strong typing with C# and TypeScript
5. **RESTful Conventions:** Proper HTTP methods and status codes
6. **Security First:** Authentication on all protected endpoints

## Output Format

I provide structured design specifications for the orchestrator:

```json
{
  "models": [
    {"name": "User", "properties": ["Id", "Email", "PasswordHash"]},
    {"name": "TodoTask", "properties": ["Id", "Title", "Description", "IsCompleted"]},
    {"name": "Category", "properties": ["Id", "Name", "Color"]},
    {"name": "Tag", "properties": ["Id", "Name"]}
  ],
  "endpoints": [
    {"method": "POST", "path": "/api/auth/register"},
    {"method": "GET", "path": "/api/tasks"},
    {"method": "POST", "path": "/api/tasks"}
  ],
  "components": [
    {"name": "TaskCard", "type": "component"},
    {"name": "TaskForm", "type": "component"},
    {"name": "DashboardLayout", "type": "layout"}
  ]
}
```</code></pre>

          <h3>Security Agent (.github/agents/security.md)</h3>
          <pre><code>---
name: security
description: Performs comprehensive security analysis on .NET and React applications
user-invokable: false
---

# Security Agent

I am a specialized security agent focused on identifying vulnerabilities in .NET 10 and React.js applications.

**Note:** I have `user-invokable: false`, which means I can only be invoked by other agents during the development workflow.

## Security Checks

### 1. SQL Injection Prevention (.NET)

**What I Check:**
- Use of raw SQL queries instead of parameterized queries
- String concatenation in SQL statements
- Unsafe use of `FromSqlRaw()` in EF Core

**Good Practice:**
- Always use EF Core LINQ queries (automatically parameterized)
- If using FromSqlRaw, use parameterized placeholders {0}, {1}
- Never concatenate user input into SQL strings
- Avoid FromSqlInterpolated with user input
- Use stored procedures with parameters if needed

**Examples to Check:**
- ‚úÖ GOOD: `.Where(t => t.UserId == userId)`
- ‚úÖ GOOD: `FromSqlRaw("SELECT * FROM Tasks WHERE Id = {0}", id)`
- ‚ùå BAD: `FromSqlRaw($"SELECT * FROM Tasks WHERE Id = '{id}'")`
- ‚ùå BAD: String concatenation in queries

### 2. Authentication & Authorization (.NET)

**What I Check:**
- Proper JWT token validation
- Secure password hashing (bcrypt, PBKDF2)
- Authorization attributes on controllers
- Token expiration settings

**Good Practice:**
- Use ASP.NET Core Identity for password hashing (handles salt and iterations)
- Use PBKDF2 or bcrypt algorithms (not plain SHA)
- Apply [Authorize] attribute to all protected controllers/actions
- Configure JWT with proper validation parameters
- Set appropriate token expiration (15-60 minutes for access tokens)
- Implement refresh tokens for extended sessions
- Validate Issuer, Audience, Lifetime, and SigningKey
- Use strong secret keys (at least 256 bits)
- Store secrets in configuration, never hardcoded

**What to Check:**
- All API controllers have [Authorize] attribute
- Password hashing uses ASP.NET Identity or strong algorithm
- JWT configuration validates all required parameters
- Token expiration is reasonable (not years)
- Refresh token mechanism exists

### 3. XSS Prevention (React)

**What I Check:**
- Use of `dangerouslySetInnerHTML`
- Unsafe rendering of user input
- Missing input sanitization

**Good Practice:**
- Trust React's automatic escaping (use {variable} syntax)
- Avoid dangerouslySetInnerHTML unless absolutely necessary
- If HTML rendering is required, sanitize with DOMPurify
- Validate and sanitize user input on both frontend and backend
- Use Content Security Policy (CSP) headers
- Encode output appropriately for context (HTML, JavaScript, URL)

**What to Check:**
- Search for dangerouslySetInnerHTML usage
- Verify sanitization if innerHTML is used
- Check that user input is not directly rendered as HTML
- Ensure no eval() or Function() with user input
- Verify CSP headers are configured

### 4. Secrets Management

**What I Check:**
- Hardcoded API keys, passwords, or tokens
- Sensitive data in appsettings.json committed to Git
- Missing .env files in .gitignore

**Good Practice (.NET):**
- Use IConfiguration to read secrets from environment or user secrets
- Development: Use User Secrets (`dotnet user-secrets set "Key" "Value"`)
- Production: Use environment variables or Azure Key Vault
- Never commit appsettings.json with real secrets
- Add appsettings.Development.json to .gitignore if it has secrets

**Good Practice (React):**
- Use environment variables with VITE_ prefix
- Store in .env.local file (add to .gitignore)
- Different .env files for dev/staging/production
- Never commit .env files with real API keys

**What to Check:**
- Search for hardcoded strings like API keys, passwords, tokens
- Verify .gitignore includes .env, appsettings.Development.json
- Check that secrets use configuration/environment variables
- Look for Connection strings, JWT secrets, API keys

### 5. CORS Configuration (.NET)

**What I Check:**
- CORS policy configuration
- Allow all origins (*) in production
- Missing CORS for React app

**Good Practice:**
- Define specific CORS policy with allowed origins
- Use configuration for allowed origins (different per environment)
- Development: Allow localhost:3000, localhost:5173 (Vite)
- Production: Allow only production domain
- Use AllowCredentials() if cookies/auth headers needed
- Avoid AllowAnyOrigin() in production

**What to Check:**
- CORS policy is configured and specific
- WithOrigins() specifies actual domains, not "*"
- AllowedOrigins comes from configuration
- Policy is applied with app.UseCors()
- No AllowAnyOrigin() with AllowCredentials() (invalid)

### 6. HTTPS Enforcement

**What I Check:**
- HTTPS redirection enabled
- HSTS headers configured
- Secure cookies (HttpOnly, Secure, SameSite)

**Good Practice:**
- Enable UseHttpsRedirection() middleware
- Enable UseHsts() for HTTP Strict Transport Security
- Add security headers: X-Content-Type-Options, X-Frame-Options, X-XSS-Protection
- Consider Content-Security-Policy header
- Use [RequireHttps] attribute on controllers
- Ensure HTTPS in production environment

**What to Check:**
- UseHttpsRedirection() is called in Configure()
- UseHsts() is enabled (especially for production)
- Security headers are added
- No HTTP-only endpoints in production
- SSL certificate is valid and not expired

### 7. Dependency Vulnerabilities

**What I Check:**
- Run `dotnet list package --vulnerable`
- Run `npm audit` for React dependencies
- Outdated packages with known CVEs

**Commands to Run:**
- .NET: `dotnet list package --vulnerable --include-transitive`
- React: `npm audit` or `npm audit fix`
- Update packages regularly
- Review dependency updates before applying

**What to Check:**
- Run vulnerability scans on both .NET and npm packages
- Review audit results for HIGH and CRITICAL issues
- Update vulnerable packages to patched versions
- Check for transitive dependencies with issues
- Consider using Dependabot for automated updates

### 8. Input Validation (.NET)

**What I Check:**
- Missing model validation attributes
- No validation on API endpoints
- Unsafe deserialization

**Good Practice:**
- Apply validation attributes to DTOs ([Required], [MaxLength], [Range], etc.)
- Check ModelState.IsValid in controller actions
- Return BadRequest(ModelState) for validation errors
- Use FluentValidation for complex validation rules
- Validate on both client (React) and server (.NET)
- Sanitize input before processing
- Use appropriate status codes (400 for validation errors)

**What to Check:**
- DTOs have validation attributes
- Controllers check ModelState.IsValid
- Proper error responses for invalid input
- No unsafe deserialization
- Input length limits are enforced

## Security Score Calculation

| Check | Weight | Penalty if Failed |
|-------|--------|-------------------|
| SQL Injection | Critical | -30 points |
| Authentication Issues | Critical | -25 points |
| Hardcoded Secrets | Critical | -30 points |
| XSS Vulnerabilities | High | -20 points |
| CORS Misconfiguration | Medium | -15 points |
| Missing HTTPS | High | -20 points |
| Input Validation | Medium | -15 points |
| Vulnerable Dependencies | Medium | -10 points |

**Scoring:**
- 90-100: Excellent ‚úÖ
- 70-89: Good ‚ö†Ô∏è
- 50-69: Fair ‚ö†Ô∏è
- Below 50: Poor ‚ùå

## Recommendations

I always provide security recommendations:

1. **Enable HTTPS Everywhere** - Use HTTPS in development and production
2. **Implement Rate Limiting** - Protect against brute force attacks
3. **Use Security Headers** - Add X-Frame-Options, CSP, etc.
4. **Enable Logging** - Log authentication attempts and failures
5. **Regular Updates** - Keep dependencies up to date
6. **Code Reviews** - Have security-focused code reviews
7. **Security Testing** - Include security tests in CI/CD
8. **Principle of Least Privilege** - Grant minimum necessary permissions

## Output Format

```json
{
  "vulnerabilities": [
    {
      "severity": "HIGH",
      "type": "SQL Injection",
      "description": "Raw SQL concatenation detected",
      "file": "TaskRepository.cs",
      "line": 45,
      "recommendation": "Use parameterized queries or EF Core LINQ"
    }
  ],
  "score": 85,
  "grade": "Good",
  "recommendations": [
    "Enable HTTPS redirection",
    "Implement rate limiting",
    "Update vulnerable npm packages"
  ]
}
```</code></pre>

          <h2>Usage Example</h2>
          
          <h3>Building the Complete Application</h3>
          
          <pre><code>// In VS Code Chat
@orchestrator /build

# The orchestrator will coordinate all subagents:
# Note: You can only invoke @orchestrator directly (user-invokable: true)
# All other agents have user-invokable: false and work behind the scenes

# 1. ‚úÖ Create project plan with @planning (invoked by orchestrator)
# 2. ‚úÖ Design data models and APIs with @design (invoked by orchestrator)
# 3. ‚úÖ Generate .NET 10 and React code with @coding (invoked by orchestrator)  
# 4. ‚úÖ Review code quality with @review (invoked by orchestrator)
# 5. ‚úÖ Create xUnit and Jest tests with @testing (invoked by orchestrator)
# 6. ‚úÖ Perform security audit with @security (invoked by orchestrator)
# 7. ‚úÖ Setup Docker and CI/CD with @infrastructure (invoked by orchestrator)

# Output:
# üéâ TODO Application Complete!
#
# üìä Summary
# | Phase          | Status | Output                    |
# |----------------|--------|---------------------------|
# | Planning       | ‚úÖ     | Clean Architecture, .NET 10 + React |
# | Design         | ‚úÖ     | 4 C# entities, 15 API endpoints |
# | Coding         | ‚úÖ     | 52 files (.NET + React)  |
# | Review         | ‚úÖ     | 0 critical issues         |
# | Testing        | ‚úÖ     | 92% coverage (xUnit + Jest) |
# | Security       | ‚úÖ     | 95/100 score              |
# | Infrastructure | ‚úÖ     | Docker + GitHub Actions   |
#
# üöÄ Next Steps
# 1. Review generated code in `src/` directory
# 2. Run backend: `cd TodoApi && dotnet run`
# 3. Run frontend: `cd todo-app-ui && npm run dev`
# 4. Run tests: `dotnet test && npm test`
# 5. Deploy: `docker-compose up`</code></pre>

          <h3>Adding a New Feature</h3>
          
          <pre><code>@orchestrator /feature add task sharing between users

# Orchestrator delegates to relevant agents:
# - @planning: Create feature plan (shared tasks table design)
# - @design: Update C# models and API endpoints (sharing permissions)
# - @coding: Implement sharing logic (.NET service + React components)
# - @testing: Add xUnit and Jest tests for sharing
# - @security: Check sharing permissions and authorization
# - @review: Validate implementation

# Note: You cannot invoke @planning, @design, etc. directly
# Only @orchestrator has user-invokable: true</code></pre>

          <h2>Technology Stack Summary</h2>
          
          <table class="table table-striped">
            <thead>
              <tr>
                <th>Layer</th>
                <th>Technology</th>
                <th>Purpose</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Backend</strong></td>
                <td>.NET 10, ASP.NET Core</td>
                <td>Web API with RESTful endpoints</td>
              </tr>
              <tr>
                <td><strong>ORM</strong></td>
                <td>Entity Framework Core 10</td>
                <td>Database access with migrations</td>
              </tr>
              <tr>
                <td><strong>Database</strong></td>
                <td>SQL Server 2022</td>
                <td>Relational data storage</td>
              </tr>
              <tr>
                <td><strong>Authentication</strong></td>
                <td>ASP.NET Identity + JWT</td>
                <td>User auth and token management</td>
              </tr>
              <tr>
                <td><strong>Frontend</strong></td>
                <td>React 18 + TypeScript</td>
                <td>Modern UI with type safety</td>
              </tr>
              <tr>
                <td><strong>State Mgmt</strong></td>
                <td>Redux Toolkit</td>
                <td>Predictable state management</td>
              </tr>
              <tr>
                <td><strong>UI Library</strong></td>
                <td>Material-UI</td>
                <td>Component library and styling</td>
              </tr>
              <tr>
                <td><strong>Testing (.NET)</strong></td>
                <td>xUnit, Moq, FluentAssertions</td>
                <td>Backend unit/integration tests</td>
              </tr>
              <tr>
                <td><strong>Testing (React)</strong></td>
                <td>Jest, React Testing Library</td>
                <td>Frontend component tests</td>
              </tr>
              <tr>
                <td><strong>Containerization</strong></td>
                <td>Docker, Docker Compose</td>
                <td>Application packaging</td>
              </tr>
              <tr>
                <td><strong>CI/CD</strong></td>
                <td>GitHub Actions</td>
                <td>Automated build and deployment</td>
              </tr>
            </tbody>
          </table>

          <h2>Usage Example</h2>
          
          <h3>Building the Complete Application</h3>
          
          <pre><code>// In VS Code Chat
@orchestrator /build TODO Application

# The orchestrator will:
# 1. ‚úÖ Create project plan with Planning Agent
# 2. ‚úÖ Design data models and APIs with Design Agent
# 3. ‚úÖ Generate code with Coding Agent
# 4. ‚úÖ Review code quality with Review Agent
# 5. ‚úÖ Create tests with Testing Agent
# 6. ‚úÖ Perform security audit with Security Agent
# 7. ‚úÖ Setup infrastructure with Infrastructure Agent

# Output:
# üéâ TODO Application Complete!
#
# üìä Summary
# | Phase          | Status | Output                    |
# |----------------|--------|---------------------------|
# | Planning       | ‚úÖ     | 5 milestones              |
# | Design         | ‚úÖ     | 4 models, 12 endpoints    |
# | Coding         | ‚úÖ     | 45 files                  |
# | Review         | ‚ö†Ô∏è     | 3 issues                  |
# | Testing        | ‚úÖ     | 87% coverage              |
# | Security       | ‚úÖ     | 95/100 score              |
# | Infrastructure | ‚úÖ     | Docker + CI/CD ready      |
#
# üöÄ Next Steps
# 1. Review generated code in `src/` directory
# 2. Run tests: `npm test`
# 3. Start development server: `npm run dev`
# 4. Deploy using: `docker-compose up`</code></pre>

          <h3>Adding a New Feature</h3>
          
          <pre><code>@orchestrator /feature add task sharing between users

# Orchestrator delegates to relevant agents:
# - Planning: Create feature plan
# - Design: Update models and APIs
# - Coding: Implement sharing logic
# - Testing: Add feature tests
# - Security: Check sharing permissions
# - Review: Validate implementation</code></pre>

          <h2>Execution Flow Diagram</h2>
          
          <div class="mermaid">
%%{ init: { "theme": "base", "fontFamily": "Segoe UI Semibold", "fontSize": "18px" }}%%
sequenceDiagram
    participant Dev as Developer
    participant Orch as @orchestrator<br/>(user-invokable: true)
    participant Plan as @planning<br/>(user-invokable: false)
    participant Design as @design<br/>(user-invokable: false)
    participant Code as @coding<br/>(user-invokable: false)
    participant Test as @testing<br/>(user-invokable: false)
    participant Sec as @security<br/>(user-invokable: false)
    participant Infra as @infrastructure<br/>(user-invokable: false)
    
    Dev->>Orch: @orchestrator /build
    Note over Orch: Orchestrator coordinates workflow
    
    Orch->>Plan: Create .NET 10 + React plan
    Plan-->>Orch: Clean Architecture + Milestones
    
    Orch->>Design: Design C# models & APIs
    Design-->>Orch: EF Core entities + REST endpoints
    
    Orch->>Code: Generate .NET & React code
    Code-->>Orch: Controllers, Services, Components
    
    par Parallel Quality Checks
        Orch->>Test: Generate xUnit + Jest tests
        Test-->>Orch: Test suite (92% coverage)
    and
        Orch->>Sec: Security audit (.NET + React)
        Sec-->>Orch: Security report (95/100)
    end
    
    Orch->>Infra: Setup Docker + CI/CD
    Infra-->>Orch: Dockerfiles + GitHub Actions
    
    Orch-->>Dev: Complete .NET 10 + React TODO app
    Note over Dev: All subagents are user-invokable: false<br/>Only orchestrator is directly accessible
          </div>

          <h2>Benefits of This Approach</h2>
          
          <table class="table table-striped">
            <thead>
              <tr>
                <th>Benefit</th>
                <th>Description</th>
                <th>Impact</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Markdown Simplicity</strong></td>
                <td>Define agents in simple .md files with frontmatter</td>
                <td>Lower barrier to entry, easier to maintain</td>
              </tr>
              <tr>
                <td><strong>user-invokable Control</strong></td>
                <td>Explicitly control which agents users can invoke</td>
                <td>Better encapsulation and user experience</td>
              </tr>
              <tr>
                <td><strong>Separation of Concerns</strong></td>
                <td>Each agent focuses on specific domain (.NET/React/Security)</td>
                <td>Better quality, specialized expertise</td>
              </tr>
              <tr>
                <td><strong>Scalability</strong></td>
                <td>Add new .md agents without changing orchestrator</td>
                <td>Extensible architecture</td>
              </tr>
              <tr>
                <td><strong>Reusability</strong></td>
                <td>SubAgents work independently across projects</td>
                <td>Use same agents for multiple apps</td>
              </tr>
              <tr>
                <td><strong>Quality Assurance</strong></td>
                <td>Automated review, xUnit/Jest testing, security checks</td>
                <td>Higher code quality, fewer bugs</td>
              </tr>
              <tr>
                <td><strong>Technology Best Practices</strong></td>
                <td>.NET 10 with EF Core, React with TypeScript</td>
                <td>Modern, type-safe, performant stack</td>
              </tr>
              <tr>
                <td><strong>Consistency</strong></td>
                <td>Standard process for every .NET + React project</td>
                <td>Predictable outcomes</td>
              </tr>
            </tbody>
          </table>

          <h2>Best Practices</h2>
          
          <div class="callout">
            <strong>‚úÖ Do:</strong>
            <ul style="margin-bottom: 0;">
              <li>Use markdown files (.md) for simple, declarative agent definitions</li>
              <li>Set user-invokable: false for subagents to hide internal implementation</li>
              <li>Set user-invokable: true only for top-level orchestrator agents</li>
              <li>Keep each agent focused on a single technology or responsibility</li>
              <li>Use .NET 10 best practices (async/await, dependency injection, EF Core)</li>
              <li>Use React best practices (TypeScript, hooks, component composition)</li>
              <li>Include comprehensive instructions in agent markdown content</li>
              <li>Document agent capabilities and expected outputs clearly</li>
              <li>Version control your .github/agents folder</li>
              <li>Test agent workflows end-to-end</li>
            </ul>
          </div>
          
          <br />
          
          <div class="callout">
            <strong>‚ùå Don't:</strong>
            <ul style="margin-bottom: 0;">
              <li>Make all agents user-invokable: true (overwhelming for users)</li>
              <li>Create circular dependencies between agents</li>
              <li>Mix .NET and Node.js in the same backend (choose one)</li>
              <li>Hard-code agent responses (leverage LLM capabilities)</li>
              <li>Mix concerns across multiple agents (planning shouldn't code)</li>
              <li>Skip security checks in automated workflows</li>
              <li>Commit secrets or API keys in agent markdown files</li>
              <li>Forget to update agent descriptions when changing behavior</li>
            </ul>
          </div>

          <h2>Extending the System</h2>
          
          <h3>Adding New Agents</h3>
          <pre><code>// Create: .github/agents/documentation.md
---
name: documentation
description: Generates comprehensive documentation for .NET and React applications
user-invokable: false
---

# Documentation Agent

I generate comprehensive documentation for your application.

## My Capabilities

- **API Documentation:** Generate Swagger/OpenAPI specs from .NET controllers
- **Code Documentation:** Add XML comments to C# code and JSDoc to TypeScript
- **User Guides:** Create README files and user manuals
- **Architecture Diagrams:** Generate C4 or UML diagrams
- **Database Schema Docs:** Document EF Core entities and relationships

## Documentation Types

### 1. API Documentation
- OpenAPI 3.0 specification from ASP.NET controllers
- Request/response examples
- Authentication requirements
- Error codes and messages

### 2. Code Documentation
```csharp
/// <summary>
/// Creates a new TODO task for the authenticated user.
/// </summary>
/// <param name="request">The task creation request containing title, description, etc.</param>
/// <returns>The created task with assigned ID</returns>
/// <response code="201">Task created successfully</response>
/// <response code="400">Invalid request data</response>
/// <response code="401">User not authenticated</response>
[HttpPost]
[ProducesResponseType(typeof(TaskDto), StatusCodes.Status201Created)]
public async Task<IActionResult> CreateTask([FromBody] CreateTaskRequest request)
{
    // Implementation
}
```

### 3. README Generation
- Project overview and architecture
- Setup instructions for .NET and React
- API endpoint documentation
- Environment configuration
- Deployment guides

## Usage

Invoked by orchestrator during the `/build` or `/document` workflow.

---

// Then update orchestrator.md to include:
subagents:
  - planning
  - design
  - coding
  - review
  - testing
  - security
  - infrastructure
  - documentation  # NEW
</code></pre>

          <h3>Custom Orchestrator Commands</h3>
          <pre><code>// Update .github/agents/orchestrator.md frontmatter:
---
name: orchestrator
description: Orchestrates TODO app development
user-invokable: true
commands:
  - name: build
    description: Build complete TODO application
  - name: feature
    description: Add a new feature
  - name: fix
    description: Fix a bug
  - name: migrate
    description: Migrate from Node.js to .NET 10  # NEW
  - name: optimize
    description: Optimize performance             # NEW
  - name: upgrade
    description: Upgrade to latest .NET version   # NEW
---

# Then add command handling logic in markdown:

## Command: /migrate

When you invoke `/migrate`, I will:
1. Analyze existing Node.js/Express backend
2. Delegate to @design to map models to C# entities
3. Delegate to @coding to generate .NET 10 controllers and services
4. Delegate to @testing to recreate tests in xUnit
5. Provide migration guide and comparison

## Command: /optimize

When you invoke `/optimize`, I will:
1. Delegate to @review for performance analysis
2. Identify N+1 queries in EF Core
3. Add database indexes where needed
4. Optimize React rendering with useMemo/useCallback
5. Implement caching strategies
</code></pre>

          <h2>Key Advantages of Markdown Agents</h2>
          
          <div class="callout">
            <strong>üéØ Declarative vs Imperative</strong><br />
            <p style="margin-top: 10px;">With markdown-based agents, you describe <em>what</em> the agent should do, not <em>how</em> to do it. The VS Code agent runtime handles the implementation details, letting you focus on agent behavior and orchestration.</p>
            
            <p><strong>Markdown Agent (.md):</strong></p>
            <ul>
              <li>Simple frontmatter for configuration</li>
              <li>Natural language instructions</li>
              <li>No TypeScript compilation needed</li>
              <li>Easy to read and modify</li>
              <li>LLMs interpret and execute instructions</li>
            </ul>
            
            <p><strong>TypeScript Agent (.agent.ts):</strong></p>
            <ul>
              <li>Full programmatic control</li>
              <li>Complex logic and algorithms</li>
              <li>Requires compilation and build step</li>
              <li>More verbose but more powerful</li>
              <li>Direct API access</li>
            </ul>
            
            <p><strong>When to use Markdown:</strong> Most agents, especially those focused on AI-assisted development, planning, design, and review.</p>
            <p><strong>When to use TypeScript:</strong> Agents that need direct file system access, complex algorithms, or integration with external services.</p>
          </div>

          <h2>Resources</h2>
          
          <ul>
            <li>üìñ <a href="https://code.visualstudio.com/api/extension-guides/chat" target="_blank" rel="noopener">VS Code Chat Extension Guide</a></li>
            <li>üìñ <a href="https://code.visualstudio.com/api/extension-guides/language-model" target="_blank" rel="noopener">Language Model API</a></li>
            <li>üîß <a href="https://github.com/microsoft/vscode-extension-samples" target="_blank" rel="noopener">VS Code Extension Samples</a></li>
            <li>üìö <a href="https://code.visualstudio.com/docs/copilot/agents/subagents" target="_blank" rel="noopener">SubAgents Documentation</a></li>
          </ul>
        </section>

        <!-- MCP vs RAG vs AI Agents Section -->
        <section id="mcp-vs-rag-vs-agents" role="article">
          <h1>‚ö° MCP vs RAG vs AI Agents</h1>
          <span class="badge">mcp</span>
          <span class="badge">rag</span>
          <span class="badge">agents</span>
          <span class="badge">comparison</span>

          <p>Everyone is talking about MCP, RAG, and AI Agents. Most people are still mixing them up. They're not competing ideas ‚Äî they solve very different problems at different layers of the stack.</p>

          <div class="callout">
            <strong>üí° The Mental Model</strong><br />
            <strong>MCP</strong> = tool interface (plumbing) &nbsp;|&nbsp; <strong>RAG</strong> = knowledge injection (memory) &nbsp;|&nbsp; <strong>AI Agents</strong> = decision loop (manager). They sit at different layers of the stack ‚Äî not rivals.
          </div>

          <h2>üîó Model Context Protocol (MCP)</h2>
          <p>MCP is about <strong>how LLMs use tools</strong>. Think of it as a standard interface between an LLM and external systems ‚Äî databases, file systems, GitHub, Slack, and internal APIs.</p>
          <p>Instead of every app inventing its own glue code, MCP defines a consistent way for models to:</p>
          <ul>
            <li>Discover available tools</li>
            <li>Invoke them with structured parameters</li>
            <li>Receive structured results back</li>
          </ul>

          <div class="callout">
            <strong>üîë Key Point</strong><br />
            MCP doesn't decide <em>what</em> to do. It standardizes <em>how</em> tools are exposed to the model.
          </div>

          <div class="mermaid">
%%{ init: { "theme": "base", "fontFamily": "Segoe UI Semibold", "fontSize": "18px" }}%%
flowchart LR
    LLM["üß† LLM"] -->|Tool Call| MCP["üîó MCP Interface"]
    MCP -->|Discover &amp; Invoke| DB[("üóÑÔ∏è Database")]
    MCP -->|Discover &amp; Invoke| FS["üìÅ File System"]
    MCP -->|Discover &amp; Invoke| GH["üêô GitHub / Slack"]
    MCP -->|Discover &amp; Invoke| API["‚öôÔ∏è Internal APIs"]
    DB -->|Structured Result| MCP
    FS -->|Structured Result| MCP
    GH -->|Structured Result| MCP
    API -->|Structured Result| MCP
    MCP -->|Result| LLM

    style LLM fill:#dbeafe,stroke:#3b82f6,color:#1e40af
    style MCP fill:#e0f2fe,stroke:#0ea5e9,color:#0c4a6e
    style DB fill:#f0fdf4,stroke:#22c55e,color:#14532d
    style FS fill:#f0fdf4,stroke:#22c55e,color:#14532d
    style GH fill:#f0fdf4,stroke:#22c55e,color:#14532d
    style API fill:#f0fdf4,stroke:#22c55e,color:#14532d
          </div>

          <h3>Security Concern with MCP</h3>
          <p>Once MCP connects models to real systems ‚Äî files, Slack, GitHub, internal APIs ‚Äî the cool demo becomes an attack surface. Teams will need:</p>
          <ul>
            <li>Least-privilege tool access</li>
            <li>Audit logs</li>
            <li>Safety checks between agents and external MCP servers</li>
          </ul>

          <h2>üìö Retrieval-Augmented Generation (RAG)</h2>
          <p>RAG is about <strong>what the model knows at runtime</strong>. The model stays frozen ‚Äî no retraining needed. When a user asks a question, a retriever fetches relevant documents (PDFs, code, vector DBs), and those are injected into the prompt.</p>

          <h3>RAG is great for:</h3>
          <ul>
            <li>Internal knowledge bases</li>
            <li>Fresh or private data the model wasn't trained on</li>
            <li>Reducing hallucinations by grounding answers in facts</li>
          </ul>

          <div class="mermaid">
            %%{ init: { "theme": "base", "fontFamily": "Segoe UI Semibold", "fontSize": "18px" }}%%
flowchart LR
    Q["‚ùì User Query"] --> R["üîç Retriever"]
    R --> VDB[("üìö Vector DB / Docs")]
    VDB -->|"Relevant Chunks"| PB["üìù Prompt Builder"]
    Q --> PB
    PB -->|"Augmented Prompt"| FLLM["üßä Frozen LLM"]
    FLLM --> ANS["‚úÖ Grounded Answer"]

    style Q fill:#fef3c7,stroke:#f59e0b,color:#78350f
    style R fill:#e0f2fe,stroke:#0ea5e9,color:#0c4a6e
    style VDB fill:#f0fdf4,stroke:#22c55e,color:#14532d
    style PB fill:#ede9fe,stroke:#8b5cf6,color:#4c1d95
    style FLLM fill:#dbeafe,stroke:#3b82f6,color:#1e40af
    style ANS fill:#dcfce7,stroke:#16a34a,color:#14532d
          </div>

          <div class="callout">
            <strong>‚ö†Ô∏è Important Limitation</strong><br />
            RAG doesn't take actions. It only improves answers by grounding the model's response in retrieved context.
          </div>

          <h2>ü§ñ AI Agents</h2>
          <p>AI Agents are about <strong>doing things</strong>. An agent observes, reasons, decides, acts, and repeats this loop. Agents can:</p>
          <ul>
            <li>Call tools via MCP or direct integrations</li>
            <li>Write and execute code</li>
            <li>Browse the internet</li>
            <li>Store and retrieve memory</li>
            <li>Delegate tasks to sub-agents</li>
            <li>Operate with varying levels of autonomy ‚Äî from supervised to fully autonomous</li>
          </ul>

          <div class="mermaid">
%%{ init: { "theme": "base", "fontFamily": "Segoe UI Semibold", "fontSize": "18px" }}%%
flowchart TD
    REQ["üì• User Request"] --> AGT["ü§ñ Agent"]
    AGT --> DEC{"üî∑ Reason &amp; Decide"}
    DEC -->|"Use Tool"| MCP["üîó MCP / Tools"]
    DEC -->|"Need Knowledge"| RAG["üìö RAG"]
    DEC -->|"Delegate"| SUB["ü§ñ Sub-Agent"]
    MCP --> RES["üì¶ Results"]
    RAG --> RES
    SUB --> RES
    RES -->|"Observe &amp; Loop"| AGT
    AGT --> OUT["üéØ Final Output"]

    style REQ fill:#fef3c7,stroke:#f59e0b,color:#78350f
    style AGT fill:#dbeafe,stroke:#3b82f6,color:#1e40af
    style DEC fill:#ede9fe,stroke:#8b5cf6,color:#4c1d95
    style MCP fill:#e0f2fe,stroke:#0ea5e9,color:#0c4a6e
    style RAG fill:#f0fdf4,stroke:#22c55e,color:#14532d
    style SUB fill:#dbeafe,stroke:#3b82f6,color:#1e40af
    style RES fill:#f1f5f9,stroke:#64748b,color:#1e293b
    style OUT fill:#dcfce7,stroke:#16a34a,color:#14532d
          </div>

          <h2>üîÑ How They Work Together</h2>
          <p>These three concepts complement each other in a layered architecture:</p>
          <ul>
            <li><strong>RAG</strong> feeds the agent relevant knowledge before it reasons</li>
            <li><strong>MCP</strong> provides the agent a standardized way to connect to and invoke external tools</li>
            <li><strong>The Agent</strong> is the orchestrator ‚Äî it decides <em>when</em> to retrieve data (RAG) and <em>when</em> to take action (via MCP tools)</li>
          </ul>

          <div class="callout">
            <strong>üèóÔ∏è Stack Layers</strong><br />
            <strong>Bottom layer:</strong> MCP (how tools are plumbed in) &nbsp;‚Üí&nbsp;
            <strong>Middle layer:</strong> RAG (what context/knowledge is available) &nbsp;‚Üí&nbsp;
            <strong>Top layer:</strong> Agent (the decision-maker that drives everything)
          </div>

          <h2>üìä Comparison Table</h2>
          <div class="table-responsive">
            <table class="table table-striped table-bordered">
              <thead>
                <tr>
                  <th>Aspect</th>
                  <th>üîó MCP</th>
                  <th>üìö RAG</th>
                  <th>ü§ñ AI Agents</th>
                </tr>
              </thead>
              <tbody>
                <tr>
                  <td><strong>Purpose</strong></td>
                  <td>Standard tool interface</td>
                  <td>Knowledge injection at runtime</td>
                  <td>Autonomous task execution</td>
                </tr>
                <tr>
                  <td><strong>Stack layer</strong></td>
                  <td>Connectivity plumbing</td>
                  <td>Context / memory</td>
                  <td>Decision &amp; action</td>
                </tr>
                <tr>
                  <td><strong>Core question</strong></td>
                  <td>How do tools connect?</td>
                  <td>What does the model know?</td>
                  <td>What should be done?</td>
                </tr>
                <tr>
                  <td><strong>Model changes?</strong></td>
                  <td>No</td>
                  <td>No (frozen model)</td>
                  <td>No, but guides behavior</td>
                </tr>
                <tr>
                  <td><strong>Takes actions?</strong></td>
                  <td>Enables actions via tools</td>
                  <td>No ‚Äî improves answers only</td>
                  <td>Yes ‚Äî core capability</td>
                </tr>
                <tr>
                  <td><strong>Best for</strong></td>
                  <td>Connecting LLMs to external systems</td>
                  <td>Private/fresh data, reducing hallucinations</td>
                  <td>Multi-step automation &amp; workflows</td>
                </tr>
                <tr>
                  <td><strong>Key security concern</strong></td>
                  <td>Least-privilege tool access, audit logs</td>
                  <td>Data privacy, source integrity</td>
                  <td>Autonomy level, human-in-the-loop</td>
                </tr>
              </tbody>
            </table>
          </div>
        </section>

        <!-- Resources Section -->
        <section id="resources" role="article">
          <h1>üìö Resources</h1>
          <span class="badge">docs</span>
          <span class="badge">community</span>
          <span class="badge">learning</span>
          
          <p>Comprehensive collection of documentation, tutorials, examples, and community resources for GitHub Copilot agent development.</p>

          <div class="callout">
            <strong>üéì Keep Learning</strong><br />
            The agent ecosystem is rapidly evolving. Use these resources to stay current and connect with the community.
          </div>

          <h2>Official Documentation</h2>
          
          <h3>üìñ Microsoft / GitHub</h3>
          <ul>
            <li><strong>GitHub Copilot Docs:</strong> <a href="https://docs.github.com/copilot" target="_blank">docs.github.com/copilot</a></li>
            <li><strong>VS Code Extensions API:</strong> <a href="https://code.visualstudio.com/api" target="_blank">code.visualstudio.com/api</a></li>
            <li><strong>Chat Participant API:</strong> <a href="https://code.visualstudio.com/api/extension-guides/chat" target="_blank">Chat Extension Guide</a></li>
            <li><strong>Language Model API:</strong> <a href="https://code.visualstudio.com/api/extension-guides/language-model" target="_blank">Language Model Guide</a></li>
            <li><strong>Extension Samples:</strong> <a href="https://github.com/microsoft/vscode-extension-samples" target="_blank">vscode-extension-samples</a></li>
          </ul>

          <h3>üîß SDKs and Tools</h3>
          <ul>
            <li><strong>VS Code Extension Generator:</strong> <code>npm install -g yo generator-code</code></li>
            <li><strong>Extension Packager:</strong> <code>npm install -g @vscode/vsce</code></li>
            <li><strong>TypeScript:</strong> <a href="https://typescriptlang.org" target="_blank">typescriptlang.org</a></li>
          </ul>

          <h2>MCP Resources</h2>
          
          <h3>üîå Model Context Protocol</h3>
          <ul>
            <li><strong>MCP Specification:</strong> <a href="https://modelcontextprotocol.io" target="_blank">modelcontextprotocol.io</a></li>
            <li><strong>MCP SDK:</strong> <a href="https://github.com/modelcontextprotocol/sdk" target="_blank">@modelcontextprotocol/sdk</a></li>
            <li><strong>Official MCP Servers:</strong>
              <ul>
                <li>Filesystem Server</li>
                <li>PostgreSQL Server</li>
                <li>GitHub Server</li>
                <li>SQLite Server</li>
              </ul>
            </li>
            <li><strong>Community Servers:</strong> <a href="https://github.com/modelcontextprotocol/servers" target="_blank">MCP Servers Repository</a></li>
          </ul>

          <h2>Tutorials & Guides</h2>
          
          <h3>üéØ Getting Started</h3>
          <ul>
            <li><strong>Your First Agent:</strong> Create a basic chat participant</li>
            <li><strong>Adding Commands:</strong> Implement slash commands</li>
            <li><strong>Using LLMs:</strong> Integrate language models</li>
            <li><strong>Tool Integration:</strong> Add executable tools</li>
            <li><strong>Publishing:</strong> Share your agent</li>
          </ul>

          <h3>üöÄ Advanced Topics</h3>
          <ul>
            <li><strong>Multi-step Workflows:</strong> Complex agent interactions</li>
            <li><strong>Custom Skills:</strong> Domain expertise injection</li>
            <li><strong>MCP Server Development:</strong> Build custom integrations</li>
            <li><strong>Performance Optimization:</strong> Faster, more efficient agents</li>
            <li><strong>Security Best Practices:</strong> Build secure agents</li>
          </ul>

          <h2>Example Projects</h2>
          
          <h3>üíª Open Source Agents</h3>
          <ul>
            <li><strong>Code Review Agent:</strong> Automated code quality checks</li>
            <li><strong>Documentation Generator:</strong> Auto-generate docs from code</li>
            <li><strong>Test Writer:</strong> Generate unit and integration tests</li>
            <li><strong>API Helper:</strong> REST API development assistant</li>
            <li><strong>Security Auditor:</strong> Vulnerability scanning</li>
          </ul>

          <h3>üì¶ Starter Templates</h3>
          <ul>
            <li><strong>Basic Agent:</strong> Minimal chat participant</li>
            <li><strong>Command Agent:</strong> Agent with slash commands</li>
            <li><strong>Tool Agent:</strong> Agent with executable tools</li>
            <li><strong>MCP Agent:</strong> Agent with MCP server integration</li>
            <li><strong>Full-Featured Agent:</strong> Complete example with all features</li>
          </ul>

          <h2>Community</h2>
          
          <h3>üë• Connect & Collaborate</h3>
          <ul>
            <li><strong>GitHub Discussions:</strong> <a href="https://github.com/github/copilot/discussions" target="_blank">Ask questions, share ideas</a></li>
            <li><strong>VS Code Community:</strong> <a href="https://github.com/microsoft/vscode-discussions" target="_blank">Extension development discussions</a></li>
            <li><strong>Discord:</strong> Join the VS Code and GitHub communities</li>
            <li><strong>Stack Overflow:</strong> Tag [github-copilot] and [vscode-extensions]</li>
          </ul>

          <h3>üì¢ Stay Updated</h3>
          <ul>
            <li><strong>GitHub Changelog:</strong> <a href="https://github.blog/changelog/" target="_blank">github.blog/changelog</a></li>
            <li><strong>VS Code Release Notes:</strong> <a href="https://code.visualstudio.com/updates" target="_blank">code.visualstudio.com/updates</a></li>
            <li><strong>VS Code API Updates:</strong> Monthly extension API updates</li>
            <li><strong>GitHub Copilot Blog:</strong> Feature announcements and best practices</li>
          </ul>

          <h2>Learning Materials</h2>
          
          <h3>üé• Video Tutorials</h3>
          <ul>
            <li>Building Your First GitHub Copilot Agent</li>
            <li>Advanced Agent Patterns</li>
            <li>MCP Server Development</li>
            <li>Agent Testing and Debugging</li>
          </ul>

          <h3>üìù Blog Posts & Articles</h3>
          <ul>
            <li>Best Practices for Agent Development</li>
            <li>Performance Optimization Techniques</li>
            <li>Security Considerations for Agents</li>
            <li>Real-World Agent Use Cases</li>
          </ul>

          <h2>Tools & Extensions</h2>
          
          <h3>üõ†Ô∏è Development Tools</h3>
          <ul>
            <li><strong>Extension Tester:</strong> Test extensions locally</li>
            <li><strong>Extension Debugger:</strong> Debug agent code</li>
            <li><strong>MCP Inspector:</strong> Test MCP server connections</li>
            <li><strong>Token Counter:</strong> Estimate LLM token usage</li>
          </ul>

          <h2>Reference</h2>
          
          <h3>üìë API References</h3>
          <ul>
            <li><strong>vscode.chat namespace:</strong> Chat participant APIs</li>
            <li><strong>vscode.lm namespace:</strong> Language model APIs</li>
            <li><strong>vscode.commands:</strong> Command registration</li>
            <li><strong>MCP Protocol:</strong> Server implementation spec</li>
          </ul>

          <h3>üìä Code Samples</h3>
          <pre><code>// Quick Reference: Create Agent
import * as vscode from 'vscode';

export function activate(context: vscode.ExtensionContext) {
  const agent = vscode.chat.createChatParticipant(
    'my-agent',
    async (request, context, response, token) => {
      response.markdown('Hello from my agent!');
    }
  );
  
  context.subscriptions.push(agent);
}

// Use Language Model
const models = await vscode.lm.selectChatModels({ vendor: 'copilot' });
const model = models[0];
const messages = [vscode.LanguageModelChatMessage.User('Hello')];
const response = await model.sendRequest(messages, {}, token);

// Register Command
agent.commands = [
  { name: 'analyze', description: 'Analyze code' }
];

// Access Context
const currentFile = vscode.window.activeTextEditor?.document;
const selection = vscode.window.activeTextEditor?.selection;</code></pre>

          <h2>Contributing</h2>
          
          <h3>ü§ù How to Contribute</h3>
          <ul>
            <li><strong>Share Your Agents:</strong> Publish to VS Code Marketplace</li>
            <li><strong>Create MCP Servers:</strong> Build integrations for others</li>
            <li><strong>Write Tutorials:</strong> Help others learn</li>
            <li><strong>Report Issues:</strong> Help improve the platform</li>
            <li><strong>Join Discussions:</strong> Share ideas and feedback</li>
          </ul>

          <h2>Quick Links</h2>
          
          <h3>‚ö° Essential Bookmarks</h3>
          <ul>
            <li>üìò <a href="https://docs.github.com/copilot" target="_blank">Copilot Documentation</a></li>
            <li>üì¶ <a href="https://marketplace.visualstudio.com/vscode" target="_blank">VS Code Marketplace</a></li>
            <li>üêõ <a href="https://github.com/microsoft/vscode/issues" target="_blank">VS Code Issues</a></li>
            <li>üí¨ <a href="https://github.com/github/copilot/discussions" target="_blank">Copilot Discussions</a></li>
            <li>üîó <a href="https://modelcontextprotocol.io" target="_blank">MCP Specification</a></li>
          </ul>

          <hr />
          <div class="document-footer">
            <p>
              <strong>Last Updated:</strong> February 2026 | 
              <strong>Curated by:</strong> Murthy Vepa with ‚ù§Ô∏è | <strong>Powered by:</strong> GitHub Copilot
            </p>
          </div>         
        </section>
        </div>
      </main>
    </div>
    
    <nav class="controls" role="navigation" aria-label="Pagination">
      <div class="btn-group" role="group">
        <button class="btn btn-outline-info btn-sm" id="prevBtn" title="Previous" aria-label="Previous concept">&nbsp;&lt;&nbsp;</button>
        <button class="btn btn-outline-info btn-sm" id="nextBtn" title="Next" aria-label="Next concept">&nbsp;&gt;&nbsp;</button>
      </div>
    </nav>
  </div>  <div class="offcanvas offcanvas-start" tabindex="-1" id="sidebarOffcanvas" aria-labelledby="sidebarLabel">
    <div class="offcanvas-header">
      <h5 class="offcanvas-title" id="sidebarLabel">Contents</h5>
      <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close"></button>
    </div>
    <div class="offcanvas-body p-0">
      <ul class="list-group list-group-flush w-100" id="tocMobile"></ul>
    </div>
  </div>

  <script>
    // ---- Configuration ----
    const sectionConfig = [
      { id: "agents-overview", title: "üìñ Overview", tags: ["intro", "overview", "agents"] },
      { id: "agents-sessions", title: "üîÑ Agent Sessions", tags: ["sessions", "lifecycle", "state"] },
      { id: "agent-architecture", title: "üèóÔ∏è Agent Architecture", tags: ["architecture", "design", "structure"] },
      { id: "agent-definition-schema", title: "üìã Agent Definition Schema", tags: ["schema", "configuration", "structure"] },
      { id: "agent-tools", title: "üõ†Ô∏è Agent Tools", tags: ["tools", "capabilities", "actions"] },
      { id: "agent-types", title: "üéØ Agent Types", tags: ["types", "categories"] },
      { id: "background-agents", title: "üîô Background Agents", tags: ["background", "async"], parent: "agent-types" },
      { id: "custom-agents", title: "üé® Custom Agents", tags: ["custom", "build"], parent: "agent-types" },
      { id: "local-agents", title: "üíª Local Agents", tags: ["local", "workspace"], parent: "agent-types" },
      { id: "cloud-agents", title: "‚òÅÔ∏è Cloud Agents", tags: ["cloud", "remote"], parent: "agent-types" },
      { id: "third-party-agents", title: "üîå Third Party Agents", tags: ["third-party", "extensions"], parent: "agent-types" },
      { id: "subagents", title: "ü§ñ SubAgents", tags: ["subagents", "delegation", "hierarchy"], parent: "agent-types" },
      // { id: "subagents-vscode", title: "üîµ SubAgents in VS Code", tags: ["vscode", "subagents", "chat"], parent: "subagents" },
      { id: "tutorial", title: "üöÄ Build Your First Agent", tags: ["tutorial", "guide", "start"] },
      { id: "agent-planning", title: "üìã Agent Planning", tags: ["planning", "orchestration", "workflow"] },
      { id: "agent-customization", title: "‚öôÔ∏è Agent Customization", tags: ["customization", "configuration"] },
      { id: "prompt-files", title: "üìÑ Prompt Files", tags: ["prompts", "files"], parent: "agent-customization" },
      { id: "custom-instructions", title: "üìù Custom Instructions", tags: ["instructions", "rules"], parent: "agent-customization" },
      { id: "agent-skills", title: "üéì Agent Skills", tags: ["skills", "capabilities"], parent: "agent-customization" },
      { id: "agent-capabilities", title: "üéØ Agent Capabilities", tags: ["capabilities", "permissions", "features"], parent: "agent-customization" },
      { id: "language-models", title: "üß† Language Models", tags: ["models", "llm"], parent: "agent-customization" },
      { id: "mcp-servers", title: "üîó MCP Servers", tags: ["mcp", "protocol"], parent: "agent-customization" },
      { id: "hooks", title: "ü™ù Hooks", tags: ["hooks", "events"], parent: "agent-customization" },
      { id: "best-practices", title: "‚≠ê Best Practices", tags: ["practices", "tips", "guidelines"] },
      { id: "use-cases", title: "üíº Use Cases", tags: ["examples", "scenarios", "applications"] },
      { id: "practical-example-todo-app", title: "üéØ Practical Example: TODO App", tags: ["practical", "example", "orchestrator", "todo"] },
      { id: "mcp-vs-rag-vs-agents", title: "‚ö° MCP vs RAG vs AI Agents", tags: ["mcp", "rag", "agents", "comparison", "protocol", "retrieval"] },
      { id: "resources", title: "üìö Resources", tags: ["docs", "community", "learning"] }
    ];

    // ---- State & rendering ----
    const state = {
      index: 0,
      filtered: sectionConfig.map((_, i) => i), // indices
    };

    const els = {
      toc: document.getElementById('toc'),
      tocMobile: document.getElementById('tocMobile'),
      prev: document.getElementById('prevBtn'),
      next: document.getElementById('nextBtn'),
      toggleSidebar: document.getElementById('toggleSidebar'),
      themeToggle: document.getElementById('themeToggle'),
      main: document.getElementById('main'),
      sidebar: document.querySelector('nav.sidebar'),
      sidebarOffcanvas: document.getElementById('sidebarOffcanvas')
    };

    function buildTOC(){
      // Clear both TOC lists
      els.toc.innerHTML = '';
      els.tocMobile.innerHTML = '';
      
      state.filtered.forEach((idx) => {
        const s = sectionConfig[idx];
        const isSubItem = !!s.parent;
        
        // Desktop sidebar
        const liDesktop = document.createElement('li');
        liDesktop.className = isSubItem ? 'list-group-sub-item' : 'list-group-item';
        const aDesktop = document.createElement('a');
        aDesktop.href = `#${s.id}`;
        aDesktop.textContent = s.title;
        aDesktop.addEventListener('click', (e) => {
          e.preventDefault();
          navigateToId(s.id);
          closeSidebar();
        });
        liDesktop.appendChild(aDesktop);
        els.toc.appendChild(liDesktop);
        
        // Mobile offcanvas
        const liMobile = document.createElement('li');
        liMobile.className = isSubItem ? 'list-group-sub-item' : 'list-group-item';
        const aMobile = document.createElement('a');
        aMobile.href = `#${s.id}`;
        aMobile.textContent = s.title;
        aMobile.addEventListener('click', (e) => {
          e.preventDefault();
          navigateToId(s.id);
          closeSidebar();
        });
        liMobile.appendChild(aMobile);
        els.tocMobile.appendChild(liMobile);
      });
      highlightActiveTOC();
    }

    function setActiveByIndex(i){
      const ids = state.filtered.map(idx => sectionConfig[idx].id);
      document.querySelectorAll('section').forEach(s => s.classList.remove('active'));
      const id = ids[i];
      const active = document.getElementById(id);
      if (active){
        active.classList.add('active');
        active.setAttribute('tabindex', '-1');
        active.focus({preventScroll:true});
      }
      updateControls();
      highlightActiveTOC();
      updateURLHash(id);
    }

    function updateControls(){
      const count = state.filtered.length;
      els.prev.disabled = state.index <= 0;
      els.next.disabled = state.index >= count - 1;
    }

    function filterTOC(query){
      const q = query.trim().toLowerCase();
      state.filtered = sectionConfig
        .map((s, i) => ({s, i}))
        .filter(({s}) => s.title.toLowerCase().includes(q) || s.tags.some(t => t.toLowerCase().includes(q)))
        .map(({i}) => i);

      state.index = Math.min(state.index, Math.max(0, state.filtered.length - 1));
      buildTOC();
      setActiveByIndex(state.index);
    }

    function navigate(delta){
      const count = state.filtered.length;
      const nextIndex = Math.min(Math.max(state.index + delta, 0), count - 1);
      if (nextIndex !== state.index){
        state.index = nextIndex;
        setActiveByIndex(state.index);
        // Scroll content to top
        const contentEl = document.querySelector('.content');
        if (contentEl) contentEl.scrollTop = 0;
      }
    }

    function navigateToId(id){
      const idxInFiltered = state.filtered.findIndex(fi => sectionConfig[fi].id === id);
      if (idxInFiltered !== -1){
        state.index = idxInFiltered;
        setActiveByIndex(state.index);
        // Scroll content to top
        const contentEl = document.querySelector('.content');
        if (contentEl) contentEl.scrollTop = 0;
      } else {
        state.filtered = sectionConfig.map((_, i) => i);
        buildTOC();
        navigateToId(id);
      }
    }

    function updateURLHash(id){
      const url = new URL(window.location);
      url.hash = id;
      history.replaceState(null, '', url);
    }

    function highlightActiveTOC(){
      const ids = state.filtered.map(idx => sectionConfig[idx].id);
      const activeId = ids[state.index];
      // Highlight desktop sidebar
      els.toc.querySelectorAll('a').forEach(a => a.classList.toggle('active', a.getAttribute('href') === `#${activeId}`));
      // Highlight mobile offcanvas
      els.tocMobile.querySelectorAll('a').forEach(a => a.classList.toggle('active', a.getAttribute('href') === `#${activeId}`));
    }

    function openSidebar(){
      const offcanvas = new bootstrap.Offcanvas(document.getElementById('sidebarOffcanvas'));
      offcanvas.show();
    }
    function closeSidebar(){
      const offcanvasElement = document.getElementById('sidebarOffcanvas');
      const offcanvas = bootstrap.Offcanvas.getInstance(offcanvasElement);
      if(offcanvas) offcanvas.hide();
    }

    // ---- Events ----
    els.prev.addEventListener('click', () => navigate(-1));
    els.next.addEventListener('click', () => navigate(1));

    // Keyboard navigation
    window.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowLeft') navigate(-1);
      else if (e.key === 'ArrowRight') navigate(1);
      else if (e.key === 'Escape') closeSidebar();
    });

    // Deep linking on load/hash change
    window.addEventListener('hashchange', () => {
      const id = location.hash.replace('#','');
      if (id) navigateToId(id);
    });

    // Sidebar toggle (mobile)
    els.toggleSidebar.addEventListener('click', () => {
      openSidebar();
    });

    // Restore theme
    (function(){
      try {
        const saved = localStorage.getItem('concepts-theme');
        if (saved) { 
          document.documentElement.setAttribute('data-theme', saved);
          els.themeToggle.textContent = saved === 'light' ? 'üåó' : 'üåô';
        }
      } catch {}
    })();

    // Initial render
    buildTOC();
    
    // Navigate to hash if present, otherwise show first section
    const initialId = location.hash.replace('#','');
    if (initialId){ 
    navigateToId(initialId); 
    } else {
    setActiveByIndex(0);
    // Scroll content to top on initial load
    const contentEl = document.querySelector('.content');
    if (contentEl) contentEl.scrollTop = 0;
    }

  </script>
  <!-- Bootstrap JS -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>