<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Software Architecture Patterns - In a Nutshell</title>
  <meta name="description" content="A comprehensive guide to Software Architecture Patterns." />
  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    :root{
      --bg: #ffffff;
      --fg: #0f172a;
      --muted: #64748b;
      --accent: #3b82f6;
      --accent-light: #dbeafe;
      --border: #e2e8f0;
      --sidebar-bg: #ffffff;
      --sidebar-fg: #0f172a;
      --code-bg: linear-gradient(90deg, rgba(59, 130, 246, 0.08) 0%, rgba(59, 130, 246, 0.12) 100%);
      --focus: #10b981;
      --shadow-sm: 0 1px 3px rgba(0,0,0,0.08);
      --shadow-md: 0 4px 6px rgba(0,0,0,0.1), 0 2px 4px rgba(0,0,0,0.06);
      --shadow-lg: 0 10px 20px rgba(0,0,0,0.12), 0 6px 6px rgba(0,0,0,0.08);
      --gradient: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
    }
    
    /* Bootstrap Gradient Utility Classes */
    .bg-gradient-blue { background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%) !important; }
    .bg-gradient-green { background: linear-gradient(135deg, #dcfce7 0%, #bbf7d0 100%) !important; }
    .bg-gradient-yellow { background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%) !important; }
    .bg-gradient-pink { background: linear-gradient(135deg, #fce7f3 0%, #fbcfe8 100%) !important; }
    .bg-gradient-purple { background: linear-gradient(135deg, #e9d5ff 0%, #d8b4fe 100%) !important; }
    .bg-gradient-teal { background: linear-gradient(135deg, #ccfbf1 0%, #99f6e4 100%) !important; }
    .bg-gradient-blue-dark { background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%) !important; }
    .bg-gradient-gray { background: linear-gradient(135deg, #64748b 0%, #475569 100%) !important; }
    .bg-gradient-purple-dark { background: linear-gradient(135deg, #a855f7 0%, #9333ea 100%) !important; }
    .bg-gradient-teal-dark { background: linear-gradient(135deg, #14b8a6 0%, #0d9488 100%) !important; }
    .bg-gradient-green-dark { background: linear-gradient(135deg, #10b981 0%, #059669 100%) !important; }
    .bg-gradient-red { background: linear-gradient(135deg, #fee2e2 0%, #fecaca 100%) !important; }
    .bg-gradient-green-light { background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%) !important; }
    .bg-gradient-blue-sky { background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%) !important; }
    .bg-gradient-red-dark { background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%) !important; }
    .bg-gradient-indigo { background: linear-gradient(135deg, #4f46e5 0%, #4338ca 100%) !important; }
    .bg-gradient-green-medium { background: linear-gradient(135deg, #10b981 0%, #059669 100%) !important; }
    .bg-gradient-orange { background: linear-gradient(135deg, #f97316 0%, #ea580c 100%) !important; }
    .bg-gradient-violet { background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%) !important; }
    .bg-gradient-lime { background: linear-gradient(135deg, #84cc16 0%, #65a30d 100%) !important; }
    .bg-gradient-sky { background: linear-gradient(135deg, #0284c7 0%, #0369a1 100%) !important; }
    
    /* Apply theme colors to Bootstrap elements */
    body { background-color: var(--bg); color: var(--fg); overflow: hidden; }
    .navbar { background-color: var(--fg) !important; border-bottom: none !important; box-shadow: var(--shadow-md) !important; }
    .navbar-brand { cursor: pointer; color: var(--bg) !important; font-weight: 600; letter-spacing: 0px; }
    .navbar-toggler-icon { 
      filter: invert(1);
      background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 30 30'%3e%3cpath stroke='rgba%2896, 165, 250, 0.9%29' stroke-linecap='round' stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/%3e%3c/svg%3e");
    }
    
    .btn-outline-secondary { border-color: var(--border) !important; color: var(--fg) !important; }
    .btn-outline-secondary:hover { background-color: var(--accent-light) !important; border-color: var(--accent) !important; color: var(--accent) !important; }
    
    /* Sidebar - Modern Design */
    nav.sidebar { 
      background: linear-gradient(180deg, #f3f4f6 0%, #e5e7eb 100%); 
      border-right: 1px solid rgba(0, 0, 0, 0.05) !important;  
      overflow-y: auto; 
      box-shadow: 4px 0 16px rgba(0, 0, 0, 0.06);
      padding-top: 0;
    }
    
    .menu-header {  
      background: linear-gradient(135deg, rgba(0, 0, 0, 0.15), rgba(0, 0, 0, 0.1) 100%);
      font-weight: bold; 
      padding: 1.25rem 1.25rem; 
      letter-spacing: 0px; 
      font-size: 1.1rem;
      position: relative;
      overflow: hidden;
      border: none;
      border-bottom: 2px solid #a5aab3;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.12);
      color: #0c346c;
      text-shadow: none;
      margin: 0;
      text-transform: none;
    }
    .menu-header::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.15), transparent);
      transition: left 0.6s ease;
    }
    .menu-header:hover::before {
      left: 100%;
    }
    .menu-header::after {
      content: 'üìã';
      position: absolute;
      right: 1.5rem;
      top: 50%;
      transform: translateY(-50%);
      font-size: 1.3rem;
      opacity: 0.9;
      filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.2));
    }
    
    .toc { 
      list-style: none; 
      padding: 0rem 0; 
      margin: 0; 
      background: transparent;
    }
    .toc li { 
      margin: 0; 
    }
    
    /* Section grouping */
    .toc li[data-group="overview"] { margin-bottom: 0.75rem; }
    .toc li[data-group="solid"]:first-of-type { 
      margin-top: 1rem; 
      border-top: 2px solid rgba(59, 130, 246, 0.15);
      padding-top: 1rem;
    }
    .toc li[data-group="other-principles"]:first-of-type { 
      margin-top: 1rem; 
      border-top: 2px solid rgba(16, 185, 129, 0.15);
      padding-top: 1rem;
    }
    .toc li[data-group="resources"] { 
      margin-top: 1rem; 
      border-top: 2px solid rgba(100, 116, 139, 0.15);
      padding-top: 1rem;
    }
    
    .list-group-item { 
      background: transparent; 
      border-color: transparent; 
      padding: 0; 
      margin: 0.25rem 0.75rem; 
      border-radius: 0rem;
      transition: all 0.2s ease;
    }
    .list-group-item a { 
      color: #1f2937; 
      text-decoration: none; 
      display: flex; 
      flex-direction: column; 
      align-items: flex-start; 
      gap: 0.4rem; 
      border-left: 3px solid transparent; 
      padding: 0.85rem 1.25rem; 
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); 
      font-weight: 500; 
      border-radius: 0rem;
      font-size: 0.95rem;
      position: relative;
      overflow: hidden;
      background: linear-gradient(90deg, rgba(255, 255, 255, 0.4) 0%, rgba(255, 255, 255, 0.1) 100%);
      border: 1px solid rgba(0, 0, 0, 0.06);
      -webkit-backdrop-filter: blur(10px);
      backdrop-filter: blur(10px);
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
    }
    .list-group-item a::before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      width: 4px;
      background: linear-gradient(180deg, #3b82f6 0%, #2563eb 100%);
      transform: scaleY(0);
      transition: transform 0.3s ease;
      border-radius: 0 0px 0px 0;
    }
    .list-group-item a::after {
      content: '‚ñ∂';
      position: absolute;
      right: 1rem;
      top: 50%;
      transform: translateY(-50%) scale(0.7);
      font-size: 0.7rem;
      color: #9ca3af;
      opacity: 0;
      transition: all 0.3s ease;
    }
    .list-group-item a:hover { 
      background: linear-gradient(90deg, rgba(59, 130, 246, 0.15) 0%, rgba(59, 130, 246, 0.08) 100%); 
      border-left-color: transparent;
      color: #1e40af;
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.2), 0 2px 4px rgba(0, 0, 0, 0.08);
      border-color: rgba(59, 130, 246, 0.2);
      text-decoration: none;
    }
    .list-group-item a:hover::before {
      transform: scaleY(1);
    }
    .list-group-item a:hover::after {
      opacity: 1;
      transform: translateY(-50%) scale(1);
      color: #3b82f6;
    }
    .list-group-item a.active { 
      background: linear-gradient(90deg, rgba(59, 130, 246, 0.22) 0%, rgba(59, 130, 246, 0.12) 100%); 
      color: #1e40af; 
      font-weight: 600; 
      border-left-color: transparent;
      box-shadow: 0 4px 16px rgba(59, 130, 246, 0.25), inset 0 1px 0 rgba(255, 255, 255, 0.3);
      border-color: rgba(59, 130, 246, 0.3);
    }
    .list-group-item a.active::before {
      transform: scaleY(1);
      background: linear-gradient(180deg, #3b82f6 0%, #2563eb 100%);
      width: 5px;
      box-shadow: 0 0 8px rgba(59, 130, 246, 0.5);
    }
    .list-group-item a.active::after {
      opacity: 1;
      color: #2563eb;
      transform: translateY(-50%) scale(1);
    }
    .list-group-item a.active:hover { 
      background: linear-gradient(90deg, rgba(59, 130, 246, 0.28) 0%, rgba(59, 130, 246, 0.16) 100%); 
      box-shadow: 0 6px 20px rgba(59, 130, 246, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.4);
    }
    
    /* Sub-items tree connectors */
    .list-group-sub-item a::before { 
      content: '‚îú‚îÄ';
      font-size: 0.85rem;
      margin-right: 0.5rem;
      color: #6b7280;
      z-index: 1;
      position: relative;
    }
    
    /* Sub-items styling - similar to main items but smaller and indented */
    .list-group-sub-item {
      background: transparent; 
      border-color: transparent; 
      padding: 0px; 
      margin: 0.2rem 0.75rem 0.2rem 1.5rem;
      border-radius: 0rem;
      transition: all 0.2s ease;
      position: relative;
      list-style-type: none;
    }
    .list-group-sub-item::before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      width: 4px;
      background: linear-gradient(180deg, #3b82f6 0%, #2563eb 100%);
      transform: scaleY(0);
      transition: transform 0.3s ease;
      border-radius: 0 0px 0px 0;
      z-index: 1;
    }
    .list-group-sub-item a {
      color: #1f2937; 
      text-decoration: none; 
      display: block;
      border-left: 3px solid transparent; 
      padding: 0.65rem 1rem 0.65rem 2.00rem;
      transition: all 0.2s ease; 
      font-weight: 500; 
      border-radius: 0rem;
      font-size: 0.8125rem;
      line-height: 1.4;
      position: relative;
      overflow: hidden;
      background: rgba(255, 255, 255, 0.5);
      border: 1px solid rgba(0, 0, 0, 0.04);
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.04);
    }
    
    /* Sub-items hover and active states - same as main items */
    .list-group-sub-item a::after {
      content: '‚ñ∂';
      position: absolute;
      right: 1rem;
      top: 50%;
      transform: translateY(-50%) scale(0.7);
      font-size: 0.7rem;
      color: #9ca3af;
      opacity: 0;
      transition: all 0.3s ease;
    }
    
    .list-group-sub-item:hover::before {
      transform: scaleY(1);
    }
    .list-group-sub-item a:hover { 
      background: linear-gradient(90deg, rgba(59, 130, 246, 0.15) 0%, rgba(59, 130, 246, 0.08) 100%); 
      border-left-color: transparent;
      color: #1e40af;
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.2), 0 2px 4px rgba(0, 0, 0, 0.08);
      border-color: rgba(59, 130, 246, 0.2);
      text-decoration: none;
    }
    .list-group-sub-item a:hover::after {
      opacity: 1;
      transform: translateY(-50%) scale(1);
      color: #3b82f6;
    }
    
    .list-group-sub-item.active::before {
      transform: scaleY(1);
      width: 5px;
      box-shadow: 0 0 8px rgba(59, 130, 246, 0.5);
    }
    .list-group-sub-item a.active { 
      background: linear-gradient(90deg, rgba(59, 130, 246, 0.22) 0%, rgba(59, 130, 246, 0.12) 100%); 
      color: #1e40af; 
      font-weight: 600; 
      border-left-color: transparent;
      box-shadow: 0 4px 16px rgba(59, 130, 246, 0.25), inset 0 1px 0 rgba(255, 255, 255, 0.3);
      border-color: rgba(59, 130, 246, 0.3);
    }
    .list-group-sub-item a.active::after {
      opacity: 1;
      color: #2563eb;
      transform: translateY(-50%) scale(1);
    }
    .list-group-sub-item a.active:hover { 
      background: linear-gradient(90deg, rgba(59, 130, 246, 0.28) 0%, rgba(59, 130, 246, 0.16) 100%); 
      box-shadow: 0 6px 20px rgba(59, 130, 246, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.4);
    }
    
    .list-group-item a::after {
      content: '‚ñ∂';
      position: absolute;
      right: 1rem;
      top: 50%;
      transform: translateY(-50%) scale(0.7);
      font-size: 0.7rem;
      color: #9ca3af;
      opacity: 0;
      transition: all 0.3s ease;
    }
    
    .list-group-item a:hover { 
      background: linear-gradient(90deg, rgba(59, 130, 246, 0.15) 0%, rgba(59, 130, 246, 0.08) 100%); 
      border-left-color: transparent;
      color: #1e40af;
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.2), 0 2px 4px rgba(0, 0, 0, 0.08);
      border-color: rgba(59, 130, 246, 0.2);
      text-decoration: none;
    }
    .list-group-item a:hover::before {
      transform: scaleY(1);
    }
    .list-group-item a:hover::after {
      opacity: 1;
      transform: translateY(-50%) scale(1);
      color: #3b82f6;
    }
    .list-group-item a.active { 
      background: linear-gradient(90deg, rgba(59, 130, 246, 0.22) 0%, rgba(59, 130, 246, 0.12) 100%); 
      color: #1e40af; 
      font-weight: 600; 
      border-left-color: transparent;
      box-shadow: 0 4px 16px rgba(59, 130, 246, 0.25), inset 0 1px 0 rgba(255, 255, 255, 0.3);
      border-color: rgba(59, 130, 246, 0.3);
    }
    .list-group-item a.active::after {
      opacity: 1;
      color: #2563eb;
      transform: translateY(-50%) scale(1);
    }
    .list-group-item a.active:hover { 
      background: linear-gradient(90deg, rgba(59, 130, 246, 0.28) 0%, rgba(59, 130, 246, 0.16) 100%); 
      box-shadow: 0 6px 20px rgba(59, 130, 246, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.4);
    }
    
    /* Badge styling */
    .badge { font-size: 0.8rem; padding: 0.15rem 0.4rem; background: var(--accent-light); color: var(--accent); border: 1px solid var(--accent); font-weight: 600; border-radius: 0.25rem; font-style: normal; line-height: 1.2; opacity: 0.9; }
    .badge { background: var(--accent); color: white; border: none; font-size: 0.6rem; padding: 0.25rem 0.5rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; display: inline-block; margin-top: 0.5rem; margin-right: 0.35rem; }
    .list-group-item a:hover .badge { opacity: 1; background: var(--accent); color: white; }
    .list-group-item a.active .badge { background: rgba(255, 255, 255, 0.3); color: white; border-color: rgba(255, 255, 255, 0.6); font-weight: 600; opacity: 1; }
        
    /* Content */
    .content { width: 100%; max-width: 100%; margin: 0 auto; background: #ffffff; padding: 2rem; border-radius: 0.75rem; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08); }
    section { display: none !important; margin-bottom: 2rem; }
    section.active { display: block !important; }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    
    h1 { font-size: 2rem; font-weight: 700; margin: 1rem 0 0.25rem 0; letter-spacing: -0.5px; color: var(--fg); display: block; border: none; }
    h2 { font-size: 1.5rem; font-weight: 600; margin: 1.5rem 0 0.75rem 0; color: var(--fg); border-bottom: 2px solid var(--accent-light); padding-bottom: 0.5rem; }
    h3 { font-size: 1.1rem; color: var(--accent); font-weight: 600; margin: 1rem 0 0.5rem 0; }
    h4 { font-size: 0.8rem; color: var(--fg); font-weight: 600; margin: 0.75rem 0 0.4rem 0; }
    p { margin: 1rem 0; line-height: 1.65; color: var(--fg); }
    ul, ol { margin: 1rem 0; padding-left: 2rem; }
    li { margin: 0.5rem 0; color: var(--fg); }
    
    code { background: var(--code-bg); border: 1px solid var(--border); padding: 0.2rem 0.5rem; font-family: ui-monospace, 'Cascadia Code', 'Source Code Pro', monospace; font-size: 0.9em; color: var(--accent); border-radius: 0.5rem; }
    pre { background: var(--code-bg); border: 0px solid var(--border); padding: 1rem; border-radius: 0.5rem; overflow: auto; box-shadow: var(--shadow-sm); margin: 1rem 0; }
    pre code { padding: 0; background: transparent; border: none; color: var(--fg); }
    
    .callout { border-left: 5px solid var(--accent); background: var(--accent-light); padding: 1rem 1.2rem; margin: 1.5rem 0; border-radius: 0.5rem; box-shadow: var(--shadow-sm); font-weight: 500; color: var(--fg); }
    
    /* Table styling */
    .table { color: var(--fg); }
    .table thead th { background: var(--accent-light); color: var(--accent); border-color: var(--border); font-weight: 600; }
    .table tbody td { border-color: var(--border); }
    .table-striped tbody tr:nth-of-type(odd) { background-color: rgba(0,0,0,0.02); }
    .table-striped tbody tr:hover { background-color: var(--accent-light); }
    
    /* Controls/Pagination */
    .controls { opacity: 0.5; position: fixed; bottom: 0.25rem; right: 1rem; width: auto; z-index: 1000; background: transparent; display: flex; align-items: center; justify-content: center; gap: 0rem; padding: 0; min-height: 40px; }
    @media (max-width: 991px) {
      .controls { bottom: 0.25rem; right: 1rem; }
      .menu-header { color: var(--focus); }
    }
    .controls:hover { opacity: 1; }
    
    .page-indicator { color: var(--accent); font-weight: 600; font-size: 0.875rem; }
    .btn-group .btn { margin: 0px 2px; padding: 0.2rem 0.5rem; background: var(--accent); color: white; border-color: var(--accent); font-size: 1rem; font-weight: bold; }
    .btn-group .btn:hover { background: var(--accent); }
    .btn-group .btn + .btn { margin-left: -1px; }
    
    /* Mobile/Offcanvas */
    .offcanvas { background: var(--bg) !important; }
    .offcanvas-header { border-bottom: 1px solid var(--border); }
    .offcanvas-title { color: var(--fg); font-weight: 600; }
    .btn-close { color: var(--fg); }
    
    /* Scrollbar */
    nav.sidebar::-webkit-scrollbar { width: 6px; }
    nav.sidebar::-webkit-scrollbar-track { background: rgba(0, 0, 0, 0.05); }
    nav.sidebar::-webkit-scrollbar-thumb { background: rgba(0, 0, 0, 0.2); border-radius: 0px; }
    nav.sidebar::-webkit-scrollbar-thumb:hover { background: rgba(0, 0, 0, 0.3); }
    
    /* Mermaid Diagrams */
    .mermaid {
      background: #ffffff;
      border: 1px solid #e2e8f0;
      border-radius: 0.5rem;
      padding: 2rem;
      margin: 1.5rem 0;
      min-height: 400px;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: visible;
      position: relative;
    }
    .mermaid.rendered {
      min-height: 0;
    }
    .mermaid svg {
      max-width: 100%;
      height: auto;
      min-height: 300px;
      transition: transform 0.3s ease;
      transform-origin: center center;
    }
    .mermaid.zoomed {
      overflow: auto;
      cursor: grab;
    }
    .mermaid.zoomed:active {
      cursor: grabbing;
    }
    .mermaid svg text {
      font-size: 14px !important;
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif !important;
    }
    
    /* Mermaid title styling */
    .mermaid svg text, .diagram-modal-content svg text {
      font-size: 1rem !important;
      font-weight: bold !important;
      fill: var(--fg) !important;
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif !important;
    }

    .mermaid svg *
    {
        color: #333;
    }

    .mermaid[data-processed="true"] {
      min-height: 0;
    }
    
    .mermaid svg {
      max-width: 100%;
      height: auto;
      display: inline-block;
    }
    
    /* Zoom controls */
    .zoom-controls {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 10;
      opacity: 0.5;
      transition: opacity 0.3s ease;
    }
    .mermaid:hover .zoom-controls {
      opacity: 1;
    }
    .zoom-btn {
      background: var(--accent);
      color: white;
      border: none;
      border-radius: 0.25rem;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 16px;
      font-weight: bold;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      transition: all 0.2s ease;
    }
    .zoom-btn:hover {
      background: #2563eb;
      transform: scale(1.1);
    }

    /* Modal for diagram zoom */
    .diagram-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.95);
      z-index: 9999;
      align-items: center;
      justify-content: center;
      padding: 0;
    }
    .diagram-modal.active {
      display: flex;
    }
    .diagram-modal-content {
      position: relative;
      width: 100%;
      height: 100%;
      background: white;
      border-radius: 0;
      padding: 3rem 3rem 3rem 3rem;
      overflow: auto;
      display: flex;
      align-items: flex-start;
      justify-content: center;
    }
    .diagram-modal-content svg {
      max-width: 100%;
      height: auto;
    }
    .modal-close {
      position: fixed;
      top: 1.5rem;
      right: 1.5rem;
      background: #ef4444;
      color: white;
      border: none;
      border-radius: 50%;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 16px;
      font-weight: bold;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
      transition: all 0.2s ease;
      z-index: 10000;
    }
    .modal-close:hover {
      background: #dc2626;
      transform: scale(1.1);
    }
    .modal-zoom-controls {
      position: fixed;
      bottom: 1.5rem;
      right: 1.5rem;
      display: flex;
      gap: 0.5rem;
      z-index: 10000;
      padding: 0rem;
      border-radius: 0.4rem;
    }
    .modal-zoom-btn {
      background: var(--accent);
      color: white;
      border: none;
      border-radius: 0.25rem;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 16px;
      font-weight: bold;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      transition: all 0.2s ease;
    }
    .modal-zoom-btn:hover {
      background: #2563eb;
      transform: scale(1.1);
    }
    
    /* Utilities */
    .search { height: 0; overflow: hidden; padding: 0 !important; }
    .search input { display: none; }
    .min-vh-100 { min-height: 100vh; }
    .skip-link { position: absolute; left: -9999px; top: auto; width: 1px; height: 1px; overflow: hidden; }
    .skip-link:focus { position: static; width: auto; height: auto; padding: 0.4rem 0.6rem; background: var(--accent); color: white; border-radius: 0.4rem; }
    
    /* Override Bootstrap defaults for theme */
    a { color: var(--accent); }
    a:hover { color: var(--accent); text-decoration: underline; }
    
    /* Responsive - keep sidebar visible on desktop, offcanvas on mobile */
    @media (max-width: 991px) {
      nav.sidebar { display: none; }
      #main { width: 100%; }
      .row { --bs-gutter-x: 0; }
    }
    
    /* Layout - prevent unnecessary scrolling */
    html, body { height: 100%; margin: 0; }
    #appContainer { display: flex; flex-direction: column; height: calc(100vh - 50px); }
    #mainRow { flex: 1; overflow: hidden; display: flex; }
    nav.sidebar { overflow-y: auto; max-height: 100%; position: relative; padding-bottom: 0px; }
    #main { overflow: hidden; display: flex; flex-direction: column; height: 100%; -webkit-tap-highlight-color: transparent; outline: none; border: none; }
    #main:focus { outline: none; }
    .content { overflow-y: auto; flex: 1; width: 100%; min-height: 0; padding: 0rem 1.5rem 0rem 1.5rem; }
    
    /* Contact Info */
    .contact-info {
      font-weight: 400 !important;
      padding: 0.5rem 0.75rem;
      font-size: 0.75rem;
      color: var(--accent-light);
      margin: 0;
      opacity: 0.5;
      white-space: nowrap;
      cursor: pointer;
    }
    .contact-info:hover {
      opacity: 0.9;
      text-decoration: none;
    }
    @media (max-width: 991px) {
      .navbar-brand {
        font-size: 1rem !important;
        flex: 1;
      }
      .contact-info {
        font-size: 0.7rem;
        padding: 0.25rem 0.5rem;
      }
    }
    @media (max-width: 576px) {
      .navbar-brand {
        font-size: 0.9rem !important;
      }
      .contact-info {
        font-size: 0.65rem;
        padding: 0.2rem 0.4rem;
      }
    }

    .list-style-none {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    /* JSON Syntax Highlighting */
    pre code.language-json {
      display: block;
      white-space: pre;
      font-family: 'Cascadia Code', 'Consolas', 'Monaco', 'Courier New', monospace;
    }

    pre code.language-json .json-key {
      color: #0451a5;
      font-weight: 500;
    }

    pre code.language-json .json-string {
      color: #a31515;
    }

    pre code.language-json .json-number {
      color: #098658;
    }

    pre code.language-json .json-boolean {
      color: #0000ff;
      font-weight: 600;
    }

    pre code.language-json .json-null {
      color: #0000ff;
      font-weight: 600;
    }

    pre code.language-json .json-punctuation {
      color: #333;
    }

    /* SQL Syntax Highlighting */
    pre code.language-sql {
      display: block;
      white-space: pre;
      font-family: 'Cascadia Code', 'Consolas', 'Monaco', 'Courier New', monospace;
    }

    pre code.language-sql .sql-keyword {
      color: #0000ff;
      font-weight: 600;
      text-transform: uppercase;
    }

    pre code.language-sql .sql-string {
      color: #a31515;
    }

    pre code.language-sql .sql-number {
      color: #098658;
    }

    pre code.language-sql .sql-comment {
      color: #008000;
      font-style: italic;
    }

    pre code.language-sql .sql-function {
      color: #795e26;
      font-weight: 500;
    }

    pre code.language-sql .sql-operator {
      color: #666;
      font-weight: 500;
    }

    /* Language Label for Code Blocks */
    pre[data-language]::before {
      content: attr(data-language);
      position: absolute;
      top: 8px;
      right: 12px;
      font-size: 0.75em;
      color: #6a737d;
      text-transform: uppercase;
      font-weight: 600;
      letter-spacing: 0.5px;
      background: var(--bg);
      padding: 0.2rem 0.5rem;
      border-radius: 0.25rem;
      border: 1px solid var(--border);
    }

    /* Enhanced pre/code styling for syntax highlighted blocks */
    pre.syntax-highlighted {
      position: relative;
      background: var(--code-bg);
      border: 1px solid var(--border);
      padding: 1.5rem 1rem 1rem 1rem;
      border-radius: 0.5rem;
      overflow-x: auto;
      box-shadow: var(--shadow-sm);
      margin: 1rem 0;
    }

    pre.syntax-highlighted code {
      background: transparent;
      padding: 0;
      border: none;
      color: var(--fg);
      font-size: 0.875rem;
      line-height: 1.6;
    }

    ul
    {
        list-style-type: none;
    }

    /* Code Tabs Styling */
    .code-tabs {
      margin: 1.5rem 0;
    }
    .code-tabs .nav-tabs {
      border-bottom: 2px solid var(--border);
      margin-bottom: 0;
    }
    .code-tabs .nav-link {
      color: var(--muted);
      border: none;
      border-bottom: 3px solid transparent;
      padding: 0.75rem 1.5rem;
      font-weight: 600;
      transition: all 0.3s ease;
      background: transparent;
    }
    .code-tabs .nav-link:hover {
      color: var(--accent);
      background: var(--accent-light);
      border-bottom-color: var(--accent);
    }
    .code-tabs .nav-link.active {
      color: var(--accent);
      background: var(--accent-light);
      border-bottom-color: var(--accent);
    }
    .code-tabs .tab-content {
      background: var(--code-bg);
      border: 1px solid var(--border);
      border-top: none;
      border-radius: 0 0 0.5rem 0.5rem;
      padding: 0;
    }
    .code-tabs .tab-pane {
      padding: 0;
    }
    .code-tabs pre {
      margin: 0;
      border: none;
      border-radius: 0 0 0.5rem 0.5rem;
    }

  /* Document Footer */
    .document-footer {
      text-align: center;
      padding: 20px;
      background-color: #f8f9fa;
      border-radius: 8px;
      margin-top: 20px;
    }
    .document-footer p {
      margin: 0;
      font-size: 14px;
      color: #6c757d;
      line-height: 1.6;
    }
    .document-footer strong {
      color: #495057;
    }  
  </style>
  <!-- Mermaid.js for diagrams -->
  <script src="https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.min.js"></script>
  <script>
    // Initialize Mermaid with proper configuration
    document.addEventListener('DOMContentLoaded', function() {

      mermaid.initialize({
        startOnLoad: false,
        theme: 'base',
        securityLevel: 'loose',
        logLevel: 'error',
        fontFamily: 'Segoe UI',
        flowchart: {
          useMaxWidth: true,
          htmlLabels: true,
          curve: 'basis',
        },
        sequence: {
          useMaxWidth: false,
          htmlLabels: true,
          diagramMarginX: 50,
          diagramMarginY: 10
        }
      });
      
      // Render all diagrams
      renderMermaidDiagrams();
    });
    
    async function renderMermaidDiagrams() {
      const diagrams = document.querySelectorAll('.mermaid');
      
      for (let i = 0; i < diagrams.length; i++) {
        const diagram = diagrams[i];
        const code = diagram.textContent.trim();
        
        // Store original code
        if (!diagram.hasAttribute('data-original-code')) {
          diagram.setAttribute('data-original-code', code);
        }
        
        try {
          const { svg } = await mermaid.render('mermaid-diagram-' + i, code);
          diagram.innerHTML = svg;
          diagram.setAttribute('data-processed', 'true');
          
          // Add zoom controls
          addZoomControls(diagram);
        } catch (error) {
          console.error('Mermaid rendering error for diagram ' + i + ':', error);
          diagram.innerHTML = '<div class="alert alert-danger border border-danger rounded p-3">Error rendering diagram: ' + error.message + '</div>';
        }
      }
    }
    
    // Add zoom controls to mermaid diagrams
    function addZoomControls(diagram) {
      const controls = document.createElement('div');
      controls.className = 'zoom-controls';
      controls.innerHTML = `
        <button class="zoom-btn" data-action="expand" title="Expand View">‚õ∂</button>
      `;
      
      diagram.style.position = 'relative';
      diagram.insertBefore(controls, diagram.firstChild);
      
      // Expand to modal
      controls.addEventListener('click', (e) => {
        const btn = e.target.closest('.zoom-btn');
        if (!btn) return;
        
        openDiagramModal(diagram);
      });
    }

    // Open diagram in modal
    function openDiagramModal(diagram) {
      // Create modal if it doesn't exist
      let modal = document.getElementById('diagram-modal');
      if (!modal) {
        modal = document.createElement('div');
        modal.id = 'diagram-modal';
        modal.className = 'diagram-modal';
        modal.innerHTML = `
          <button class="modal-close" id="modal-close">√ó</button>
          <div class="diagram-modal-content" id="modal-diagram-content"></div>
          <div class="modal-zoom-controls">
            <button class="modal-zoom-btn" data-action="zoom-in" title="Zoom In">+</button>
            <button class="modal-zoom-btn" data-action="zoom-out" title="Zoom Out">‚àí</button>
            <button class="modal-zoom-btn" data-action="reset" title="Reset Zoom">‚ü≤</button>
          </div>
        `;
        document.body.appendChild(modal);
        
        // Close modal handlers
        modal.querySelector('#modal-close').addEventListener('click', closeDiagramModal);
        modal.addEventListener('click', (e) => {
          if (e.target === modal) closeDiagramModal();
        });
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape' && modal.classList.contains('active')) {
            closeDiagramModal();
          }
        });
        
        // Zoom controls in modal
        let scale = 1;
        let translateX = 0;
        let translateY = 0;
        
        modal.querySelector('.modal-zoom-controls').addEventListener('click', (e) => {
          const btn = e.target.closest('.modal-zoom-btn');
          if (!btn) return;
          
          const action = btn.dataset.action;
          const svg = modal.querySelector('svg');
          if (!svg) return;
          
          if (action === 'zoom-in') {
            scale = Math.min(scale + 0.1, 5);
          } else if (action === 'zoom-out') {
            scale = Math.max(scale - 0.1, 0.5);
          } else if (action === 'reset') {
            scale = 1;
            translateX = 0;
            translateY = 0;
          }
          
          svg.style.transform = `scale(${scale}) translate(${translateX / scale}px, ${translateY / scale}px)`;
        });
      }
      
      // Clone diagram content
      const svg = diagram.querySelector('svg');
      if (svg) {
        const content = modal.querySelector('#modal-diagram-content');
        content.innerHTML = '';
        const clonedSvg = svg.cloneNode(true);
        clonedSvg.style.transform = 'scale(1)';
        clonedSvg.style.maxWidth = '100%';
        clonedSvg.style.height = 'auto';
        content.appendChild(clonedSvg);
      }
      
      modal.classList.add('active');
      document.body.style.overflow = 'hidden';
    }

    function closeDiagramModal() {
      const modal = document.getElementById('diagram-modal');
      if (modal) {
        modal.classList.remove('active');
        document.body.style.overflow = '';
      }
    }
    
    // Re-render on theme change
    window.rerenderMermaid = async function() {
      const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
      
      mermaid.initialize({
        startOnLoad: false,
        theme: isDark ? 'base' : 'base',
        securityLevel: 'loose',
        flowchart: {
          useMaxWidth: true,
          htmlLabels: true,
          curve: 'basis',
        },
        sequence: {
          useMaxWidth: false,
          htmlLabels: true,
          diagramMarginX: 50,
          diagramMarginY: 10
        }
      });
      
      const diagrams = document.querySelectorAll('.mermaid[data-processed="true"]');
      for (let i = 0; i < diagrams.length; i++) {
        const diagram = diagrams[i];
        const code = diagram.getAttribute('data-original-code');
        
        if (code) {
          try {
            const { svg } = await mermaid.render('mermaid-diagram-rerender-' + i + '-' + Date.now(), code);
            diagram.innerHTML = svg;
          } catch (error) {
            console.error('Mermaid re-rendering error:', error);
          }
        }
      }
    };
  </script>
</head>
<body>
  <nav class="navbar navbar-expand-lg sticky-top" aria-label="Top bar">
    <div class="container-fluid d-flex align-items-center">
      <button class="navbar-toggler me-2" id="toggleSidebar" type="button" aria-label="Toggle sidebar">
        <span class="navbar-toggler-icon"></span>
      </button>
        <span class="navbar-brand mb-0 h1 me-auto">üß± Software Architecture Patterns - In a Nutshell</span>
        <span class="contact-info mb-0">ü§ù Curated by Murthy Vepa</span>
    </div>      
  </nav>

  <div id="appContainer">
    <div class="row g-0" id="mainRow">
      <nav class="col-lg-3 border-end sidebar" id="sidebar" aria-label="Table of contents">
        <div class="menu-header py-2">Contents</div>
        <ul class="list-group list-group-flush toc" id="toc"></ul>
      </nav>

      <main id="main" class="col-lg-9 d-flex flex-column" tabindex="-1">
        <div class="content" id="content">
        <!-- Overview Section -->
        <section id="overview" role="article">
          <h1>üìñ Overview</h1>
          <span class="badge">intro</span>
          <span class="badge">overview</span>
          <span class="badge">basics</span>
          <span class="badge">architecture</span>
          
          <h2>What are Software Architecture Patterns?</h2>
          <p>
            <strong>Software Architecture Patterns</strong> are reusable, proven solutions to common architectural problems in software design. 
            They provide a structured template for organizing components, defining relationships, and establishing communication patterns 
            within software systems. These patterns guide high-level design decisions and shape the fundamental structure of applications.
          </p>
          <p>
            Unlike design patterns (which focus on code-level solutions), architecture patterns address system-wide concerns such as 
            scalability, reliability, maintainability, and deployment strategies. They define the "blueprint" of your application.
          </p>

          <h2>Why Architecture Patterns Matter</h2>
          <p>
            Choosing the right architecture pattern is one of the most critical decisions in software development. 
            It impacts everything from development speed to system performance, team collaboration, and long-term maintainability.
          </p>

          <div class="row g-3 mb-4">
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-blue">
                <div class="card-body">
                  <h3>üéØ Clear Structure</h3>
                  <p class="mb-0">Provides a well-defined structure that helps teams understand system organization and make consistent design decisions.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-green">
                <div class="card-body">
                  <h3>üìà Scalability</h3>
                  <p class="mb-0">Enables systems to grow and handle increased load by providing patterns that support horizontal and vertical scaling.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-purple">
                <div class="card-body">
                  <h3>üîß Maintainability</h3>
                  <p class="mb-0">Makes systems easier to modify, extend, and debug by establishing clear boundaries and separation of concerns.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-teal">
                <div class="card-body">
                  <h3>üöÄ Proven Solutions</h3>
                  <p class="mb-0">Leverages battle-tested approaches that have been validated across thousands of real-world implementations.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-yellow">
                <div class="card-body">
                  <h3>üë• Team Communication</h3>
                  <p class="mb-0">Provides a common vocabulary for discussing system design, improving collaboration and reducing misunderstandings.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-pink">
                <div class="card-body">
                  <h3>‚ö° Performance</h3>
                  <p class="mb-0">Addresses performance concerns through patterns optimized for specific scenarios like high throughput or low latency.</p>
                </div>
              </div>
            </div>
          </div>

          <h2>Categories of Architecture Patterns</h2>
          <p>Architecture patterns can be organized into several key categories based on their primary focus and use cases:</p>

          <div class="mermaid">
graph TB
    A[Software Architecture Patterns] --> B[Structural Patterns]
    A --> C[Distributed Patterns]
    A --> D[Data Patterns]
    A --> E[Communication Patterns]
    A --> F[Domain Patterns]
    A --> G[Cloud-Native Patterns]
    
    B --> B1[Layered Architecture]
    B --> B2[Vertical Slice]
    B --> B3[Modular Monolith]
    B --> B4[Clean Architecture]
    B --> B5[Hexagonal Architecture]
    B --> B6[Microkernel]
    
    C --> C1[Microservices]
    C --> C2[Service Mesh]
    C --> C3[API Gateway]
    C --> C4[Saga Pattern]
    
    D --> D1[Event Sourcing]
    D --> D2[CQRS]
    D --> D3[Database per Service]
    D --> D4[Sharding]
    
    E --> E1[Event-Driven]
    E --> E2[Message-Driven]
    E --> E3[RESTful APIs]
    E --> E4[GraphQL/gRPC]
    E --> E5[BFF Pattern]
    
    F --> F1[Domain-Driven Design]
    F --> F2[Bounded Contexts]
    F --> F3[Aggregates]
    F --> F4[Domain Events]
    
    G --> G1[Serverless]
    G --> G2[Strangler Fig]
    
    style A fill:#3b82f6,stroke:#2563eb,stroke-width:3px,color:#fff
    style B fill:#10b981,stroke:#059669,stroke-width:2px,color:#fff
    style C fill:#8b5cf6,stroke:#7c3aed,stroke-width:2px,color:#fff
    style D fill:#f59e0b,stroke:#d97706,stroke-width:2px,color:#fff
    style E fill:#ec4899,stroke:#db2777,stroke-width:2px,color:#fff
    style F fill:#14b8a6,stroke:#0d9488,stroke-width:2px,color:#fff
    style G fill:#0ea5e9,stroke:#0284c7,stroke-width:2px,color:#fff
          </div>

          <h2>Pattern Selection Criteria</h2>
          <p>Choosing the right architecture pattern depends on multiple factors:</p>
          
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th>Factor</th>
                <th>Questions to Ask</th>
                <th>Impact on Pattern Choice</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Scale</strong></td>
                <td>How many users? How much data?</td>
                <td>Small apps: Layered/MVC. Large scale: Microservices/Event-Driven</td>
              </tr>
              <tr>
                <td><strong>Team Size</strong></td>
                <td>How many developers? Distributed teams?</td>
                <td>Small teams: Monolith. Large teams: Microservices</td>
              </tr>
              <tr>
                <td><strong>Complexity</strong></td>
                <td>How complex is the domain?</td>
                <td>Simple: MVC/Layered. Complex: DDD/Clean Architecture</td>
              </tr>
              <tr>
                <td><strong>Performance</strong></td>
                <td>Latency requirements? Throughput needs?</td>
                <td>High performance: Event-Driven/CQRS. Standard: Layered</td>
              </tr>
              <tr>
                <td><strong>Deployment</strong></td>
                <td>Cloud vs On-premise? CI/CD maturity?</td>
                <td>Cloud-native: Microservices/Serverless. Traditional: Layered</td>
              </tr>
              <tr>
                <td><strong>Evolution</strong></td>
                <td>How often will requirements change?</td>
                <td>Frequent changes: Hexagonal/Clean. Stable: Layered</td>
              </tr>
            </tbody>
          </table>

          <h2>Common Architecture Patterns Overview</h2>
          
          <div class="row g-3 mb-4">
            <div class="col-md-12">
              <div class="card border-0 shadow-sm bg-gradient-blue-sky">
                <div class="card-body">
                  <h3>üî∑ Microservices Architecture</h3>
                  <p><strong>Best For:</strong> Large-scale applications, distributed teams, independent deployments</p>
                  <p><strong>Key Characteristics:</strong> Service decomposition, API gateways, service mesh, independent databases</p>
                  <p class="mb-0"><strong>Trade-offs:</strong> High operational complexity, eventual consistency, but excellent scalability and team autonomy</p>
                </div>
              </div>
            </div>
            
            <div class="col-md-12">
              <div class="card border-0 shadow-sm bg-gradient-green-light">
                <div class="card-body">
                  <h3>üéØ Domain-Driven Design (DDD)</h3>
                  <p><strong>Best For:</strong> Complex business domains, large enterprise applications, long-term projects</p>
                  <p><strong>Key Characteristics:</strong> Bounded contexts, aggregates, domain events, ubiquitous language</p>
                  <p class="mb-0"><strong>Trade-offs:</strong> Steep learning curve and upfront investment, but superior maintainability for complex domains</p>
                </div>
              </div>
            </div>
            
            <div class="col-md-12">
              <div class="card border-0 shadow-sm bg-gradient-purple">
                <div class="card-body">
                  <h3>‚ö° Event-Driven Architecture</h3>
                  <p><strong>Best For:</strong> Real-time systems, decoupled components, asynchronous processing</p>
                  <p><strong>Key Characteristics:</strong> Event sourcing, CQRS, message brokers, loose coupling</p>
                  <p class="mb-0"><strong>Trade-offs:</strong> Complex debugging and eventual consistency, but excellent scalability and responsiveness</p>
                </div>
              </div>
            </div>
            
            <div class="col-md-12">
              <div class="card border-0 shadow-sm bg-gradient-teal">
                <div class="card-body">
                  <h3>üèõÔ∏è Clean/Hexagonal Architecture</h3>
                  <p><strong>Best For:</strong> Applications requiring high testability, framework independence, long lifecycle</p>
                  <p><strong>Key Characteristics:</strong> Dependency inversion, ports and adapters, core business logic isolation</p>
                  <p class="mb-0"><strong>Trade-offs:</strong> More boilerplate code, but excellent testability and maintainability</p>
                </div>
              </div>
            </div>
            
            <div class="col-md-12">
              <div class="card border-0 shadow-sm bg-gradient-yellow">
                <div class="card-body">
                  <h3>üèóÔ∏è Layered Architecture</h3>
                  <p><strong>Best For:</strong> Traditional applications, small to medium teams, CRUD-heavy systems</p>
                  <p><strong>Key Characteristics:</strong> Presentation, business logic, data access layers, vertical slicing</p>
                  <p class="mb-0"><strong>Trade-offs:</strong> Can become monolithic and hard to scale, but simple to understand and implement</p>
                </div>
              </div>
            </div>
            
            <div class="col-md-12">
              <div class="card border-0 shadow-sm bg-gradient-blue">
                <div class="card-body">
                  <h3>üìä Vertical Slice Architecture</h3>
                  <p><strong>Best For:</strong> Feature-focused development, reducing coupling, rapid iteration</p>
                  <p><strong>Key Characteristics:</strong> Organized by features not layers, minimal shared code, independent slices</p>
                  <p class="mb-0"><strong>Trade-offs:</strong> Some code duplication, but better encapsulation and easier to change features independently</p>
                </div>
              </div>
            </div>
            
            <div class="col-md-12">
              <div class="card border-0 shadow-sm bg-gradient-orange">
                <div class="card-body">
                  <h3>üè¢ Modular Monolith</h3>
                  <p><strong>Best For:</strong> Starting simple with option to scale later, single deployment with clear boundaries</p>
                  <p><strong>Key Characteristics:</strong> Well-defined modules, strong boundaries, single codebase, potential to extract services later</p>
                  <p class="mb-0"><strong>Trade-offs:</strong> Requires discipline to maintain boundaries, but simpler deployment than microservices with similar modularity</p>
                </div>
              </div>
            </div>
            
            <div class="col-md-12">
              <div class="card border-0 shadow-sm bg-gradient-sky">
                <div class="card-body">
                  <h3>‚ö° Serverless Architecture</h3>
                  <p><strong>Best For:</strong> Event-driven workloads, variable traffic, pay-per-use scenarios, rapid development</p>
                  <p><strong>Key Characteristics:</strong> Function-as-a-Service (FaaS), auto-scaling, no server management, event triggers</p>
                  <p class="mb-0"><strong>Trade-offs:</strong> Vendor lock-in and cold starts, but zero infrastructure management and automatic scaling</p>
                </div>
              </div>
            </div>
          </div>

          <h2>Architecture Pattern Evolution</h2>
          <p>
            Software architecture has evolved significantly over the decades, driven by changing requirements, 
            technology advancements, and lessons learned from real-world implementations:
          </p>
          
          <div class="mermaid">
graph LR
    A[1970s-1980s<br/>Monolithic] --> B[1990s<br/>Layered/N-Tier]
    B --> C[2000s<br/>SOA/ESB]
    C --> D[2010s<br/>Microservices]
    D --> E[2015+<br/>Event-Driven]
    E --> F[2020+<br/>Cloud-Native]
    
    A --> A1[Single Process<br/>Tight Coupling]
    B --> B1[Separation of Concerns<br/>Horizontal Scaling]
    C --> C1[Service Reuse<br/>Enterprise Integration]
    D --> D1[Independent Services<br/>DevOps Culture]
    E --> E1[Reactive Systems<br/>Eventual Consistency]
    F --> F1[Serverless<br/>Kubernetes<br/>Service Mesh]
    
    style A fill:#64748b,stroke:#475569,stroke-width:2px,color:#fff
    style B fill:#8b5cf6,stroke:#7c3aed,stroke-width:2px,color:#fff
    style C fill:#f59e0b,stroke:#d97706,stroke-width:2px,color:#fff
    style D fill:#3b82f6,stroke:#2563eb,stroke-width:2px,color:#fff
    style E fill:#10b981,stroke:#059669,stroke-width:2px,color:#fff
    style F fill:#ec4899,stroke:#db2777,stroke-width:2px,color:#fff
          </div>

          <h2>Hybrid Approaches</h2>
          <p>
            Modern applications often combine multiple architecture patterns to leverage the strengths of each. 
            Common hybrid approaches include:
          </p>
          <ul>
            <li><strong>Microservices + Event-Driven:</strong> Independent services communicating through events for loose coupling</li>
            <li><strong>Microservices + Saga Pattern:</strong> Distributed transactions across services with compensating actions</li>
            <li><strong>DDD + Clean Architecture:</strong> Domain-centric design with strong dependency management</li>
            <li><strong>CQRS + Microservices:</strong> Separate read/write services for optimal performance</li>
            <li><strong>API Gateway + BFF Pattern:</strong> External routing with client-specific backend services</li>
            <li><strong>API Gateway + Service Mesh:</strong> External routing with internal service-to-service communication</li>
            <li><strong>Modular Monolith + Vertical Slice:</strong> Feature-based organization within a modular structure</li>
            <li><strong>Serverless + Event-Driven:</strong> Function-based services triggered by events for extreme scalability</li>
            <li><strong>Strangler Fig + Microservices:</strong> Gradually migrate from monolith to microservices</li>
            <li><strong>Layered + Hexagonal:</strong> Traditional layers with ports/adapters for external integrations</li>
          </ul>

          <h2>Key Principles Across All Patterns</h2>
          <p>Regardless of which pattern you choose, certain principles apply universally:</p>
          
          <div class="row g-3 mb-4">
            <div class="col-md-4">
              <div class="card border-0 shadow-sm h-100 bg-gradient-indigo">
                <div class="card-body text-white">
                  <h4>üéØ Separation of Concerns</h4>
                  <p class="mb-0">Divide system into distinct sections, each addressing a separate concern.</p>
                </div>
              </div>
            </div>
            <div class="col-md-4">
              <div class="card border-0 shadow-sm h-100 bg-gradient-green-medium">
                <div class="card-body text-white">
                  <h4>üîÑ Loose Coupling</h4>
                  <p class="mb-0">Minimize dependencies between components for flexibility and maintainability.</p>
                </div>
              </div>
            </div>
            <div class="col-md-4">
              <div class="card border-0 shadow-sm h-100 bg-gradient-orange">
                <div class="card-body text-white">
                  <h4>üì¶ High Cohesion</h4>
                  <p class="mb-0">Keep related functionality together within the same component or module.</p>
                </div>
              </div>
            </div>
            <div class="col-md-4">
              <div class="card border-0 shadow-sm h-100 bg-gradient-violet">
                <div class="card-body text-white">
                  <h4>üîê Encapsulation</h4>
                  <p class="mb-0">Hide implementation details and expose only necessary interfaces.</p>
                </div>
              </div>
            </div>
            <div class="col-md-4">
              <div class="card border-0 shadow-sm h-100 bg-gradient-sky">
                <div class="card-body text-white">
                  <h4>üé® Abstraction</h4>
                  <p class="mb-0">Work with higher-level concepts rather than low-level implementation details.</p>
                </div>
              </div>
            </div>
            <div class="col-md-4">
              <div class="card border-0 shadow-sm h-100 bg-gradient-lime">
                <div class="card-body text-white">
                  <h4>üîß Modularity</h4>
                  <p class="mb-0">Design systems as composable modules that can be independently developed and deployed.</p>
                </div>
              </div>
            </div>
          </div>

          <div class="callout">
            <strong>üí° Key Takeaway:</strong> There is no "one-size-fits-all" architecture pattern. The best pattern depends on your 
            specific requirements, constraints, and context. Start simple, evolve as needed, and don't over-engineer for problems 
            you don't have yet. Many successful systems begin with a simple layered architecture and evolve into more complex 
            patterns as scale and complexity demands increase. Understanding multiple patterns gives you the flexibility to choose 
            the right tool for the job and combine patterns when beneficial.
          </div>

          <h2>How to Use This Guide</h2>
          <p>
            This guide is organized to help you understand and apply software architecture patterns effectively:
          </p>
          <ul>
            <li><strong>Start with fundamentals:</strong> Each major pattern has a dedicated section explaining its core concepts</li>
            <li><strong>See practical examples:</strong> Real-world code examples demonstrate implementation approaches</li>
            <li><strong>Understand trade-offs:</strong> Every pattern includes pros, cons, and when to use it</li>
            <li><strong>Explore combinations:</strong> Learn how patterns work together in hybrid architectures</li>
            <li><strong>Reference best practices:</strong> Follow industry-proven guidelines for each pattern</li>
          </ul>

        </section>

        <!-- Microservices Architecture Section -->
        <section id="microservices" role="article">
          <h1>üî∑ Microservices Architecture</h1>
          <span class="badge">microservices</span>
          <span class="badge">distributed</span>
          <span class="badge">scalability</span>
          
          <h2>What is Microservices Architecture?</h2>
          <p>
            <strong>Microservices Architecture</strong> is an architectural style that structures an application as a collection of 
            small, autonomous services modeled around a business domain. Each service is self-contained, independently deployable, 
            and communicates with other services through well-defined APIs.
          </p>
          <p>
            Unlike monolithic applications where all functionality is built as a single unit, microservices break down the application 
            into smaller, loosely coupled services that can be developed, deployed, and scaled independently by different teams.
          </p>

          <h2>Core Characteristics</h2>
          <div class="row g-3 mb-4">
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-blue">
                <div class="card-body">
                  <h3>üéØ Single Responsibility</h3>
                  <p class="mb-0">Each microservice focuses on doing one thing well, representing a specific business capability or domain.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-green">
                <div class="card-body">
                  <h3>üöÄ Independent Deployment</h3>
                  <p class="mb-0">Services can be deployed independently without affecting other services, enabling faster release cycles.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-purple">
                <div class="card-body">
                  <h3>üìä Decentralized Data</h3>
                  <p class="mb-0">Each service manages its own database, ensuring loose coupling and data autonomy.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-orange">
                <div class="card-body">
                  <h3>üîß Technology Diversity</h3>
                  <p class="mb-0">Different services can use different technologies, languages, and frameworks based on their needs.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-teal">
                <div class="card-body">
                  <h3>üåê API-First Communication</h3>
                  <p class="mb-0">Services communicate through well-defined APIs (REST, gRPC, messaging) with clear contracts.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-pink">
                <div class="card-body">
                  <h3>‚ö° Fault Isolation</h3>
                  <p class="mb-0">Failures in one service don't cascade to others, improving overall system resilience.</p>
                </div>
              </div>
            </div>
          </div>

          <h2>Microservices Architecture Pattern</h2>
          <div class="mermaid">
graph TB
    Client[Client Applications]
    Gateway[API Gateway]
    
    Gateway --> Auth[Auth Service]
    Gateway --> User[User Service]
    Gateway --> Order[Order Service]
    Gateway --> Product[Product Service]
    Gateway --> Payment[Payment Service]
    Gateway --> Notification[Notification Service]
    
    Auth --> AuthDB[(Auth DB)]
    User --> UserDB[(User DB)]
    Order --> OrderDB[(Order DB)]
    Product --> ProductDB[(Product DB)]
    Payment --> PaymentDB[(Payment DB)]
    
    Order -.Message Bus.-> Notification
    Payment -.Message Bus.-> Notification
    Order -.Message Bus.-> Payment
    
    Client --> Gateway
    
    style Client fill:#64748b,stroke:#475569,stroke-width:2px,color:#fff
    style Gateway fill:#3b82f6,stroke:#2563eb,stroke-width:3px,color:#fff
    style Auth fill:#10b981,stroke:#059669,stroke-width:2px,color:#fff
    style User fill:#10b981,stroke:#059669,stroke-width:2px,color:#fff
    style Order fill:#10b981,stroke:#059669,stroke-width:2px,color:#fff
    style Product fill:#10b981,stroke:#059669,stroke-width:2px,color:#fff
    style Payment fill:#10b981,stroke:#059669,stroke-width:2px,color:#fff
    style Notification fill:#10b981,stroke:#059669,stroke-width:2px,color:#fff
          </div>

          <h2>Monolith vs Microservices</h2>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th>Aspect</th>
                <th>Monolithic</th>
                <th>Microservices</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Deployment</strong></td>
                <td>Single unit, all-or-nothing</td>
                <td>Independent service deployment</td>
              </tr>
              <tr>
                <td><strong>Scaling</strong></td>
                <td>Scale entire application</td>
                <td>Scale individual services</td>
              </tr>
              <tr>
                <td><strong>Technology Stack</strong></td>
                <td>Uniform across application</td>
                <td>Different per service</td>
              </tr>
              <tr>
                <td><strong>Team Structure</strong></td>
                <td>Single team or layered teams</td>
                <td>Cross-functional teams per service</td>
              </tr>
              <tr>
                <td><strong>Failure Impact</strong></td>
                <td>Entire app goes down</td>
                <td>Isolated to single service</td>
              </tr>
              <tr>
                <td><strong>Development Speed</strong></td>
                <td>Slower as app grows</td>
                <td>Faster with parallel development</td>
              </tr>
              <tr>
                <td><strong>Data Management</strong></td>
                <td>Single shared database</td>
                <td>Database per service</td>
              </tr>
              <tr>
                <td><strong>Complexity</strong></td>
                <td>Lower operational complexity</td>
                <td>Higher operational complexity</td>
              </tr>
            </tbody>
          </table>

          <h2>Key Benefits</h2>
          <ul>
            <li><strong>Scalability:</strong> Scale services independently based on demand rather than scaling entire application</li>
            <li><strong>Team Autonomy:</strong> Teams can work independently on different services without stepping on each other</li>
            <li><strong>Faster Time to Market:</strong> Deploy changes to individual services without waiting for full release cycle</li>
            <li><strong>Resilience:</strong> Circuit breakers and bulkheads prevent cascading failures across services</li>
            <li><strong>Technology Freedom:</strong> Choose the best technology for each service without being locked into single stack</li>
            <li><strong>Easier Maintenance:</strong> Smaller codebases are easier to understand, test, and maintain</li>
          </ul>

          <h2>Key Challenges</h2>
          <ul>
            <li><strong>Distributed System Complexity:</strong> Network latency, partial failures, eventual consistency</li>
            <li><strong>Data Management:</strong> Distributed transactions, maintaining data consistency across services</li>
            <li><strong>Testing:</strong> Integration testing across multiple services, contract testing complexity</li>
            <li><strong>Deployment Coordination:</strong> Managing multiple deployments, versioning, and rollbacks</li>
            <li><strong>Monitoring & Debugging:</strong> Distributed tracing, centralized logging, observability requirements</li>
            <li><strong>Operational Overhead:</strong> More moving parts, infrastructure management, DevOps investment</li>
          </ul>

          <h2>When to Use Microservices</h2>
          <div class="row g-3 mb-4">
            <div class="col-md-12">
              <div class="card border-0 shadow-sm bg-gradient-green-light">
                <div class="card-body">
                  <h3>‚úÖ Good Fit</h3>
                  <ul class="mb-0">
                    <li>Large, complex applications with multiple business domains</li>
                    <li>Multiple teams working on the same application</li>
                    <li>Different parts of application have different scaling requirements</li>
                    <li>Need for frequent, independent deployments</li>
                    <li>Mature DevOps culture and infrastructure automation</li>
                    <li>Long-term project with evolving requirements</li>
                  </ul>
                </div>
              </div>
            </div>
            <div class="col-md-12">
              <div class="card border-0 shadow-sm bg-gradient-red">
                <div class="card-body">
                  <h3>‚ùå Poor Fit</h3>
                  <ul class="mb-0">
                    <li>Small applications with simple requirements</li>
                    <li>Small team without DevOps expertise</li>
                    <li>Tight budget constraints for infrastructure</li>
                    <li>Limited operational capabilities</li>
                    <li>Application with few changes or updates</li>
                    <li>Startup in MVP phase (consider modular monolith first)</li>
                  </ul>
                </div>
              </div>
            </div>
          </div>

          <div class="callout">
            <strong>üí° Key Takeaway:</strong> Microservices are not a silver bullet. They solve certain problems (scalability, team autonomy, 
            independent deployment) but introduce new challenges (distributed system complexity, operational overhead). Start with a 
            well-structured monolith or modular monolith, and migrate to microservices when you have clear evidence that you need them. 
            Consider the "Strangler Fig" pattern for gradual migration.
          </div>
        </section>

        <!-- Service Decomposition Section -->
        <section id="service-decomposition" role="article">
          <h1>Service Decomposition</h1>
          <span class="badge">microservices</span>
          <span class="badge">decomposition</span>
          <span class="badge">design</span>
          
          <h2>What is Service Decomposition?</h2>
          <p>
            <strong>Service Decomposition</strong> is the process of breaking down a monolithic application or business domain into 
            smaller, independent microservices. It's one of the most critical decisions in microservices architecture, as poor 
            decomposition leads to chatty services, data inconsistencies, and tight coupling.
          </p>

          <h2>Decomposition Strategies</h2>
          
          <h3>1. Decompose by Business Capability</h3>
          <p>
            Organize services around business capabilities from the business architecture. Each service implements a specific business 
            capability and owns all data needed to fulfill that capability.
          </p>
          <div class="mermaid">
graph TB
    Business[E-Commerce Business]
    
    Business --> Catalog[Product Catalog]
    Business --> Order[Order Management]
    Business --> Payment[Payment Processing]
    Business --> Shipping[Shipping & Delivery]
    Business --> Customer[Customer Management]
    Business --> Inventory[Inventory Management]
    
    Catalog --> CatalogDB[(Catalog DB)]
    Order --> OrderDB[(Order DB)]
    Payment --> PaymentDB[(Payment DB)]
    Shipping --> ShippingDB[(Shipping DB)]
    Customer --> CustomerDB[(Customer DB)]
    Inventory --> InventoryDB[(Inventory DB)]
    
    style Business fill:#3b82f6,stroke:#2563eb,stroke-width:3px,color:#fff
    style Catalog fill:#10b981,stroke:#059669,stroke-width:2px,color:#fff
    style Order fill:#10b981,stroke:#059669,stroke-width:2px,color:#fff
    style Payment fill:#10b981,stroke:#059669,stroke-width:2px,color:#fff
    style Shipping fill:#10b981,stroke:#059669,stroke-width:2px,color:#fff
    style Customer fill:#10b981,stroke:#059669,stroke-width:2px,color:#fff
    style Inventory fill:#10b981,stroke:#059669,stroke-width:2px,color:#fff
          </div>

          <h3>2. Decompose by Subdomain (DDD Approach)</h3>
          <p>
            Use Domain-Driven Design to identify bounded contexts and subdomains. Each bounded context becomes a microservice with 
            clear boundaries and its own ubiquitous language.
          </p>

          <div class="row g-3 mb-4">
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-blue">
                <div class="card-body">
                  <h4>Core Subdomain</h4>
                  <p class="mb-0">Key business differentiator, highest value. Example: Order Processing, Product Recommendation Engine</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-yellow">
                <div class="card-body">
                  <h4>Supporting Subdomain</h4>
                  <p class="mb-0">Necessary but not differentiating. Example: Inventory Management, Shipping</p>
                </div>
              </div>
            </div>
            <div class="col-md-12">
              <div class="card border-0 shadow-sm bg-gradient-gray">
                <div class="card-body">
                  <h4>Generic Subdomain</h4>
                  <p class="mb-0">Common functionality that can be bought or reused. Example: Authentication, Notifications, Email</p>
                </div>
              </div>
            </div>
          </div>

          <h2>Decomposition Guidelines</h2>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th>Principle</th>
                <th>Description</th>
                <th>Example</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Single Responsibility</strong></td>
                <td>Each service has one reason to change</td>
                <td>Payment Service only handles payment processing</td>
              </tr>
              <tr>
                <td><strong>Loose Coupling</strong></td>
                <td>Minimize dependencies between services</td>
                <td>Services communicate via APIs, not shared databases</td>
              </tr>
              <tr>
                <td><strong>High Cohesion</strong></td>
                <td>Related functionality stays together</td>
                <td>All order-related operations in Order Service</td>
              </tr>
              <tr>
                <td><strong>Autonomous</strong></td>
                <td>Service can operate independently</td>
                <td>Can deploy without coordinating with other services</td>
              </tr>
              <tr>
                <td><strong>Data Ownership</strong></td>
                <td>Each service owns its data</td>
                <td>Only Order Service can write to Order DB</td>
              </tr>
            </tbody>
          </table>

          <h2>Common Decomposition Anti-Patterns</h2>
          <ul>
            <li><strong>Too Fine-Grained:</strong> Nano-services that require excessive inter-service communication</li>
            <li><strong>Data-Driven Decomposition:</strong> Splitting by database tables instead of business capability</li>
            <li><strong>Shared Database:</strong> Multiple services reading/writing to same database tables</li>
            <li><strong>Distributed Monolith:</strong> Services that must be deployed together due to tight coupling</li>
            <li><strong>CRUD Services:</strong> Services that are just thin wrappers around database operations</li>
          </ul>

          <h2>Service Sizing Guidelines</h2>
          <p>How big should a microservice be? Consider these factors:</p>
          <ul>
            <li><strong>Team Size:</strong> Service should be maintainable by a small team (2-pizza rule: 5-9 people)</li>
            <li><strong>Codebase Size:</strong> Should be rewritable in 2-4 weeks if needed</li>
            <li><strong>Single Bounded Context:</strong> Represents one bounded context from DDD perspective</li>
            <li><strong>Independent Deployment:</strong> Can be deployed without coordinating with other teams</li>
            <li><strong>Resource Requirements:</strong> Has distinct scaling and resource needs</li>
          </ul>

          <div class="callout">
            <strong>üí° Key Takeaway:</strong> Start with larger services (mini-services) and split them later as you learn more about 
            the domain and identify clear boundaries. It's easier to split services than to merge them. Focus on business capabilities 
            and bounded contexts rather than technical layers. When in doubt, keep things together until you have a compelling reason 
            to separate them.
          </div>
        </section>

        <!-- API Gateway Section -->
        <section id="api-gateway" role="article">
          <h1>API Gateway Pattern</h1>
          <span class="badge">microservices</span>
          <span class="badge">gateway</span>
          <span class="badge">routing</span>
          
          <h2>What is an API Gateway?</h2>
          <p>
            An <strong>API Gateway</strong> is a server that acts as a single entry point for all clients into a microservices-based 
            application. It sits between clients and backend services, routing requests, aggregating responses, and providing 
            cross-cutting concerns like authentication, rate limiting, and monitoring.
          </p>

          <h2>API Gateway Pattern</h2>
          <div class="mermaid">
graph LR
    Mobile[Mobile App]
    Web[Web App]
    Partner[Partner API]
    
    Mobile --> Gateway[API Gateway]
    Web --> Gateway
    Partner --> Gateway
    
    Gateway --> Auth[Auth Service]
    Gateway --> User[User Service]
    Gateway --> Order[Order Service]
    Gateway --> Product[Product Service]
    Gateway --> Payment[Payment Service]
    
    Gateway -.Cross-Cutting.-> Security[Security]
    Gateway -.Cross-Cutting.-> RateLimit[Rate Limiting]
    Gateway -.Cross-Cutting.-> Logging[Logging]
    Gateway -.Cross-Cutting.-> Monitoring[Monitoring]
    
    style Gateway fill:#3b82f6,stroke:#2563eb,stroke-width:3px,color:#fff
    style Mobile fill:#64748b,stroke:#475569,stroke-width:2px,color:#fff
    style Web fill:#64748b,stroke:#475569,stroke-width:2px,color:#fff
    style Partner fill:#64748b,stroke:#475569,stroke-width:2px,color:#fff
          </div>

          <h2>Core Responsibilities</h2>
          <div class="row g-3 mb-4">
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-blue">
                <div class="card-body">
                  <h3>üîÄ Request Routing</h3>
                  <p class="mb-0">Route incoming requests to appropriate backend services based on URL, headers, or other criteria.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-green">
                <div class="card-body">
                  <h3>üîê Authentication & Authorization</h3>
                  <p class="mb-0">Validate tokens, enforce security policies, and handle authentication before routing to services.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-purple">
                <div class="card-body">
                  <h3>üìä Request/Response Transformation</h3>
                  <p class="mb-0">Transform data formats, aggregate responses from multiple services, adapt protocols.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-orange">
                <div class="card-body">
                  <h3>‚ö° Rate Limiting & Throttling</h3>
                  <p class="mb-0">Protect backend services from overload by limiting request rates per client or API key.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-teal">
                <div class="card-body">
                  <h3>üìù Logging & Monitoring</h3>
                  <p class="mb-0">Centralized logging, metrics collection, and monitoring for all API traffic.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-pink">
                <div class="card-body">
                  <h3>üíæ Caching</h3>
                  <p class="mb-0">Cache responses to reduce load on backend services and improve response times.</p>
                </div>
              </div>
            </div>
          </div>

          <h2>Gateway Patterns</h2>
          
          <h3>1. Single Gateway Pattern</h3>
          <p>One gateway for all clients - simplest but can become bottleneck.</p>
          
          <h3>2. Gateway per Client Type (Backend for Frontend)</h3>
          <p>Separate gateways for mobile, web, and partners - optimized for each client's needs.</p>
          
          <h3>3. Gateway Aggregation Pattern</h3>
          <p>Gateway aggregates calls to multiple services into single response for clients.</p>

          <h2>Benefits of API Gateway</h2>
          <ul>
            <li><strong>Single Entry Point:</strong> Clients don't need to know about multiple service endpoints</li>
            <li><strong>Simplified Client Code:</strong> Clients make fewer calls, gateway handles aggregation</li>
            <li><strong>Reduced Round Trips:</strong> Aggregate multiple service calls into single gateway call</li>
            <li><strong>Centralized Cross-Cutting Concerns:</strong> Authentication, logging, rate limiting in one place</li>
            <li><strong>Protocol Translation:</strong> Convert between protocols (HTTP to gRPC, REST to GraphQL)</li>
            <li><strong>Service Discovery:</strong> Gateway handles locating and routing to service instances</li>
          </ul>

          <h2>Challenges & Considerations</h2>
          <ul>
            <li><strong>Single Point of Failure:</strong> Gateway must be highly available and scalable</li>
            <li><strong>Increased Latency:</strong> Additional hop adds latency to every request</li>
            <li><strong>Complexity:</strong> Gateway logic can become complex with many services</li>
            <li><strong>Development Bottleneck:</strong> Changes may require gateway updates</li>
            <li><strong>Ownership:</strong> Who owns the gateway? Platform team vs. service teams</li>
          </ul>

          <h2>Popular API Gateway Solutions</h2>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th>Solution</th>
                <th>Type</th>
                <th>Best For</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Azure API Management</strong></td>
                <td>Cloud Managed</td>
                <td>Azure-native applications, enterprise features</td>
              </tr>
              <tr>
                <td><strong>AWS API Gateway</strong></td>
                <td>Cloud Managed</td>
                <td>AWS Lambda, serverless applications</td>
              </tr>
              <tr>
                <td><strong>Kong</strong></td>
                <td>Open Source/Enterprise</td>
                <td>High performance, plugin ecosystem</td>
              </tr>
              <tr>
                <td><strong>NGINX</strong></td>
                <td>Open Source/Plus</td>
                <td>High performance, reverse proxy</td>
              </tr>
              <tr>
                <td><strong>Envoy</strong></td>
                <td>Open Source</td>
                <td>Cloud-native, service mesh integration</td>
              </tr>
              <tr>
                <td><strong>Ocelot (.NET)</strong></td>
                <td>Open Source</td>
                <td>.NET Core microservices</td>
              </tr>
            </tbody>
          </table>

          <div class="callout">
            <strong>üí° Key Takeaway:</strong> API Gateway is essential for microservices but must be designed for high availability 
            and low latency. Keep gateway logic simple - it should route and transform, not contain business logic. Consider the 
            BFF (Backend for Frontend) pattern for different client types with distinct needs. Monitor gateway performance closely 
            as it affects all API calls.
          </div>
        </section>

        <!-- Service Mesh Section -->
        <section id="service-mesh" role="article">
          <h1>Service Mesh</h1>
          <span class="badge">microservices</span>
          <span class="badge">communication</span>
          <span class="badge">infrastructure</span>
          
          <h2>What is a Service Mesh?</h2>
          <p>
            A <strong>Service Mesh</strong> is a dedicated infrastructure layer that handles service-to-service communication in a 
            microservices architecture. It provides capabilities like traffic management, security, and observability without requiring 
            changes to application code. Services communicate through lightweight network proxies (sidecars) deployed alongside each service.
          </p>

          <h2>Service Mesh Architecture</h2>
          <div class="mermaid">
graph TB
    subgraph Service A
        A[Service A Code]
        ProxyA[Sidecar Proxy]
        A <--> ProxyA
    end
    
    subgraph Service B
        B[Service B Code]
        ProxyB[Sidecar Proxy]
        B <--> ProxyB
    end
    
    subgraph Service C
        C[Service C Code]
        ProxyC[Sidecar Proxy]
        C <--> ProxyC
    end
    
    ProxyA <-.Service Mesh.-> ProxyB
    ProxyB <-.Service Mesh.-> ProxyC
    ProxyA <-.Service Mesh.-> ProxyC
    
    Control[Control Plane]
    Control -.Configuration.-> ProxyA
    Control -.Configuration.-> ProxyB
    Control -.Configuration.-> ProxyC
    
    style Control fill:#3b82f6,stroke:#2563eb,stroke-width:3px,color:#fff
    style ProxyA fill:#10b981,stroke:#059669,stroke-width:2px,color:#fff
    style ProxyB fill:#10b981,stroke:#059669,stroke-width:2px,color:#fff
    style ProxyC fill:#10b981,stroke:#059669,stroke-width:2px,color:#fff
          </div>

          <h2>Key Components</h2>
          
          <h3>Data Plane</h3>
          <p>
            Consists of lightweight proxies (sidecars) deployed alongside each service instance. Handles all network communication 
            between services, enforcing policies, collecting telemetry, and managing traffic.
          </p>

          <h3>Control Plane</h3>
          <p>
            Manages and configures the sidecar proxies. Provides APIs for configuration, policy management, and certificate distribution. 
            Collects metrics and telemetry from data plane.
          </p>

          <h2>Core Capabilities</h2>
          <div class="row g-3 mb-4">
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-blue">
                <div class="card-body">
                  <h3>üîÄ Traffic Management</h3>
                  <p class="mb-0">Load balancing, circuit breaking, retry logic, timeout handling, traffic splitting for canary deployments.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-green">
                <div class="card-body">
                  <h3>üîê Security</h3>
                  <p class="mb-0">Mutual TLS (mTLS), certificate management, authentication, authorization between services.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-purple">
                <div class="card-body">
                  <h3>üìä Observability</h3>
                  <p class="mb-0">Distributed tracing, metrics collection, request logging, service dependency mapping.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-orange">
                <div class="card-body">
                  <h3>üéØ Service Discovery</h3>
                  <p class="mb-0">Automatic service discovery, health checking, load balancing across service instances.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-teal">
                <div class="card-body">
                  <h3>üõ°Ô∏è Resilience</h3>
                  <p class="mb-0">Automatic retries, circuit breakers, fault injection for chaos testing, bulkhead isolation.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-pink">
                <div class="card-body">
                  <h3>‚öôÔ∏è Policy Enforcement</h3>
                  <p class="mb-0">Rate limiting, access control, quota management applied consistently across services.</p>
                </div>
              </div>
            </div>
          </div>

          <h2>Benefits of Service Mesh</h2>
          <ul>
            <li><strong>Separation of Concerns:</strong> Move networking logic out of application code into infrastructure</li>
            <li><strong>Consistent Security:</strong> Enforce mTLS and security policies uniformly across all services</li>
            <li><strong>Better Observability:</strong> Automatic metrics, tracing, and logging without code changes</li>
            <li><strong>Traffic Control:</strong> Advanced deployment strategies (blue-green, canary) without application changes</li>
            <li><strong>Polyglot Support:</strong> Works with services in different languages and frameworks</li>
            <li><strong>Reduced Development Burden:</strong> Developers focus on business logic, not networking concerns</li>
          </ul>

          <h2>When to Use Service Mesh</h2>
          <div class="row g-3 mb-4">
            <div class="col-md-12">
              <div class="card border-0 shadow-sm bg-gradient-green-light">
                <div class="card-body">
                  <h3>‚úÖ Good Fit</h3>
                  <ul class="mb-0">
                    <li>Large number of microservices (20+)</li>
                    <li>Multiple teams with polyglot services</li>
                    <li>Strong security requirements (mTLS, zero-trust)</li>
                    <li>Need for advanced traffic management and observability</li>
                    <li>Kubernetes-based infrastructure</li>
                  </ul>
                </div>
              </div>
            </div>
            <div class="col-md-12">
              <div class="card border-0 shadow-sm bg-gradient-red">
                <div class="card-body">
                  <h3>‚ùå Overkill For</h3>
                  <ul class="mb-0">
                    <li>Small number of services (< 10)</li>
                    <li>Simple service-to-service communication needs</li>
                    <li>Limited operational resources</li>
                    <li>Services already handle their own resilience</li>
                  </ul>
                </div>
              </div>
            </div>
          </div>

          <h2>Popular Service Mesh Solutions</h2>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th>Solution</th>
                <th>Proxy</th>
                <th>Best For</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Istio</strong></td>
                <td>Envoy</td>
                <td>Feature-rich, Kubernetes-native, enterprise-grade</td>
              </tr>
              <tr>
                <td><strong>Linkerd</strong></td>
                <td>linkerd2-proxy</td>
                <td>Lightweight, simple, CNCF graduated</td>
              </tr>
              <tr>
                <td><strong>Consul Connect</strong></td>
                <td>Envoy</td>
                <td>Multi-platform, HashiCorp ecosystem</td>
              </tr>
              <tr>
                <td><strong>AWS App Mesh</strong></td>
                <td>Envoy</td>
                <td>AWS-native applications</td>
              </tr>
              <tr>
                <td><strong>Dapr</strong></td>
                <td>Multiple</td>
                <td>Sidecar pattern, multi-platform, building blocks approach</td>
              </tr>
            </tbody>
          </table>

          <div class="callout">
            <strong>üí° Key Takeaway:</strong> Service mesh adds significant complexity and should only be adopted when you have clear 
            needs for its capabilities. Start with simpler solutions (API Gateway, client libraries) and move to service mesh when 
            managing cross-cutting concerns in application code becomes unmanageable. Ensure your team has the operational expertise 
            to run and troubleshoot a service mesh before adoption.
          </div>
        </section>

        <!-- Saga Pattern Section -->
        <section id="saga-pattern" role="article">
          <h1>Saga Pattern</h1>
          <span class="badge">microservices</span>
          <span class="badge">transactions</span>
          <span class="badge">distributed</span>
          
          <h2>What is the Saga Pattern?</h2>
          <p>
            The <strong>Saga Pattern</strong> is a design pattern for managing distributed transactions across multiple microservices. 
            Instead of using traditional ACID transactions, a saga breaks down a transaction into a series of local transactions, each 
            updating a single service. If any step fails, compensating transactions are executed to undo the changes.
          </p>
          <p>
            Sagas are essential in microservices because distributed transactions (two-phase commit) don't scale well and violate 
            service autonomy. Sagas provide eventual consistency while maintaining data integrity.
          </p>

          <h2>Saga Implementations</h2>
          
          <h3>1. Choreography-Based Saga</h3>
          <p>
            Services communicate through events. Each service listens for events, performs its local transaction, and publishes an 
            event for the next service. No central coordinator.
          </p>
          
          <div class="mermaid">
sequenceDiagram
    participant Order
    participant Payment
    participant Inventory
    participant Shipping
    
    Order->>Order: Create Order
    Order->>Payment: OrderCreated Event
    Payment->>Payment: Process Payment
    Payment->>Inventory: PaymentCompleted Event
    Inventory->>Inventory: Reserve Items
    Inventory->>Shipping: ItemsReserved Event
    Shipping->>Shipping: Schedule Delivery
    Shipping->>Order: DeliveryScheduled Event
    Order->>Order: Complete Order
          </div>

          <h3>2. Orchestration-Based Saga</h3>
          <p>
            A central orchestrator (saga coordinator) tells each service what to do. The orchestrator manages the saga's state and 
            decides which step to execute next.
          </p>

          <div class="mermaid">
sequenceDiagram
    participant Client
    participant Orchestrator
    participant Order
    participant Payment
    participant Inventory
    participant Shipping
    
    Client->>Orchestrator: Create Order
    Orchestrator->>Order: Create Order
    Order-->>Orchestrator: Order Created
    Orchestrator->>Payment: Process Payment
    Payment-->>Orchestrator: Payment Success
    Orchestrator->>Inventory: Reserve Items
    Inventory-->>Orchestrator: Items Reserved
    Orchestrator->>Shipping: Schedule Delivery
    Shipping-->>Orchestrator: Delivery Scheduled
    Orchestrator-->>Client: Order Complete
          </div>

          <h2>Choreography vs Orchestration</h2>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th>Aspect</th>
                <th>Choreography</th>
                <th>Orchestration</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Coordination</strong></td>
                <td>Decentralized, event-driven</td>
                <td>Centralized orchestrator</td>
              </tr>
              <tr>
                <td><strong>Complexity</strong></td>
                <td>Distributed across services</td>
                <td>Centralized in orchestrator</td>
              </tr>
              <tr>
                <td><strong>Coupling</strong></td>
                <td>Loose coupling</td>
                <td>Services coupled to orchestrator</td>
              </tr>
              <tr>
                <td><strong>Understanding</strong></td>
                <td>Hard to understand flow</td>
                <td>Easy to understand flow</td>
              </tr>
              <tr>
                <td><strong>Testing</strong></td>
                <td>Complex end-to-end testing</td>
                <td>Easier to test</td>
              </tr>
              <tr>
                <td><strong>Best For</strong></td>
                <td>Simple workflows, few steps</td>
                <td>Complex workflows, many steps</td>
              </tr>
            </tbody>
          </table>

          <h2>Compensating Transactions</h2>
          <p>
            When a step in a saga fails, compensating transactions undo the previous steps. Each step must have a corresponding 
            compensating action.
          </p>

          <div class="mermaid">
sequenceDiagram
    participant Order
    participant Payment
    participant Inventory
    participant Shipping
    
    Order->>Order: Create Order ‚úì
    Order->>Payment: OrderCreated Event
    Payment->>Payment: Process Payment ‚úì
    Payment->>Inventory: PaymentCompleted Event
    Inventory->>Inventory: Reserve Items ‚úó FAILED
    Inventory->>Payment: Compensate: Refund Payment
    Payment->>Payment: Refund ‚úì
    Payment->>Order: Compensate: Cancel Order
    Order->>Order: Cancel Order ‚úì
          </div>

          <h2>Saga Design Considerations</h2>
          <ul>
            <li><strong>Idempotency:</strong> Operations must be idempotent to handle retries safely</li>
            <li><strong>Compensatable:</strong> Every step must have a compensating transaction</li>
            <li><strong>Ordering:</strong> Order operations from least to most likely to fail</li>
            <li><strong>Isolation:</strong> Handle concurrent saga executions (semantic lock pattern)</li>
            <li><strong>Observability:</strong> Track saga state and progress for debugging</li>
            <li><strong>Timeout Handling:</strong> Define timeout policies and failure handling</li>
          </ul>

          <h2>Benefits of Saga Pattern</h2>
          <ul>
            <li><strong>Maintains Data Consistency:</strong> Ensures eventual consistency across services</li>
            <li><strong>Service Autonomy:</strong> Each service manages its own database independently</li>
            <li><strong>Scalability:</strong> No distributed locks, better performance than 2PC</li>
            <li><strong>Resilience:</strong> Can handle long-running transactions</li>
            <li><strong>Flexibility:</strong> Services can use different database technologies</li>
          </ul>

          <h2>Challenges</h2>
          <ul>
            <li><strong>Complexity:</strong> More complex than traditional ACID transactions</li>
            <li><strong>Debugging:</strong> Difficult to trace and debug distributed workflows</li>
            <li><strong>Lack of Isolation:</strong> Changes are visible before saga completes</li>
            <li><strong>Compensating Logic:</strong> Writing compensating transactions is complex</li>
            <li><strong>Error Handling:</strong> Must handle partial failures gracefully</li>
          </ul>

          <h2>Saga Frameworks & Tools</h2>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th>Tool</th>
                <th>Type</th>
                <th>Language</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Eventuate Tram Saga</strong></td>
                <td>Orchestration</td>
                <td>Java</td>
              </tr>
              <tr>
                <td><strong>NServiceBus Saga</strong></td>
                <td>Orchestration</td>
                <td>.NET</td>
              </tr>
              <tr>
                <td><strong>MassTransit Saga</strong></td>
                <td>Orchestration</td>
                <td>.NET</td>
              </tr>
              <tr>
                <td><strong>Temporal</strong></td>
                <td>Orchestration</td>
                <td>Multi-language</td>
              </tr>
              <tr>
                <td><strong>Apache Camel</strong></td>
                <td>Both</td>
                <td>Java</td>
              </tr>
              <tr>
                <td><strong>Dapr Workflow</strong></td>
                <td>Orchestration</td>
                <td>Multi-language</td>
              </tr>
            </tbody>
          </table>

          <div class="callout">
            <strong>üí° Key Takeaway:</strong> Sagas are essential for managing distributed transactions in microservices, but they 
            add significant complexity. Choose orchestration for complex workflows with many steps and better observability. Use 
            choreography for simple workflows where loose coupling is paramount. Always design compensating transactions upfront, 
            make operations idempotent, and implement comprehensive monitoring to track saga execution and failures.
          </div>
        </section>

        <!-- Domain-Driven Design Section -->
        <section id="ddd" role="article">
          <h1>üéØ Domain-Driven Design (DDD)</h1>
          <span class="badge">ddd</span>
          <span class="badge">domain</span>
          <span class="badge">design</span>
          
          <h2>What is Domain-Driven Design?</h2>
          <p>
            <strong>Domain-Driven Design (DDD)</strong> is an approach to software development that emphasizes collaboration between 
            technical experts and domain experts to create a shared understanding of the business domain. DDD provides patterns and 
            practices for modeling complex business logic and organizing code around business capabilities.
          </p>
          <p>
            Introduced by Eric Evans in 2003, DDD focuses on creating a <strong>ubiquitous language</strong> - a common vocabulary 
            shared by developers and domain experts - and structuring the codebase to reflect the mental model of the domain.
          </p>

          <h2>Strategic vs Tactical Design</h2>
          <div class="row g-3 mb-4">
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-blue">
                <div class="card-body">
                  <h3>üó∫Ô∏è Strategic Design</h3>
                  <p><strong>Focus:</strong> High-level domain organization</p>
                  <p><strong>Key Concepts:</strong></p>
                  <ul class="mb-0">
                    <li>Bounded Contexts</li>
                    <li>Context Mapping</li>
                    <li>Ubiquitous Language</li>
                    <li>Core/Supporting/Generic Subdomains</li>
                  </ul>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-green">
                <div class="card-body">
                  <h3>‚öôÔ∏è Tactical Design</h3>
                  <p><strong>Focus:</strong> Code-level implementation patterns</p>
                  <p><strong>Key Concepts:</strong></p>
                  <ul class="mb-0">
                    <li>Entities & Value Objects</li>
                    <li>Aggregates & Aggregate Roots</li>
                    <li>Domain Events</li>
                    <li>Repositories & Services</li>
                  </ul>
                </div>
              </div>
            </div>
          </div>

          <h2>Core DDD Concepts</h2>
          <div class="mermaid">
graph TB
    DDD[Domain-Driven Design]
    
    DDD --> Strategic[Strategic Design]
    DDD --> Tactical[Tactical Design]
    
    Strategic --> BC[Bounded Contexts]
    Strategic --> UL[Ubiquitous Language]
    Strategic --> CM[Context Mapping]
    Strategic --> SD[Subdomains]
    
    Tactical --> E[Entities]
    Tactical --> VO[Value Objects]
    Tactical --> AG[Aggregates]
    Tactical --> DE[Domain Events]
    Tactical --> R[Repositories]
    Tactical --> DS[Domain Services]
    
    SD --> Core[Core Domain]
    SD --> Supporting[Supporting]
    SD --> Generic[Generic]
    
    style DDD fill:#3b82f6,stroke:#2563eb,stroke-width:3px,color:#fff
    style Strategic fill:#10b981,stroke:#059669,stroke-width:2px,color:#fff
    style Tactical fill:#8b5cf6,stroke:#7c3aed,stroke-width:2px,color:#fff
          </div>

          <h2>Ubiquitous Language</h2>
          <p>
            A common, rigorous language between developers and users. This language should be used in code, documentation, 
            conversations, and diagrams. Terms like "Customer," "Order," "Shipment" mean the same thing to everyone.
          </p>
          <div class="callout">
            <strong>Example:</strong> In an e-commerce domain, don't use "User" in code if business experts call them "Customers." 
            Use "PlaceOrder" not "CreateOrder" if that's the business term. The code should speak the language of the business.
          </div>

          <h2>Building Blocks of DDD</h2>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th>Pattern</th>
                <th>Purpose</th>
                <th>Example</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Entity</strong></td>
                <td>Objects with unique identity that persists over time</td>
                <td>Customer, Order, Product</td>
              </tr>
              <tr>
                <td><strong>Value Object</strong></td>
                <td>Immutable objects defined by their attributes</td>
                <td>Address, Money, DateRange</td>
              </tr>
              <tr>
                <td><strong>Aggregate</strong></td>
                <td>Cluster of entities and value objects with consistency boundary</td>
                <td>Order (with OrderItems)</td>
              </tr>
              <tr>
                <td><strong>Aggregate Root</strong></td>
                <td>Entry point to an aggregate, enforces invariants</td>
                <td>Order entity in Order aggregate</td>
              </tr>
              <tr>
                <td><strong>Repository</strong></td>
                <td>Abstracts data access for aggregates</td>
                <td>OrderRepository</td>
              </tr>
              <tr>
                <td><strong>Domain Service</strong></td>
                <td>Business logic that doesn't fit in entities</td>
                <td>PricingService, ShippingCalculator</td>
              </tr>
              <tr>
                <td><strong>Domain Event</strong></td>
                <td>Something significant that happened in the domain</td>
                <td>OrderPlaced, PaymentProcessed</td>
              </tr>
              <tr>
                <td><strong>Factory</strong></td>
                <td>Creates complex objects and aggregates</td>
                <td>OrderFactory</td>
              </tr>
            </tbody>
          </table>

          <h2>Layered Architecture in DDD</h2>
          <div class="mermaid">
graph TB
    UI[Presentation Layer]
    App[Application Layer]
    Domain[Domain Layer]
    Infra[Infrastructure Layer]
    
    UI --> App
    App --> Domain
    Domain -.depends on.-> Infra
    App -.depends on.-> Infra
    
    UI -.UI Components,<br/>Controllers,<br/>Views.-> UI
    App -.Use Cases,<br/>Application Services,<br/>DTOs.-> App
    Domain -.Entities,<br/>Value Objects,<br/>Aggregates,<br/>Domain Services.-> Domain
    Infra -.Repositories,<br/>External Services,<br/>Persistence.-> Infra
    
    style Domain fill:#3b82f6,stroke:#2563eb,stroke-width:3px,color:#fff
    style App fill:#10b981,stroke:#059669,stroke-width:2px,color:#fff
    style UI fill:#8b5cf6,stroke:#7c3aed,stroke-width:2px,color:#fff
    style Infra fill:#f59e0b,stroke:#d97706,stroke-width:2px,color:#fff
          </div>

          <h2>Benefits of DDD</h2>
          <ul>
            <li><strong>Better Communication:</strong> Shared language reduces misunderstandings between business and tech teams</li>
            <li><strong>Focus on Core Domain:</strong> Identifies and prioritizes the most valuable parts of the system</li>
            <li><strong>Flexibility:</strong> Well-defined boundaries make it easier to evolve the system</li>
            <li><strong>Rich Domain Models:</strong> Business logic lives in the domain layer, not scattered across layers</li>
            <li><strong>Testability:</strong> Domain logic is independent of infrastructure, making it highly testable</li>
            <li><strong>Scalability:</strong> Bounded contexts can become microservices when needed</li>
          </ul>

          <h2>When to Use DDD</h2>
          <div class="row g-3 mb-4">
            <div class="col-md-12">
              <div class="card border-0 shadow-sm bg-gradient-green-light">
                <div class="card-body">
                  <h3>‚úÖ Good Fit</h3>
                  <ul class="mb-0">
                    <li>Complex business domains with many rules and workflows</li>
                    <li>Long-term projects with evolving requirements</li>
                    <li>Close collaboration with domain experts is possible</li>
                    <li>Core domain requires significant competitive advantage</li>
                    <li>Team willing to invest in learning DDD patterns</li>
                  </ul>
                </div>
              </div>
            </div>
            <div class="col-md-12">
              <div class="card border-0 shadow-sm bg-gradient-red">
                <div class="card-body">
                  <h3>‚ùå Overkill For</h3>
                  <ul class="mb-0">
                    <li>Simple CRUD applications</li>
                    <li>Data-driven applications with minimal business logic</li>
                    <li>Short-term projects or prototypes</li>
                    <li>No access to domain experts</li>
                    <li>Generic subdomains (use off-the-shelf solutions instead)</li>
                  </ul>
                </div>
              </div>
            </div>
          </div>

          <div class="callout">
            <strong>üí° Key Takeaway:</strong> DDD is not just about code patterns - it's a way of thinking about software design 
            centered on the business domain. Start with strategic design (bounded contexts, ubiquitous language) before diving into 
            tactical patterns. Not every part of your application needs DDD - apply it to your core domain where business complexity 
            and competitive advantage lie. Use simpler approaches for supporting and generic subdomains.
          </div>
        </section>

        <!-- Bounded Contexts Section -->
        <section id="bounded-context" role="article">
          <h1>Bounded Contexts</h1>
          <span class="badge">ddd</span>
          <span class="badge">context</span>
          <span class="badge">boundaries</span>
          
          <h2>What is a Bounded Context?</h2>
          <p>
            A <strong>Bounded Context</strong> is a central pattern in Domain-Driven Design that defines explicit boundaries within 
            which a particular domain model is valid. Each bounded context has its own ubiquitous language and domain model that may 
            differ from other contexts, even for the same concepts.
          </p>
          <p>
            Think of bounded contexts as autonomous zones where a specific model applies. The same term (like "Customer") can have 
            different meanings and different attributes in different bounded contexts.
          </p>

          <h2>Why Bounded Contexts Matter</h2>
          <div class="row g-3 mb-4">
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-blue">
                <div class="card-body">
                  <h3>üéØ Clear Boundaries</h3>
                  <p class="mb-0">Define where one model ends and another begins, reducing complexity and ambiguity.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-green">
                <div class="card-body">
                  <h3>üîß Team Autonomy</h3>
                  <p class="mb-0">Different teams can work on different contexts independently without stepping on each other.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-purple">
                <div class="card-body">
                  <h3>üìä Model Integrity</h3>
                  <p class="mb-0">Each context maintains its own consistent model without being corrupted by other contexts.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-orange">
                <div class="card-body">
                  <h3>üöÄ Evolution</h3>
                  <p class="mb-0">Contexts can evolve independently, allowing for different paces of change.</p>
                </div>
              </div>
            </div>
          </div>

          <h2>Example: E-Commerce Bounded Contexts</h2>
          <div class="mermaid">
graph TB
    subgraph Sales[Sales Context]
        SC[Customer]
        SO[Order]
        SP[Product]
        SC -.places.-> SO
        SO -.contains.-> SP
    end
    
    subgraph Shipping[Shipping Context]
        SHC[Recipient]
        SHS[Shipment]
        SHP[Package]
        SHC -.receives.-> SHS
        SHS -.contains.-> SHP
    end
    
    subgraph Inventory[Inventory Context]
        II[Item]
        IL[Location]
        IS[Stock]
        II -.stored in.-> IL
        IL -.has.-> IS
    end
    
    subgraph Support[Support Context]
        SUC[Client]
        SUT[Ticket]
        SUI[Issue]
        SUC -.reports.-> SUT
        SUT -.describes.-> SUI
    end
    
    Sales -.Context Map.-> Shipping
    Sales -.Context Map.-> Inventory
    Sales -.Context Map.-> Support
    
    style Sales fill:#3b82f6,stroke:#2563eb,stroke-width:2px,color:#fff
    style Shipping fill:#10b981,stroke:#059669,stroke-width:2px,color:#fff
    style Inventory fill:#f59e0b,stroke:#d97706,stroke-width:2px,color:#fff
    style Support fill:#8b5cf6,stroke:#7c3aed,stroke-width:2px,color:#fff
          </div>

          <p>
            Notice how "Customer" in Sales Context has different attributes than "Recipient" in Shipping Context, even though they 
            might represent the same person. Each context has its own perspective and needs.
          </p>

          <h2>Context Mapping Patterns</h2>
          <p>Context maps describe relationships between bounded contexts. Here are common patterns:</p>

          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th>Pattern</th>
                <th>Description</th>
                <th>When to Use</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Partnership</strong></td>
                <td>Two contexts cooperate closely with coordinated releases</td>
                <td>Teams work together, mutual dependency</td>
              </tr>
              <tr>
                <td><strong>Shared Kernel</strong></td>
                <td>Two contexts share a subset of the domain model</td>
                <td>Small overlap, tight coordination needed</td>
              </tr>
              <tr>
                <td><strong>Customer-Supplier</strong></td>
                <td>Upstream (supplier) serves downstream (customer)</td>
                <td>Clear provider-consumer relationship</td>
              </tr>
              <tr>
                <td><strong>Conformist</strong></td>
                <td>Downstream conforms to upstream's model</td>
                <td>No negotiation power with upstream</td>
              </tr>
              <tr>
                <td><strong>Anti-Corruption Layer (ACL)</strong></td>
                <td>Downstream protects itself from upstream changes</td>
                <td>Legacy systems, external APIs</td>
              </tr>
              <tr>
                <td><strong>Open Host Service</strong></td>
                <td>Upstream provides well-defined API for all consumers</td>
                <td>Multiple downstream consumers</td>
              </tr>
              <tr>
                <td><strong>Published Language</strong></td>
                <td>Shared language for integration (often with Open Host)</td>
                <td>Standard formats like JSON Schema, XML</td>
              </tr>
              <tr>
                <td><strong>Separate Ways</strong></td>
                <td>No integration - contexts are independent</td>
                <td>No business need for integration</td>
              </tr>
            </tbody>
          </table>

          <h2>Anti-Corruption Layer (ACL)</h2>
          <p>
            The ACL pattern is particularly important when integrating with external systems or legacy code. It translates between 
            your domain model and external models, preventing external concepts from "corrupting" your bounded context.
          </p>

          <div class="mermaid">
graph LR
    DC[Your Domain Context] --> ACL[Anti-Corruption Layer]
    ACL --> Legacy[Legacy System]
    ACL --> External[External API]
    
    ACL -.Translates.-> Adapter1[Adapter]
    ACL -.Translates.-> Adapter2[Adapter]
    
    style DC fill:#3b82f6,stroke:#2563eb,stroke-width:3px,color:#fff
    style ACL fill:#10b981,stroke:#059669,stroke-width:2px,color:#fff
    style Legacy fill:#64748b,stroke:#475569,stroke-width:2px,color:#fff
    style External fill:#64748b,stroke:#475569,stroke-width:2px,color:#fff
          </div>

          <h2>Identifying Bounded Contexts</h2>
          <p>Use these techniques to identify bounded context boundaries:</p>
          <ul>
            <li><strong>Listen to Language:</strong> Different terms or different meanings = different contexts</li>
            <li><strong>Look for Subdomains:</strong> Core, supporting, and generic subdomains often map to contexts</li>
            <li><strong>Identify Team Boundaries:</strong> Organizational structure often reveals natural context boundaries</li>
            <li><strong>Find Model Inconsistencies:</strong> Where does one model need different attributes or behaviors?</li>
            <li><strong>Event Storming:</strong> Collaborative workshop to discover domain events and boundaries</li>
            <li><strong>Use Case Analysis:</strong> Different use cases often belong to different contexts</li>
          </ul>

          <h2>Bounded Context vs Microservice</h2>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th>Aspect</th>
                <th>Bounded Context</th>
                <th>Microservice</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Level</strong></td>
                <td>Logical boundary (design)</td>
                <td>Physical boundary (deployment)</td>
              </tr>
              <tr>
                <td><strong>Scope</strong></td>
                <td>Model boundary</td>
                <td>Deployment unit</td>
              </tr>
              <tr>
                <td><strong>Relationship</strong></td>
                <td>One context can contain multiple services</td>
                <td>Should align with bounded context</td>
              </tr>
              <tr>
                <td><strong>When Defined</strong></td>
                <td>During domain modeling</td>
                <td>During architecture design</td>
              </tr>
            </tbody>
          </table>

          <div class="callout">
            <strong>üí° Key Takeaway:</strong> Bounded contexts are about managing complexity through clear boundaries, not about 
            technology. Start by identifying contexts through domain exploration and language analysis. Use context mapping to 
            understand and document relationships. One bounded context can be implemented as one or more microservices, but each 
            microservice should not span multiple bounded contexts. The Anti-Corruption Layer is your best friend when integrating 
            with external systems.
          </div>
        </section>

        <!-- Aggregates & Entities Section -->
        <section id="aggregates" role="article">
          <h1>Aggregates & Entities</h1>
          <span class="badge">ddd</span>
          <span class="badge">aggregates</span>
          <span class="badge">entities</span>
          
          <h2>What are Entities?</h2>
          <p>
            <strong>Entities</strong> are objects that have a distinct identity that persists over time and across different states. 
            Two entities with the same attribute values are still different if they have different identities. The identity is usually 
            represented by an ID field.
          </p>

          <div class="row g-3 mb-4">
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-blue">
                <div class="card-body">
                  <h3>‚úÖ Entity Example</h3>
                  <p><strong>Customer</strong></p>
                  <ul class="mb-0">
                    <li>Has unique CustomerId</li>
                    <li>Name can change over time</li>
                    <li>Still the same customer</li>
                    <li>Identity is key</li>
                  </ul>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-green">
                <div class="card-body">
                  <h3>‚ùå Not an Entity</h3>
                  <p><strong>Address</strong></p>
                  <ul class="mb-0">
                    <li>No unique identity needed</li>
                    <li>Defined by its values</li>
                    <li>Two identical addresses are the same</li>
                    <li>This is a Value Object</li>
                  </ul>
                </div>
              </div>
            </div>
          </div>

          <h2>What are Aggregates?</h2>
          <p>
            An <strong>Aggregate</strong> is a cluster of entities and value objects that are treated as a single unit for data changes. 
            Each aggregate has a root entity called the <strong>Aggregate Root</strong>, which is the only entry point for modifying 
            the aggregate. This ensures consistency and enforces business invariants.
          </p>

          <h2>Aggregate Pattern</h2>
          <div class="mermaid">
graph TB
    subgraph Aggregate[Order Aggregate]
        Root[Order<br/>Aggregate Root]
        Item1[OrderItem 1]
        Item2[OrderItem 2]
        Item3[OrderItem 3]
        ShippingAddr[Shipping Address<br/>Value Object]
        BillingAddr[Billing Address<br/>Value Object]
        
        Root --> Item1
        Root --> Item2
        Root --> Item3
        Root --> ShippingAddr
        Root --> BillingAddr
    end
    
    Client[Client Code] --> Root
    Client -.‚ùå Cannot Access Directly.-> Item1
    Client -.‚ùå Cannot Access Directly.-> Item2
    
    Root -.Enforces<br/>Invariants.-> Root
    
    style Root fill:#3b82f6,stroke:#2563eb,stroke-width:3px,color:#fff
    style Aggregate fill:#e0f2fe,stroke:#0284c7,stroke-width:2px
    style Client fill:#64748b,stroke:#475569,stroke-width:2px,color:#fff
          </div>

          <h2>Aggregate Rules</h2>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th>Rule</th>
                <th>Description</th>
                <th>Reason</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>1. Single Root</strong></td>
                <td>Each aggregate has one aggregate root</td>
                <td>Clear entry point for all modifications</td>
              </tr>
              <tr>
                <td><strong>2. External Access</strong></td>
                <td>External objects can only reference the root</td>
                <td>Maintains aggregate boundary and consistency</td>
              </tr>
              <tr>
                <td><strong>3. Consistency Boundary</strong></td>
                <td>Changes within aggregate are immediately consistent</td>
                <td>Business invariants are always enforced</td>
              </tr>
              <tr>
                <td><strong>4. Small Aggregates</strong></td>
                <td>Keep aggregates as small as possible</td>
                <td>Better performance, fewer conflicts</td>
              </tr>
              <tr>
                <td><strong>5. Reference by ID</strong></td>
                <td>Aggregates reference each other by ID, not object reference</td>
                <td>Loose coupling, clear boundaries</td>
              </tr>
              <tr>
                <td><strong>6. Transaction Boundary</strong></td>
                <td>One transaction = one aggregate</td>
                <td>Prevents distributed transaction issues</td>
              </tr>
            </tbody>
          </table>

          <h2>Designing Aggregates</h2>
          
          <h3>Step 1: Identify True Invariants</h3>
          <p>What rules must always be true? These define aggregate boundaries.</p>
          <div class="callout">
            <strong>Example:</strong> In an Order, the total must always equal the sum of item prices. Order and OrderItems 
            must be in the same aggregate to enforce this invariant.
          </div>

          <h3>Step 2: Design Small Aggregates</h3>
          <p>Start with individual entities and only group them if they share invariants.</p>
          <ul>
            <li><strong>Good:</strong> Order aggregate with OrderItems</li>
            <li><strong>Bad:</strong> Order aggregate containing Customer, Product catalog, Inventory</li>
          </ul>

          <h3>Step 3: Reference Other Aggregates by ID</h3>
          <p>Don't hold object references to other aggregates. Use IDs instead.</p>

          <h2>Common Aggregate Examples</h2>
          <div class="row g-3 mb-4">
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-blue-sky">
                <div class="card-body">
                  <h4>Order Aggregate</h4>
                  <p><strong>Root:</strong> Order</p>
                  <p><strong>Children:</strong> OrderItems</p>
                  <p><strong>Invariant:</strong> Order total = sum of items</p>
                  <p class="mb-0"><strong>References:</strong> CustomerId, ProductIds</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-green-light">
                <div class="card-body">
                  <h4>ShoppingCart Aggregate</h4>
                  <p><strong>Root:</strong> ShoppingCart</p>
                  <p><strong>Children:</strong> CartItems</p>
                  <p><strong>Invariant:</strong> Item quantities > 0</p>
                  <p class="mb-0"><strong>References:</strong> CustomerId, ProductIds</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-purple">
                <div class="card-body">
                  <h4>Account Aggregate</h4>
                  <p><strong>Root:</strong> Account</p>
                  <p><strong>Children:</strong> Transactions</p>
                  <p><strong>Invariant:</strong> Balance matches sum of transactions</p>
                  <p class="mb-0"><strong>References:</strong> CustomerId</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-orange">
                <div class="card-body">
                  <h4>Blog Post Aggregate</h4>
                  <p><strong>Root:</strong> Post</p>
                  <p><strong>Children:</strong> Comments</p>
                  <p><strong>Invariant:</strong> Post published ‚Üí cannot delete comments</p>
                  <p class="mb-0"><strong>References:</strong> AuthorId</p>
                </div>
              </div>
            </div>
          </div>

          <h2>Entities vs Value Objects</h2>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th>Aspect</th>
                <th>Entity</th>
                <th>Value Object</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Identity</strong></td>
                <td>Has unique identity (ID)</td>
                <td>No identity, defined by values</td>
              </tr>
              <tr>
                <td><strong>Mutability</strong></td>
                <td>Mutable (can change state)</td>
                <td>Immutable (cannot change)</td>
              </tr>
              <tr>
                <td><strong>Equality</strong></td>
                <td>Based on ID</td>
                <td>Based on all attribute values</td>
              </tr>
              <tr>
                <td><strong>Lifecycle</strong></td>
                <td>Has lifecycle (created, modified, archived)</td>
                <td>Created and used, then discarded</td>
              </tr>
              <tr>
                <td><strong>Examples</strong></td>
                <td>Customer, Order, Product</td>
                <td>Address, Money, DateRange</td>
              </tr>
            </tbody>
          </table>

          <h2>Common Mistakes</h2>
          <ul>
            <li><strong>Too Large:</strong> Aggregates that include too many entities, causing performance issues</li>
            <li><strong>Too Many:</strong> Every entity is its own aggregate, losing consistency benefits</li>
            <li><strong>Direct References:</strong> Holding object references between aggregates instead of IDs</li>
            <li><strong>Multiple Transaction:</strong> Modifying multiple aggregates in one transaction</li>
            <li><strong>Ignoring Invariants:</strong> Not identifying true business invariants to guide design</li>
          </ul>

          <div class="callout">
            <strong>üí° Key Takeaway:</strong> Aggregates are about consistency boundaries. Keep them small - only include entities 
            that must change together to maintain invariants. Use IDs to reference other aggregates, not object references. One 
            transaction should modify one aggregate. If you need to modify multiple aggregates, use domain events and eventual 
            consistency. Remember: it's better to start with smaller aggregates and combine them later than to start with large 
            aggregates and try to split them.
          </div>
        </section>

        <!-- Domain Events Section -->
        <section id="domain-events" role="article">
          <h1>Domain Events</h1>
          <span class="badge">ddd</span>
          <span class="badge">events</span>
          <span class="badge">communication</span>
          
          <h2>What are Domain Events?</h2>
          <p>
            <strong>Domain Events</strong> are objects that represent something significant that happened in the domain. They capture 
            facts about state changes in the domain and are named in the past tense (e.g., OrderPlaced, PaymentProcessed, 
            CustomerRegistered). Domain events are immutable - once they happen, they cannot be changed.
          </p>
          <p>
            Domain events enable loose coupling between bounded contexts and aggregates by providing a way to communicate without 
            direct dependencies. They're essential for implementing eventual consistency in distributed systems.
          </p>

          <h2>Why Use Domain Events?</h2>
          <div class="row g-3 mb-4">
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-blue">
                <div class="card-body">
                  <h3>üîó Loose Coupling</h3>
                  <p class="mb-0">Aggregates and contexts can react to changes without direct dependencies on each other.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-green">
                <div class="card-body">
                  <h3>üìú Audit Trail</h3>
                  <p class="mb-0">Events provide a complete history of what happened in the system, useful for auditing and debugging.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-purple">
                <div class="card-body">
                  <h3>‚ö° Eventual Consistency</h3>
                  <p class="mb-0">Enable consistency across multiple aggregates or bounded contexts without distributed transactions.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-orange">
                <div class="card-body">
                  <h3>üéØ Business Insights</h3>
                  <p class="mb-0">Events capture business-meaningful occurrences that can be analyzed for insights and reporting.</p>
                </div>
              </div>
            </div>
          </div>

          <h2>Domain Event Pattern</h2>
          <div class="mermaid">
sequenceDiagram
    participant Client
    participant OrderAggregate
    participant EventBus
    participant InventoryHandler
    participant EmailHandler
    participant AnalyticsHandler
    
    Client->>OrderAggregate: PlaceOrder()
    OrderAggregate->>OrderAggregate: Validate & Create Order
    OrderAggregate->>EventBus: Publish OrderPlaced Event
    
    EventBus->>InventoryHandler: OrderPlaced Event
    InventoryHandler->>InventoryHandler: Reserve Items
    
    EventBus->>EmailHandler: OrderPlaced Event
    EmailHandler->>EmailHandler: Send Confirmation Email
    
    EventBus->>AnalyticsHandler: OrderPlaced Event
    AnalyticsHandler->>AnalyticsHandler: Track Conversion
    
    OrderAggregate-->>Client: Order Placed Successfully
          </div>

          <h2>Event Structure</h2>
          <p>A well-designed domain event contains:</p>
          <ul>
            <li><strong>Event ID:</strong> Unique identifier for the event</li>
            <li><strong>Timestamp:</strong> When the event occurred</li>
            <li><strong>Event Type:</strong> Name of the event (e.g., "OrderPlaced")</li>
            <li><strong>Aggregate ID:</strong> ID of the aggregate that raised the event</li>
            <li><strong>Event Data:</strong> Relevant information about what happened</li>
            <li><strong>Correlation ID:</strong> For tracking related events across the system</li>
            <li><strong>Metadata:</strong> User who triggered it, version, etc.</li>
          </ul>

          <h2>Types of Domain Events</h2>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th>Type</th>
                <th>Scope</th>
                <th>Use Case</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Internal Events</strong></td>
                <td>Within same bounded context</td>
                <td>Coordinate between aggregates in same context</td>
              </tr>
              <tr>
                <td><strong>Integration Events</strong></td>
                <td>Across bounded contexts</td>
                <td>Communicate between microservices or contexts</td>
              </tr>
              <tr>
                <td><strong>Public Events</strong></td>
                <td>External systems</td>
                <td>Notify external systems (partners, webhooks)</td>
              </tr>
            </tbody>
          </table>

          <h2>Event Naming Conventions</h2>
          <p>Events should be named in past tense to indicate something that has already happened:</p>
          <div class="row g-3 mb-4">
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-green-light">
                <div class="card-body">
                  <h4>‚úÖ Good Names</h4>
                  <ul class="mb-0">
                    <li>OrderPlaced</li>
                    <li>PaymentProcessed</li>
                    <li>CustomerRegistered</li>
                    <li>ItemShipped</li>
                    <li>AccountActivated</li>
                    <li>InventoryReserved</li>
                  </ul>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-red">
                <div class="card-body">
                  <h4>‚ùå Poor Names</h4>
                  <ul class="mb-0">
                    <li>PlaceOrder (command, not event)</li>
                    <li>ProcessPayment (action, not past tense)</li>
                    <li>RegisterCustomer (command)</li>
                    <li>OrderUpdate (too vague)</li>
                    <li>DataChanged (not domain-specific)</li>
                  </ul>
                </div>
              </div>
            </div>
          </div>

          <h2>Publishing Domain Events</h2>
          <p>Common patterns for publishing events:</p>

          <h3>1. Direct Publishing (In-Process)</h3>
          <p>Events are published and handled within the same process, useful for internal events.</p>

          <h3>2. Outbox Pattern</h3>
          <p>
            Events are saved to an outbox table in the same transaction as the aggregate changes, then published asynchronously. 
            This ensures at-least-once delivery without distributed transactions.
          </p>

          <div class="mermaid">
sequenceDiagram
    participant Service
    participant Database
    participant Outbox
    participant MessageBus
    participant Consumer
    
    Service->>Database: Begin Transaction
    Service->>Database: Update Aggregate
    Service->>Outbox: Insert Event
    Service->>Database: Commit Transaction
    
    Note over Outbox: Background Process
    Outbox->>MessageBus: Publish Event
    MessageBus->>Consumer: Deliver Event
    Consumer-->>MessageBus: Acknowledge
    Outbox->>Outbox: Mark as Published
          </div>

          <h3>3. Change Data Capture (CDC)</h3>
          <p>Database changes are captured and converted to events automatically (e.g., Debezium).</p>

          <h2>Handling Domain Events</h2>
          <p>Event handlers should:</p>
          <ul>
            <li><strong>Be Idempotent:</strong> Handle the same event multiple times safely</li>
            <li><strong>Be Fast:</strong> Process events quickly or offload to background jobs</li>
            <li><strong>Be Independent:</strong> One handler failure shouldn't affect others</li>
            <li><strong>Track Progress:</strong> Store which events have been processed</li>
            <li><strong>Handle Failures:</strong> Implement retry logic and dead letter queues</li>
          </ul>

          <h2>Domain Events vs Integration Events</h2>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th>Aspect</th>
                <th>Domain Events</th>
                <th>Integration Events</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Purpose</strong></td>
                <td>Domain logic coordination</td>
                <td>Cross-service communication</td>
              </tr>
              <tr>
                <td><strong>Scope</strong></td>
                <td>Within bounded context</td>
                <td>Across contexts/services</td>
              </tr>
              <tr>
                <td><strong>Transport</strong></td>
                <td>In-process or local message bus</td>
                <td>Message broker (RabbitMQ, Azure Service Bus)</td>
              </tr>
              <tr>
                <td><strong>Schema</strong></td>
                <td>Internal, can change freely</td>
                <td>Versioned contract, careful changes</td>
              </tr>
              <tr>
                <td><strong>Delivery</strong></td>
                <td>Synchronous or async</td>
                <td>Asynchronous</td>
              </tr>
            </tbody>
          </table>

          <h2>Benefits of Domain Events</h2>
          <ul>
            <li><strong>Decoupling:</strong> Producers don't know about consumers, enabling independent evolution</li>
            <li><strong>Scalability:</strong> Handlers can scale independently based on event volume</li>
            <li><strong>Extensibility:</strong> Add new event handlers without modifying existing code</li>
            <li><strong>Temporal Decoupling:</strong> Producers and consumers don't need to be online simultaneously</li>
            <li><strong>Event Sourcing:</strong> Events can be the source of truth for system state</li>
          </ul>

          <h2>Common Mistakes</h2>
          <ul>
            <li><strong>Too Fine-Grained:</strong> Publishing events for every property change</li>
            <li><strong>Too Coarse:</strong> Single "DataChanged" event without meaningful information</li>
            <li><strong>Missing Data:</strong> Not including enough information in events</li>
            <li><strong>Breaking Changes:</strong> Changing event schema without versioning</li>
            <li><strong>Synchronous Processing:</strong> Waiting for all handlers before completing request</li>
            <li><strong>No Idempotency:</strong> Handlers that fail when processing duplicate events</li>
          </ul>

          <div class="callout">
            <strong>üí° Key Takeaway:</strong> Domain events are essential for building loosely coupled, scalable systems. Use them 
            to communicate between aggregates and bounded contexts without creating direct dependencies. Always name events in past 
            tense to indicate completed facts. Implement the outbox pattern for reliable event publishing. Make event handlers 
            idempotent to safely handle duplicates. Events are immutable - once published, they represent historical facts that 
            cannot be changed. Consider event sourcing when you need full audit trails or temporal queries.
          </div>
        </section>

        <!-- Event-Driven Architecture Section -->
        <section id="event-driven" role="article">
          <h1>‚ö° Event-Driven Architecture (EDA)</h1>
          <span class="badge">eda</span>
          <span class="badge">events</span>
          <span class="badge">async</span>
          
          <h2>What is Event-Driven Architecture?</h2>
          <p>
            <strong>Event-Driven Architecture (EDA)</strong> is a software design pattern where system components communicate by 
            producing and consuming events. An event represents a significant state change or occurrence in the system. Components 
            are loosely coupled - producers don't know who consumes their events, and consumers don't know who produced them.
          </p>
          <p>
            EDA enables asynchronous, scalable, and resilient systems by decoupling producers and consumers in both space (they don't 
            need to know about each other) and time (they don't need to be active simultaneously).
          </p>

          <h2>Core Concepts</h2>
          <div class="row g-3 mb-4">
            <div class="col-md-4">
              <div class="card border-0 shadow-sm h-100 bg-gradient-blue">
                <div class="card-body">
                  <h3>üì§ Event Producers</h3>
                  <p class="mb-0">Components that detect state changes and publish events. They don't know or care who will consume the events.</p>
                </div>
              </div>
            </div>
            <div class="col-md-4">
              <div class="card border-0 shadow-sm h-100 bg-gradient-green">
                <div class="card-body">
                  <h3>üîÑ Event Channels</h3>
                  <p class="mb-0">Infrastructure for transmitting events from producers to consumers (message brokers, event buses).</p>
                </div>
              </div>
            </div>
            <div class="col-md-4">
              <div class="card border-0 shadow-sm h-100 bg-gradient-purple">
                <div class="card-body">
                  <h3>üì• Event Consumers</h3>
                  <p class="mb-0">Components that subscribe to events and react accordingly. They don't know who produced the events.</p>
                </div>
              </div>
            </div>
          </div>

          <h2>Event-Driven Architecture Pattern</h2>
          <div class="mermaid">
graph TB
    P1[Producer 1:<br/>Order Service] --> EB[Event Bus/<br/>Message Broker]
    P2[Producer 2:<br/>Payment Service] --> EB
    P3[Producer 3:<br/>Inventory Service] --> EB
    
    EB --> C1[Consumer 1:<br/>Email Service]
    EB --> C2[Consumer 2:<br/>Analytics Service]
    EB --> C3[Consumer 3:<br/>Notification Service]
    EB --> C4[Consumer 4:<br/>Shipping Service]
    
    P1 -.publishes.-> E1[OrderPlaced]
    P2 -.publishes.-> E2[PaymentProcessed]
    P3 -.publishes.-> E3[InventoryReserved]
    
    E1 --> EB
    E2 --> EB
    E3 --> EB
    
    style EB fill:#3b82f6,stroke:#2563eb,stroke-width:3px,color:#fff
    style P1 fill:#10b981,stroke:#059669,stroke-width:2px,color:#fff
    style P2 fill:#10b981,stroke:#059669,stroke-width:2px,color:#fff
    style P3 fill:#10b981,stroke:#059669,stroke-width:2px,color:#fff
    style C1 fill:#8b5cf6,stroke:#7c3aed,stroke-width:2px,color:#fff
    style C2 fill:#8b5cf6,stroke:#7c3aed,stroke-width:2px,color:#fff
    style C3 fill:#8b5cf6,stroke:#7c3aed,stroke-width:2px,color:#fff
    style C4 fill:#8b5cf6,stroke:#7c3aed,stroke-width:2px,color:#fff
          </div>

          <h2>Event-Driven vs Request-Driven</h2>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th>Aspect</th>
                <th>Request-Driven (Traditional)</th>
                <th>Event-Driven</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Communication</strong></td>
                <td>Synchronous, blocking</td>
                <td>Asynchronous, non-blocking</td>
              </tr>
              <tr>
                <td><strong>Coupling</strong></td>
                <td>Tight - caller knows callee</td>
                <td>Loose - producers/consumers independent</td>
              </tr>
              <tr>
                <td><strong>Response</strong></td>
                <td>Immediate response expected</td>
                <td>Fire-and-forget or eventual response</td>
              </tr>
              <tr>
                <td><strong>Scalability</strong></td>
                <td>Limited by synchronous nature</td>
                <td>High - consumers scale independently</td>
              </tr>
              <tr>
                <td><strong>Failure Handling</strong></td>
                <td>Immediate failure propagation</td>
                <td>Retry, dead letter queues, resilience</td>
              </tr>
              <tr>
                <td><strong>Availability</strong></td>
                <td>Both services must be available</td>
                <td>Services can be offline temporarily</td>
              </tr>
            </tbody>
          </table>

          <h2>Event Processing Models</h2>
          
          <h3>1. Simple Event Processing</h3>
          <p>Each event is processed independently and immediately. Used for simple triggers and notifications.</p>
          
          <h3>2. Event Stream Processing</h3>
          <p>Events are processed as continuous streams. Enables real-time analytics, filtering, and transformations.</p>
          
          <h3>3. Complex Event Processing (CEP)</h3>
          <p>Identifies patterns across multiple events over time. Used for fraud detection, anomaly detection, etc.</p>

          <div class="mermaid">
graph LR
    subgraph Simple[Simple Event Processing]
        E1[Event 1] --> H1[Handler 1]
        E2[Event 2] --> H2[Handler 2]
    end
    
    subgraph Stream[Event Stream Processing]
        S1[Event Stream] --> F[Filter]
        F --> T[Transform]
        T --> A[Aggregate]
    end
    
    subgraph Complex[Complex Event Processing]
        CE1[Event 1]
        CE2[Event 2]
        CE3[Event 3]
        CE1 --> P[Pattern<br/>Matcher]
        CE2 --> P
        CE3 --> P
        P --> Alert[Alert/<br/>Action]
    end
    
    style Simple fill:#e0f2fe,stroke:#0284c7,stroke-width:2px
    style Stream fill:#dcfce7,stroke:#16a34a,stroke-width:2px
    style Complex fill:#f3e8ff,stroke:#9333ea,stroke-width:2px
          </div>

          <h2>Common Event-Driven Patterns</h2>
          <div class="row g-3 mb-4">
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-blue-sky">
                <div class="card-body">
                  <h4>Pub/Sub (Publish-Subscribe)</h4>
                  <p><strong>Pattern:</strong> Multiple consumers subscribe to event types they're interested in.</p>
                  <p><strong>Use Case:</strong> Broadcast notifications to multiple services.</p>
                  <p class="mb-0"><strong>Example:</strong> OrderPlaced event consumed by Email, Analytics, Inventory services.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-green-light">
                <div class="card-body">
                  <h4>Event Sourcing</h4>
                  <p><strong>Pattern:</strong> Store all state changes as events, rebuild state by replaying events.</p>
                  <p><strong>Use Case:</strong> Full audit trail, temporal queries, replay capability.</p>
                  <p class="mb-0"><strong>Example:</strong> Bank account state derived from transaction events.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-purple">
                <div class="card-body">
                  <h4>CQRS (Command Query Separation)</h4>
                  <p><strong>Pattern:</strong> Separate read and write models, synchronized via events.</p>
                  <p><strong>Use Case:</strong> Different optimization for reads vs writes.</p>
                  <p class="mb-0"><strong>Example:</strong> Write to normalized DB, read from denormalized cache.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-orange">
                <div class="card-body">
                  <h4>Event Streaming</h4>
                  <p><strong>Pattern:</strong> Continuous flow of events through streaming platform.</p>
                  <p><strong>Use Case:</strong> Real-time data processing, analytics pipelines.</p>
                  <p class="mb-0"><strong>Example:</strong> Kafka streaming IoT sensor data for real-time dashboards.</p>
                </div>
              </div>
            </div>
          </div>

          <h2>Benefits of EDA</h2>
          <ul>
            <li><strong>Loose Coupling:</strong> Producers and consumers are independent, enabling separate development and deployment</li>
            <li><strong>Scalability:</strong> Consumers can scale independently based on event volume</li>
            <li><strong>Resilience:</strong> If a consumer is down, events are queued and processed when it recovers</li>
            <li><strong>Flexibility:</strong> Easy to add new consumers without modifying producers</li>
            <li><strong>Real-Time Processing:</strong> Events can trigger immediate reactions to state changes</li>
            <li><strong>Audit Trail:</strong> Event logs provide complete history of system changes</li>
            <li><strong>Eventual Consistency:</strong> Enables distributed systems without distributed transactions</li>
          </ul>

          <h2>Challenges of EDA</h2>
          <ul>
            <li><strong>Complexity:</strong> Asynchronous flows are harder to understand and debug than synchronous calls</li>
            <li><strong>Eventual Consistency:</strong> Data may be temporarily inconsistent across services</li>
            <li><strong>Event Ordering:</strong> Ensuring correct order of event processing can be difficult</li>
            <li><strong>Duplicate Events:</strong> Need idempotent handlers to safely process duplicate events</li>
            <li><strong>Monitoring:</strong> Distributed event flows require sophisticated tracing and monitoring</li>
            <li><strong>Testing:</strong> More complex to test asynchronous event flows than synchronous APIs</li>
          </ul>

          <h2>Event Broker Technologies</h2>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th>Technology</th>
                <th>Type</th>
                <th>Best For</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Apache Kafka</strong></td>
                <td>Event Streaming Platform</td>
                <td>High-throughput event streaming, log aggregation</td>
              </tr>
              <tr>
                <td><strong>RabbitMQ</strong></td>
                <td>Message Broker</td>
                <td>Traditional messaging, complex routing</td>
              </tr>
              <tr>
                <td><strong>Azure Service Bus</strong></td>
                <td>Message Broker</td>
                <td>Enterprise messaging, Azure integration</td>
              </tr>
              <tr>
                <td><strong>Amazon EventBridge</strong></td>
                <td>Event Bus</td>
                <td>AWS serverless applications, SaaS integration</td>
              </tr>
              <tr>
                <td><strong>Azure Event Hubs</strong></td>
                <td>Event Streaming</td>
                <td>Big data streaming, telemetry ingestion</td>
              </tr>
              <tr>
                <td><strong>Google Cloud Pub/Sub</strong></td>
                <td>Pub/Sub Messaging</td>
                <td>GCP applications, global distribution</td>
              </tr>
              <tr>
                <td><strong>Redis Streams</strong></td>
                <td>In-Memory Streaming</td>
                <td>Low-latency streaming, caching scenarios</td>
              </tr>
            </tbody>
          </table>

          <h2>When to Use EDA</h2>
          <div class="row g-3 mb-4">
            <div class="col-md-12">
              <div class="card border-0 shadow-sm bg-gradient-green-light">
                <div class="card-body">
                  <h3>‚úÖ Good Fit</h3>
                  <ul class="mb-0">
                    <li>Microservices architecture requiring loose coupling</li>
                    <li>Real-time data processing and analytics</li>
                    <li>Systems with many-to-many communication patterns</li>
                    <li>Need for eventual consistency over immediate consistency</li>
                    <li>High-volume event streams (IoT, clickstream, logs)</li>
                    <li>Audit and compliance requirements (event log as source of truth)</li>
                    <li>Systems requiring high availability and resilience</li>
                  </ul>
                </div>
              </div>
            </div>
            <div class="col-md-12">
              <div class="card border-0 shadow-sm bg-gradient-red">
                <div class="card-body">
                  <h3>‚ùå Overkill For</h3>
                  <ul class="mb-0">
                    <li>Simple CRUD applications with immediate consistency needs</li>
                    <li>Monolithic applications with simple workflows</li>
                    <li>Systems requiring strong transactional guarantees</li>
                    <li>Teams without experience in distributed systems</li>
                    <li>Real-time user interactions requiring immediate responses</li>
                  </ul>
                </div>
              </div>
            </div>
          </div>

          <div class="callout">
            <strong>üí° Key Takeaway:</strong> Event-Driven Architecture enables highly scalable, resilient, and loosely coupled 
            systems by communicating through asynchronous events. Choose EDA when you need loose coupling between services, handle 
            high event volumes, or require eventual consistency. However, EDA adds complexity - use simpler request-response patterns 
            for straightforward synchronous workflows. Start with pub/sub for basic decoupling, consider event sourcing for audit 
            requirements, and use stream processing for real-time analytics. Always implement idempotent event handlers and 
            comprehensive monitoring.
          </div>
        </section>

        <!-- Event Sourcing Section -->
        <section id="event-sourcing" role="article">
          <h1>Event Sourcing</h1>
          <span class="badge">eda</span>
          <span class="badge">event-sourcing</span>
          <span class="badge">audit</span>
          
          <h2>What is Event Sourcing?</h2>
          <p>
            <strong>Event Sourcing</strong> is a pattern where the state of an application is determined by a sequence of events. 
            Instead of storing just the current state, you store all state changes as events. The current state is derived by 
            replaying these events from the beginning.
          </p>
          <p>
            Think of it like a bank statement - instead of just showing your current balance, it shows every transaction (event) 
            that led to that balance. You can always recalculate your current balance by replaying all transactions.
          </p>

          <h2>Traditional State Storage vs Event Sourcing</h2>
          <div class="mermaid">
graph TB
    subgraph Traditional[Traditional: Current State Only]
        TS1[State: Balance = $100]
        TS2[Update: Balance = $150]
        TS3[Update: Balance = $120]
        TS1 --> TS2
        TS2 --> TS3
        TS3 -.Only this<br/>is stored.-> TS3
    end
    
    subgraph EventSourcing[Event Sourcing: All Events]
        ES1[Event: AccountOpened<br/>Balance = $100]
        ES2[Event: DepositMade<br/>+$50]
        ES3[Event: WithdrawalMade<br/>-$30]
        ES4[Current State<br/>Balance = $120]
        ES1 --> ES2
        ES2 --> ES3
        ES3 --> ES4
        ES1 -.Stored.-> ES1
        ES2 -.Stored.-> ES2
        ES3 -.Stored.-> ES3
    end
    
    style Traditional fill:#fecaca,stroke:#dc2626,stroke-width:2px
    style EventSourcing fill:#bbf7d0,stroke:#16a34a,stroke-width:2px
    style ES4 fill:#3b82f6,stroke:#2563eb,stroke-width:2px,color:#fff
          </div>

          <h2>Core Concepts</h2>
          <div class="row g-3 mb-4">
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-blue">
                <div class="card-body">
                  <h3>üìù Event Store</h3>
                  <p>Append-only log of all events. Events are immutable and never deleted or modified.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-green">
                <div class="card-body">
                  <h3>üîÑ Event Replay</h3>
                  <p>Rebuild current state by replaying events from the event store from the beginning.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-purple">
                <div class="card-body">
                  <h3>üì∏ Snapshots</h3>
                  <p>Periodic state checkpoints to avoid replaying all events from the beginning.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-orange">
                <div class="card-body">
                  <h3>üéØ Projections</h3>
                  <p>Read models built by processing event streams, optimized for specific queries.</p>
                </div>
              </div>
            </div>
          </div>

          <h2>Event Sourcing Flow</h2>
          <div class="mermaid">
sequenceDiagram
    participant Client
    participant CommandHandler
    participant Aggregate
    participant EventStore
    participant Projection
    participant ReadModel
    
    Client->>CommandHandler: Send Command
    CommandHandler->>EventStore: Load Events for Aggregate
    EventStore-->>CommandHandler: Return Events
    CommandHandler->>Aggregate: Rebuild State from Events
    Aggregate->>Aggregate: Process Command
    Aggregate->>EventStore: Append New Event
    EventStore->>Projection: Publish Event
    Projection->>ReadModel: Update Read Model
    CommandHandler-->>Client: Success
    
    Note over EventStore: Events are<br/>immutable
    Note over Projection: Eventual<br/>Consistency
          </div>

          <h2>Benefits of Event Sourcing</h2>
          <ul>
            <li><strong>Complete Audit Trail:</strong> Every state change is recorded permanently with timestamps</li>
            <li><strong>Temporal Queries:</strong> Query the state at any point in history by replaying events up to that time</li>
            <li><strong>Event Replay:</strong> Fix bugs by correcting event handlers and replaying events</li>
            <li><strong>Debugging:</strong> Reproduce bugs by replaying the exact sequence of events</li>
            <li><strong>Business Intelligence:</strong> Analyze historical data and understand how the system evolved</li>
            <li><strong>Event-Driven Integration:</strong> Events can be consumed by other systems for integration</li>
            <li><strong>Versioning:</strong> Handle schema changes by versioning events</li>
          </ul>

          <h2>Challenges of Event Sourcing</h2>
          <ul>
            <li><strong>Complexity:</strong> More complex than traditional CRUD, requires new mindset</li>
            <li><strong>Event Schema Evolution:</strong> Managing changes to event structure over time</li>
            <li><strong>Performance:</strong> Replaying many events can be slow; need snapshots</li>
            <li><strong>Query Complexity:</strong> Simple queries may require rebuilding state or using projections</li>
            <li><strong>Learning Curve:</strong> Team needs to understand event sourcing patterns</li>
            <li><strong>Eventual Consistency:</strong> Read models are eventually consistent with write model</li>
          </ul>

          <h2>Event Store Structure</h2>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th>Field</th>
                <th>Description</th>
                <th>Example</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Event ID</strong></td>
                <td>Unique identifier for the event</td>
                <td>UUID</td>
              </tr>
              <tr>
                <td><strong>Aggregate ID</strong></td>
                <td>ID of the aggregate the event belongs to</td>
                <td>Order-123</td>
              </tr>
              <tr>
                <td><strong>Event Type</strong></td>
                <td>Type/name of the event</td>
                <td>OrderPlaced</td>
              </tr>
              <tr>
                <td><strong>Event Data</strong></td>
                <td>JSON payload with event details</td>
                <td>{"orderId": "123", "total": 99.99}</td>
              </tr>
              <tr>
                <td><strong>Version</strong></td>
                <td>Sequence number for this aggregate</td>
                <td>1, 2, 3...</td>
              </tr>
              <tr>
                <td><strong>Timestamp</strong></td>
                <td>When the event occurred</td>
                <td>2026-01-06T10:30:00Z</td>
              </tr>
              <tr>
                <td><strong>Metadata</strong></td>
                <td>User ID, correlation ID, etc.</td>
                <td>{"userId": "user-456"}</td>
              </tr>
            </tbody>
          </table>

          <h2>Snapshots for Performance</h2>
          <p>
            As the event stream grows, replaying all events becomes slow. <strong>Snapshots</strong> are periodic checkpoints of 
            aggregate state that allow you to start replay from a recent point instead of from the beginning.
          </p>

          <div class="mermaid">
graph LR
    E1[Event 1] --> E2[Event 2]
    E2 --> E3[Event 3]
    E3 --> S1[Snapshot 1]
    S1 --> E4[Event 4]
    E4 --> E5[Event 5]
    E5 --> S2[Snapshot 2]
    S2 --> E6[Event 6]
    E6 --> E7[Event 7]
    E7 --> Current[Current State]
    
    S2 -.Load from here<br/>instead of Event 1.-> S2
    
    style S1 fill:#10b981,stroke:#059669,stroke-width:2px,color:#fff
    style S2 fill:#10b981,stroke:#059669,stroke-width:2px,color:#fff
    style Current fill:#3b82f6,stroke:#2563eb,stroke-width:2px,color:#fff
          </div>

          <p><strong>Snapshot Strategy:</strong> Create a snapshot every N events (e.g., every 100 events) or after specific critical events.</p>

          <h2>Event Schema Versioning</h2>
          <p>As your application evolves, event schemas change. Handle this by:</p>
          <ul>
            <li><strong>Version Field:</strong> Include version number in events</li>
            <li><strong>Upcasting:</strong> Transform old event versions to new versions during replay</li>
            <li><strong>Multiple Handlers:</strong> Support multiple event versions with separate handlers</li>
            <li><strong>Schema Registry:</strong> Central repository for event schemas and versions</li>
          </ul>

          <h2>Event Sourcing Technologies</h2>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th>Technology</th>
                <th>Type</th>
                <th>Features</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>EventStore DB</strong></td>
                <td>Purpose-built event store</td>
                <td>Optimized for event sourcing, projections, subscriptions</td>
              </tr>
              <tr>
                <td><strong>Apache Kafka</strong></td>
                <td>Event streaming platform</td>
                <td>High throughput, distributed, log compaction</td>
              </tr>
              <tr>
                <td><strong>Axon Framework</strong></td>
                <td>Java framework</td>
                <td>CQRS + Event Sourcing, Axon Server included</td>
              </tr>
              <tr>
                <td><strong>Marten</strong></td>
                <td>.NET library</td>
                <td>Event sourcing on PostgreSQL</td>
              </tr>
              <tr>
                <td><strong>Azure Cosmos DB</strong></td>
                <td>NoSQL database</td>
                <td>Change feed, globally distributed</td>
              </tr>
              <tr>
                <td><strong>SQL Database</strong></td>
                <td>Relational DB</td>
                <td>Simple table with append-only pattern</td>
              </tr>
            </tbody>
          </table>

          <h2>When to Use Event Sourcing</h2>
          <div class="row g-3 mb-4">
            <div class="col-md-12">
              <div class="card border-0 shadow-sm bg-gradient-green-light">
                <div class="card-body">
                  <h3>‚úÖ Good Fit</h3>
                  <ul class="mb-0">
                    <li>Audit and compliance requirements (financial, healthcare)</li>
                    <li>Need for complete historical record</li>
                    <li>Temporal queries (state at any point in time)</li>
                    <li>Event-driven systems with complex workflows</li>
                    <li>Business intelligence and analytics on historical data</li>
                    <li>Systems requiring event replay for debugging or bug fixes</li>
                  </ul>
                </div>
              </div>
            </div>
            <div class="col-md-12">
              <div class="card border-0 shadow-sm bg-gradient-red">
                <div class="card-body">
                  <h3>‚ùå Overkill For</h3>
                  <ul class="mb-0">
                    <li>Simple CRUD applications</li>
                    <li>No audit or historical query requirements</li>
                    <li>Team not familiar with event sourcing patterns</li>
                    <li>Low tolerance for eventual consistency</li>
                    <li>Very simple domain logic</li>
                  </ul>
                </div>
              </div>
            </div>
          </div>

          <div class="callout">
            <strong>üí° Key Takeaway:</strong> Event Sourcing provides complete audit trails and temporal query capabilities by 
            storing all state changes as events. It's powerful for systems requiring full history, compliance, or event replay. 
            However, it adds complexity - use snapshots to improve performance, implement proper event versioning strategies, and 
            combine with CQRS for optimized read models. Start simple with a small bounded context before applying event sourcing 
            across your entire system. Not every part of your application needs event sourcing - apply it where audit and history 
            are critical.
          </div>
        </section>

        <!-- CQRS Section -->
        <section id="cqrs" role="article">
          <h1>CQRS (Command Query Responsibility Segregation)</h1>
          <span class="badge">eda</span>
          <span class="badge">cqrs</span>
          <span class="badge">separation</span>
          
          <h2>What is CQRS?</h2>
          <p>
            <strong>CQRS (Command Query Responsibility Segregation)</strong> is a pattern that separates read operations (queries) 
            from write operations (commands). Instead of using the same model for both reading and writing, CQRS uses different 
            models optimized for each purpose.
          </p>
          <p>
            The core principle comes from Bertrand Meyer's Command-Query Separation: methods should either change state (commands) 
            or return data (queries), but not both. CQRS takes this to the architectural level.
          </p>

          <h2>Traditional vs CQRS Architecture</h2>
          <div class="mermaid">
graph TB
    subgraph Traditional[Traditional: Single Model]
        TC[Client] --> TM[Unified Model]
        TM --> TDB[(Database)]
        TM -.reads.-> TDB
        TM -.writes.-> TDB
    end
    
    subgraph CQRS[CQRS: Separate Models]
        CC[Client]
        CC --> CM[Command Model<br/>Write Optimized]
        CC --> QM[Query Model<br/>Read Optimized]
        CM --> WDB[(Write DB)]
        QM --> RDB[(Read DB)]
        WDB -.events.-> Sync[Sync/Events]
        Sync -.updates.-> RDB
    end
    
    style Traditional fill:#fecaca,stroke:#dc2626,stroke-width:2px
    style CQRS fill:#bbf7d0,stroke:#16a34a,stroke-width:2px
    style CM fill:#3b82f6,stroke:#2563eb,stroke-width:2px,color:#fff
    style QM fill:#8b5cf6,stroke:#7c3aed,stroke-width:2px,color:#fff
          </div>

          <h2>Commands vs Queries</h2>
          <div class="row g-3 mb-4">
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-blue">
                <div class="card-body">
                  <h3>üìù Commands (Writes)</h3>
                  <p><strong>Purpose:</strong> Change system state</p>
                  <p><strong>Naming:</strong> Imperative (PlaceOrder, CancelOrder)</p>
                  <p><strong>Return:</strong> Success/failure, no data</p>
                  <p><strong>Model:</strong> Rich domain model with business logic</p>
                  <p class="mb-0"><strong>Storage:</strong> Normalized, transaction-optimized</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-purple">
                <div class="card-body">
                  <h3>üîç Queries (Reads)</h3>
                  <p><strong>Purpose:</strong> Return data without side effects</p>
                  <p><strong>Naming:</strong> Question form (GetOrder, FindCustomers)</p>
                  <p><strong>Return:</strong> Data transfer objects (DTOs)</p>
                  <p><strong>Model:</strong> Denormalized, view-optimized</p>
                  <p class="mb-0"><strong>Storage:</strong> Denormalized, read-optimized (cache, materialized views)</p>
                </div>
              </div>
            </div>
          </div>

          <h2>CQRS Implementation Patterns</h2>
          
          <h3>1. Single Database CQRS</h3>
          <p>Simplest form - separate models but same database. Different read/write models with different optimizations.</p>

          <h3>2. Separate Databases CQRS</h3>
          <p>
            Different databases for reads and writes. Write side uses normalized relational DB for consistency, read side uses 
            denormalized NoSQL for performance.
          </p>

          <h3>3. Event-Driven CQRS</h3>
          <p>
            Commands produce events that update read models. Often combined with Event Sourcing where events are the source of truth.
          </p>

          <div class="mermaid">
graph TB
    Client[Client] --> CommandAPI[Command API]
    Client --> QueryAPI[Query API]
    
    CommandAPI --> CommandHandler[Command Handler]
    CommandHandler --> WriteModel[Write Model<br/>Aggregates]
    WriteModel --> WriteDB[(Write DB<br/>Normalized)]
    
    WriteDB --> Events[Domain Events]
    Events --> EventBus[Event Bus]
    EventBus --> Projection1[Projection 1]
    EventBus --> Projection2[Projection 2]
    EventBus --> Projection3[Projection 3]
    
    Projection1 --> ReadDB1[(Read DB 1<br/>Denormalized)]
    Projection2 --> ReadDB2[(Read DB 2<br/>Cache)]
    Projection3 --> ReadDB3[(Read DB 3<br/>Search Index)]
    
    QueryAPI --> ReadDB1
    QueryAPI --> ReadDB2
    QueryAPI --> ReadDB3
    
    style CommandAPI fill:#3b82f6,stroke:#2563eb,stroke-width:2px,color:#fff
    style QueryAPI fill:#8b5cf6,stroke:#7c3aed,stroke-width:2px,color:#fff
    style EventBus fill:#10b981,stroke:#059669,stroke-width:2px,color:#fff
          </div>

          <h2>Benefits of CQRS</h2>
          <ul>
            <li><strong>Optimized Models:</strong> Separate models can be optimized for their specific use case</li>
            <li><strong>Scalability:</strong> Scale reads and writes independently based on demand</li>
            <li><strong>Performance:</strong> Read models can be denormalized and cached for fast queries</li>
            <li><strong>Flexibility:</strong> Use different storage technologies for reads vs writes</li>
            <li><strong>Security:</strong> Easier to enforce different permissions for reads vs writes</li>
            <li><strong>Simplified Queries:</strong> Read models tailored to specific query needs</li>
            <li><strong>Team Autonomy:</strong> Different teams can work on read vs write sides</li>
          </ul>

          <h2>Challenges of CQRS</h2>
          <ul>
            <li><strong>Complexity:</strong> More moving parts than traditional architecture</li>
            <li><strong>Eventual Consistency:</strong> Read models may lag behind write model</li>
            <li><strong>Data Duplication:</strong> Same data stored in multiple places</li>
            <li><strong>Synchronization:</strong> Must keep read and write models in sync</li>
            <li><strong>Learning Curve:</strong> Team needs to understand CQRS patterns</li>
            <li><strong>Debugging:</strong> More complex to trace issues across separate models</li>
          </ul>

          <h2>CQRS with Event Sourcing</h2>
          <p>
            CQRS and Event Sourcing are often used together but are independent patterns. Event Sourcing provides a natural way 
            to synchronize read and write models through events.
          </p>

          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th>Aspect</th>
                <th>CQRS Alone</th>
                <th>CQRS + Event Sourcing</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Write Storage</strong></td>
                <td>Traditional database with current state</td>
                <td>Event store with event history</td>
              </tr>
              <tr>
                <td><strong>Read Sync</strong></td>
                <td>Database triggers, Change Data Capture</td>
                <td>Event subscriptions</td>
              </tr>
              <tr>
                <td><strong>Audit Trail</strong></td>
                <td>Separate audit table</td>
                <td>Built-in via event store</td>
              </tr>
              <tr>
                <td><strong>Complexity</strong></td>
                <td>Medium</td>
                <td>Higher</td>
              </tr>
              <tr>
                <td><strong>Temporal Queries</strong></td>
                <td>Difficult</td>
                <td>Built-in</td>
              </tr>
            </tbody>
          </table>

          <h2>Read Model Synchronization Strategies</h2>
          
          <h3>1. Synchronous Updates</h3>
          <p>Update read model in the same transaction as write. Simple but couples read/write.</p>

          <h3>2. Asynchronous Updates via Events</h3>
          <p>Write model publishes events, projections update read models. Eventual consistency.</p>

          <h3>3. Change Data Capture (CDC)</h3>
          <p>Automatically capture database changes and update read models (e.g., Debezium).</p>

          <h3>4. Polling</h3>
          <p>Periodically query write database for changes. Simple but inefficient.</p>

          <h2>CQRS Implementation Technologies</h2>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th>Framework/Tool</th>
                <th>Language</th>
                <th>Features</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>MediatR</strong></td>
                <td>.NET</td>
                <td>In-process messaging, command/query handlers</td>
              </tr>
              <tr>
                <td><strong>Axon Framework</strong></td>
                <td>Java</td>
                <td>CQRS + Event Sourcing, Axon Server</td>
              </tr>
              <tr>
                <td><strong>NestJS CQRS</strong></td>
                <td>TypeScript</td>
                <td>Built-in CQRS module for Node.js</td>
              </tr>
              <tr>
                <td><strong>Akka</strong></td>
                <td>Scala/Java</td>
                <td>Actor-based, event sourcing support</td>
              </tr>
              <tr>
                <td><strong>Lagom</strong></td>
                <td>Scala/Java</td>
                <td>Microservices framework with CQRS</td>
              </tr>
              <tr>
                <td><strong>Eventuate</strong></td>
                <td>Java</td>
                <td>Event sourcing and CQRS for microservices</td>
              </tr>
            </tbody>
          </table>

          <h2>When to Use CQRS</h2>
          <div class="row g-3 mb-4">
            <div class="col-md-12">
              <div class="card border-0 shadow-sm bg-gradient-green-light">
                <div class="card-body">
                  <h3>‚úÖ Good Fit</h3>
                  <ul class="mb-0">
                    <li>High read-to-write ratio (optimize reads separately)</li>
                    <li>Complex business logic on write side</li>
                    <li>Different scalability needs for reads vs writes</li>
                    <li>Multiple read representations needed (web, mobile, reporting)</li>
                    <li>Performance-critical queries requiring denormalization</li>
                    <li>Event-driven systems with eventual consistency</li>
                  </ul>
                </div>
              </div>
            </div>
            <div class="col-md-12">
              <div class="card border-0 shadow-sm bg-gradient-red">
                <div class="card-body">
                  <h3>‚ùå Overkill For</h3>
                  <ul class="mb-0">
                    <li>Simple CRUD applications</li>
                    <li>Similar read and write patterns</li>
                    <li>Need for immediate consistency</li>
                    <li>Small applications with limited complexity</li>
                    <li>Teams unfamiliar with CQRS patterns</li>
                  </ul>
                </div>
              </div>
            </div>
          </div>

          <div class="callout">
            <strong>üí° Key Takeaway:</strong> CQRS separates read and write models to optimize each independently. Use it when 
            you have different scalability or complexity needs for reads vs writes. Start simple with a single database and separate 
            models before moving to multiple databases. Combine with Event Sourcing for audit trails and temporal queries, but 
            understand that CQRS alone is simpler and may be sufficient. Accept eventual consistency - if you need immediate 
            consistency, CQRS may not be the right pattern. Focus CQRS on bounded contexts where it provides clear value, not 
            across your entire application.
          </div>
        </section>

        <!-- Event Streaming Section -->
        <section id="event-streaming" role="article">
          <h1>Event Streaming</h1>
          <span class="badge">eda</span>
          <span class="badge">streaming</span>
          <span class="badge">real-time</span>
          
          <h2>What is Event Streaming?</h2>
          <p>
            <strong>Event Streaming</strong> is the practice of capturing data in real-time from event sources like databases, 
            sensors, mobile devices, and applications in the form of streams of events. These event streams are stored durably 
            and can be processed, manipulated, and reacted to in real-time or retrospectively.
          </p>
          <p>
            Think of event streaming as a continuous flow of data - like a river of events flowing through your system. Unlike 
            traditional messaging where events are delivered and removed, event streams persist events allowing multiple consumers 
            to process them at different times.
          </p>

          <h2>Event Streaming vs Traditional Messaging</h2>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th>Aspect</th>
                <th>Traditional Messaging</th>
                <th>Event Streaming</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Storage</strong></td>
                <td>Temporary - deleted after consumption</td>
                <td>Durable - retained for configured period</td>
              </tr>
              <tr>
                <td><strong>Consumption</strong></td>
                <td>Typically consumed once</td>
                <td>Can be replayed by multiple consumers</td>
              </tr>
              <tr>
                <td><strong>Order</strong></td>
                <td>May not guarantee order</td>
                <td>Strict ordering within partitions</td>
              </tr>
              <tr>
                <td><strong>Scale</strong></td>
                <td>Moderate throughput</td>
                <td>Very high throughput (millions/sec)</td>
              </tr>
              <tr>
                <td><strong>Use Case</strong></td>
                <td>Task queues, point-to-point messaging</td>
                <td>Real-time analytics, event sourcing, log aggregation</td>
              </tr>
            </tbody>
          </table>

          <h2>Event Streaming Architecture</h2>
          <div class="mermaid">
graph TB
    subgraph Producers[Event Producers]
        P1[Web App]
        P2[Mobile App]
        P3[IoT Devices]
        P4[Microservices]
    end
    
    subgraph StreamingPlatform[Streaming Platform - Apache Kafka]
        Topic1[Topic: User Events]
        Topic2[Topic: Order Events]
        Topic3[Topic: IoT Events]
    end
    
    subgraph Consumers[Event Consumers]
        C1[Real-Time Analytics]
        C2[Database Sync]
        C3[Notification Service]
        C4[ML Training]
        C5[Data Lake]
    end
    
    P1 --> Topic1
    P2 --> Topic1
    P1 --> Topic2
    P3 --> Topic3
    P4 --> Topic2
    
    Topic1 --> C1
    Topic1 --> C4
    Topic2 --> C2
    Topic2 --> C3
    Topic3 --> C1
    Topic3 --> C5
    
    style StreamingPlatform fill:#3b82f6,stroke:#2563eb,stroke-width:3px,color:#fff
    style Producers fill:#10b981,stroke:#059669,stroke-width:2px
    style Consumers fill:#8b5cf6,stroke:#7c3aed,stroke-width:2px
          </div>

          <h2>Core Concepts</h2>
          <div class="row g-3 mb-4">
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-blue">
                <div class="card-body">
                  <h3>üìã Topics</h3>
                  <p class="mb-0">Categories or feed names to which events are published. Topics are split into partitions for parallelism.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-green">
                <div class="card-body">
                  <h3>üì¶ Partitions</h3>
                  <p class="mb-0">Ordered, immutable sequence of events within a topic. Enable parallel processing and scalability.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-purple">
                <div class="card-body">
                  <h3>üìç Offsets</h3>
                  <p class="mb-0">Sequential ID assigned to each event in a partition. Consumers track their position using offsets.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-orange">
                <div class="card-body">
                  <h3>üë• Consumer Groups</h3>
                  <p class="mb-0">Multiple consumers working together. Each partition assigned to one consumer for parallel processing.</p>
                </div>
              </div>
            </div>
          </div>

          <h2>Event Streaming Platforms</h2>
          
          <h3>Apache Kafka</h3>
          <p>
            The most popular event streaming platform. Distributed, fault-tolerant, and designed for high-throughput, low-latency 
            event streaming. Used by thousands of companies for mission-critical applications.
          </p>

          <h3>Key Features</h3>
          <ul>
            <li><strong>High Throughput:</strong> Millions of events per second</li>
            <li><strong>Durability:</strong> Events persisted to disk and replicated</li>
            <li><strong>Scalability:</strong> Horizontal scaling by adding brokers</li>
            <li><strong>Fault Tolerance:</strong> Replication and automatic failover</li>
            <li><strong>Replay:</strong> Consumers can replay events from any point</li>
            <li><strong>Stream Processing:</strong> Built-in stream processing with Kafka Streams</li>
          </ul>

          <h2>Stream Processing Patterns</h2>
          
          <h3>1. Stateless Processing</h3>
          <p>Transform or filter events without maintaining state between events.</p>
          <ul>
            <li>Map: Transform each event</li>
            <li>Filter: Select events matching criteria</li>
            <li>FlatMap: One-to-many transformations</li>
          </ul>

          <h3>2. Stateful Processing</h3>
          <p>Maintain state across events for aggregations, joins, and windowing.</p>
          <ul>
            <li>Aggregation: Count, sum, average over events</li>
            <li>Windowing: Group events by time windows</li>
            <li>Joins: Combine streams based on keys</li>
          </ul>

          <div class="mermaid">
graph LR
    subgraph Stateless[Stateless Processing]
        S1[Event Stream] --> Filter[Filter]
        Filter --> Map[Map]
        Map --> S2[Processed Stream]
    end
    
    subgraph Stateful[Stateful Processing]
        ST1[Event Stream] --> Window[Time Window]
        Window --> Aggregate[Aggregate]
        Aggregate --> State[(State Store)]
        State --> Output[Output Stream]
    end
    
    style Stateless fill:#e0f2fe,stroke:#0284c7,stroke-width:2px
    style Stateful fill:#f3e8ff,stroke:#9333ea,stroke-width:2px
    style State fill:#fef3c7,stroke:#f59e0b,stroke-width:2px
          </div>

          <h2>Common Use Cases</h2>
          <div class="row g-3 mb-4">
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-blue-sky">
                <div class="card-body">
                  <h4>Real-Time Analytics</h4>
                  <p class="mb-0">Process clickstreams, metrics, and logs in real-time for dashboards and alerts. Track KPIs and detect anomalies instantly.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-green-light">
                <div class="card-body">
                  <h4>Data Integration</h4>
                  <p class="mb-0">Sync data between databases, services, and data warehouses. Change Data Capture (CDC) for real-time replication.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-purple">
                <div class="card-body">
                  <h4>Event Sourcing</h4>
                  <p class="mb-0">Store all state changes as events in Kafka. Rebuild application state by replaying event stream.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-orange">
                <div class="card-body">
                  <h4>IoT Data Processing</h4>
                  <p class="mb-0">Ingest millions of sensor events per second. Real-time monitoring, predictive maintenance, and analytics.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-red">
                <div class="card-body">
                  <h4>Microservices Communication</h4>
                  <p class="mb-0">Asynchronous communication between microservices. Event-driven choreography for complex workflows.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-yellow">
                <div class="card-body">
                  <h4>Log Aggregation</h4>
                  <p class="mb-0">Collect logs from all services into central stream. Real-time log analysis, monitoring, and alerting.</p>
                </div>
              </div>
            </div>
          </div>

          <h2>Kafka Ecosystem</h2>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th>Component</th>
                <th>Purpose</th>
                <th>Use Case</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Kafka Brokers</strong></td>
                <td>Core event storage and distribution</td>
                <td>High-throughput event streaming</td>
              </tr>
              <tr>
                <td><strong>Kafka Streams</strong></td>
                <td>Stream processing library</td>
                <td>Real-time transformations and aggregations</td>
              </tr>
              <tr>
                <td><strong>Kafka Connect</strong></td>
                <td>Data integration framework</td>
                <td>Connect Kafka to databases, S3, etc.</td>
              </tr>
              <tr>
                <td><strong>Schema Registry</strong></td>
                <td>Centralized schema management</td>
                <td>Event schema versioning and validation</td>
              </tr>
              <tr>
                <td><strong>KSQL/ksqlDB</strong></td>
                <td>SQL interface for streams</td>
                <td>Query streams using SQL syntax</td>
              </tr>
              <tr>
                <td><strong>Zookeeper</strong></td>
                <td>Coordination service (being phased out)</td>
                <td>Cluster coordination and metadata</td>
              </tr>
            </tbody>
          </table>

          <h2>Alternative Streaming Platforms</h2>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th>Platform</th>
                <th>Provider</th>
                <th>Key Features</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Azure Event Hubs</strong></td>
                <td>Microsoft</td>
                <td>Kafka-compatible, Azure integration, auto-scaling</td>
              </tr>
              <tr>
                <td><strong>Amazon Kinesis</strong></td>
                <td>AWS</td>
                <td>Fully managed, AWS integration, serverless</td>
              </tr>
              <tr>
                <td><strong>Google Cloud Pub/Sub</strong></td>
                <td>Google</td>
                <td>Global distribution, GCP integration</td>
              </tr>
              <tr>
                <td><strong>Apache Pulsar</strong></td>
                <td>Apache</td>
                <td>Multi-tenancy, geo-replication, unified messaging</td>
              </tr>
              <tr>
                <td><strong>Redis Streams</strong></td>
                <td>Redis</td>
                <td>In-memory, low latency, simple deployment</td>
              </tr>
            </tbody>
          </table>

          <h2>Best Practices</h2>
          <ul>
            <li><strong>Partition Key Strategy:</strong> Choose keys that distribute load evenly across partitions</li>
            <li><strong>Event Schema:</strong> Use schema registry for versioning and backward compatibility</li>
            <li><strong>Idempotent Consumers:</strong> Handle duplicate events gracefully</li>
            <li><strong>Exactly-Once Semantics:</strong> Enable when strict guarantees needed (with performance trade-off)</li>
            <li><strong>Monitoring:</strong> Track lag, throughput, and consumer health</li>
            <li><strong>Retention Policy:</strong> Configure appropriate retention based on replay needs</li>
            <li><strong>Compaction:</strong> Use log compaction for storing latest state per key</li>
            <li><strong>Security:</strong> Enable encryption, authentication, and authorization</li>
          </ul>

          <h2>When to Use Event Streaming</h2>
          <div class="row g-3 mb-4">
            <div class="col-md-12">
              <div class="card border-0 shadow-sm bg-gradient-green-light">
                <div class="card-body">
                  <h3>‚úÖ Good Fit</h3>
                  <ul class="mb-0">
                    <li>High-volume event processing (thousands to millions per second)</li>
                    <li>Real-time analytics and monitoring</li>
                    <li>Event sourcing and audit trails</li>
                    <li>Data integration and CDC</li>
                    <li>IoT and sensor data ingestion</li>
                    <li>Need to replay historical events</li>
                    <li>Multiple consumers processing same events</li>
                  </ul>
                </div>
              </div>
            </div>
            <div class="col-md-12">
              <div class="card border-0 shadow-sm bg-gradient-red">
                <div class="card-body">
                  <h3>‚ùå Overkill For</h3>
                  <ul class="mb-0">
                    <li>Low event volumes (< 100 events/sec)</li>
                    <li>Simple point-to-point messaging</li>
                    <li>Request-response patterns</li>
                    <li>No need for event replay</li>
                    <li>Team lacks streaming expertise</li>
                  </ul>
                </div>
              </div>
            </div>
          </div>

          <div class="callout">
            <strong>üí° Key Takeaway:</strong> Event Streaming enables real-time data processing at massive scale with durable, 
            replayable event logs. Use Apache Kafka or managed alternatives (Azure Event Hubs, AWS Kinesis) for high-throughput 
            scenarios. Choose proper partition keys for load distribution. Implement idempotent consumers for reliability. Use 
            schema registry for event versioning. Event streaming is ideal for real-time analytics, data integration, and event 
            sourcing, but adds operational complexity - ensure your team has the expertise before adopting. Start with managed 
            services to reduce operational burden.
          </div>
        </section>

        <!-- Message-Driven Systems Section -->
        <section id="message-driven" role="article">
          <h1>üì® Message-Driven Systems</h1>
          <span class="badge">messaging</span>
          <span class="badge">async</span>
          <span class="badge">communication</span>
          
          <h2>What are Message-Driven Systems?</h2>
          <p>
            <strong>Message-Driven Systems</strong> are architectures where components communicate by sending and receiving messages 
            asynchronously through a message broker or message bus. Unlike direct method calls, messages are sent to intermediaries 
            that handle delivery, routing, and persistence, enabling loose coupling and resilient communication patterns.
          </p>
          <p>
            Message-driven architecture is one of the four pillars of Reactive Systems (responsive, resilient, elastic, and 
            message-driven) and forms the foundation for building scalable, fault-tolerant distributed applications.
          </p>

          <h2>Message-Driven vs Event-Driven</h2>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th>Aspect</th>
                <th>Message-Driven</th>
                <th>Event-Driven</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Focus</strong></td>
                <td>Addressable recipients</td>
                <td>Broadcast of facts</td>
              </tr>
              <tr>
                <td><strong>Intent</strong></td>
                <td>Command or request to do something</td>
                <td>Notification that something happened</td>
              </tr>
              <tr>
                <td><strong>Addressing</strong></td>
                <td>Point-to-point or specific queues</td>
                <td>Pub/sub to topics</td>
              </tr>
              <tr>
                <td><strong>Delivery</strong></td>
                <td>Exactly one consumer processes message</td>
                <td>Multiple subscribers can react to event</td>
              </tr>
              <tr>
                <td><strong>Coupling</strong></td>
                <td>Sender knows destination queue</td>
                <td>Publisher doesn't know subscribers</td>
              </tr>
              <tr>
                <td><strong>Example</strong></td>
                <td>ProcessOrderCommand ‚Üí Order Queue</td>
                <td>OrderPlacedEvent ‚Üí Multiple subscribers</td>
              </tr>
            </tbody>
          </table>

          <h2>Message-Driven Architecture</h2>
          <div class="mermaid">
graph TB
    subgraph Producers[Message Producers]
        P1[Order Service]
        P2[Payment Service]
        P3[User Service]
    end
    
    subgraph MessageBroker[Message Broker]
        Q1[Order Queue]
        Q2[Payment Queue]
        Q3[Email Queue]
        Q4[Notification Queue]
        DLQ[Dead Letter Queue]
    end
    
    subgraph Consumers[Message Consumers]
        C1[Order Processor]
        C2[Payment Processor]
        C3[Email Service]
        C4[Notification Service]
    end
    
    P1 --> Q1
    P2 --> Q2
    P1 --> Q3
    P3 --> Q4
    
    Q1 --> C1
    Q2 --> C2
    Q3 --> C3
    Q4 --> C4
    
    Q1 -.failed messages.-> DLQ
    Q2 -.failed messages.-> DLQ
    
    style MessageBroker fill:#3b82f6,stroke:#2563eb,stroke-width:3px,color:#fff
    style Producers fill:#10b981,stroke:#059669,stroke-width:2px
    style Consumers fill:#8b5cf6,stroke:#7c3aed,stroke-width:2px
    style DLQ fill:#ef4444,stroke:#dc2626,stroke-width:2px,color:#fff
          </div>

          <h2>Core Messaging Patterns</h2>
          <div class="row g-3 mb-4">
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-blue">
                <div class="card-body">
                  <h3>üìç Point-to-Point</h3>
                  <p><strong>Pattern:</strong> One sender, one receiver</p>
                  <p><strong>Mechanism:</strong> Queue-based</p>
                  <p><strong>Guarantee:</strong> Message consumed by exactly one consumer</p>
                  <p class="mb-0"><strong>Use Case:</strong> Task distribution, work queues, command processing</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-green">
                <div class="card-body">
                  <h3>üì¢ Publish-Subscribe</h3>
                  <p><strong>Pattern:</strong> One publisher, multiple subscribers</p>
                  <p><strong>Mechanism:</strong> Topic-based</p>
                  <p><strong>Guarantee:</strong> Message delivered to all subscribers</p>
                  <p class="mb-0"><strong>Use Case:</strong> Broadcast notifications, fan-out patterns</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-purple">
                <div class="card-body">
                  <h3>üîÑ Request-Reply</h3>
                  <p><strong>Pattern:</strong> Asynchronous request/response</p>
                  <p><strong>Mechanism:</strong> Correlation ID and reply queue</p>
                  <p><strong>Guarantee:</strong> Response sent back to requester</p>
                  <p class="mb-0"><strong>Use Case:</strong> Async RPC, service queries with callbacks</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-orange">
                <div class="card-body">
                  <h3>üåê Competing Consumers</h3>
                  <p><strong>Pattern:</strong> Multiple consumers on same queue</p>
                  <p><strong>Mechanism:</strong> Load balancing across consumers</p>
                  <p><strong>Guarantee:</strong> Each message processed by one consumer</p>
                  <p class="mb-0"><strong>Use Case:</strong> Parallel processing, scalability</p>
                </div>
              </div>
            </div>
          </div>

          <h2>Message Delivery Guarantees</h2>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th>Guarantee</th>
                <th>Description</th>
                <th>Trade-offs</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>At-Most-Once</strong></td>
                <td>Message delivered zero or one time, may be lost</td>
                <td>Fastest, lowest overhead, acceptable data loss</td>
              </tr>
              <tr>
                <td><strong>At-Least-Once</strong></td>
                <td>Message guaranteed delivery, may be duplicated</td>
                <td>Good balance, requires idempotent consumers</td>
              </tr>
              <tr>
                <td><strong>Exactly-Once</strong></td>
                <td>Message delivered exactly one time, no duplicates</td>
                <td>Highest overhead, complex implementation, performance impact</td>
              </tr>
            </tbody>
          </table>

          <h2>Message Structure</h2>
          <p>A well-designed message typically contains:</p>
          <ul>
            <li><strong>Message ID:</strong> Unique identifier for the message</li>
            <li><strong>Timestamp:</strong> When the message was created</li>
            <li><strong>Message Type:</strong> Identifies the message schema/structure</li>
            <li><strong>Payload:</strong> Actual message data (JSON, XML, binary)</li>
            <li><strong>Headers/Metadata:</strong> Routing info, priority, TTL, correlation ID</li>
            <li><strong>Reply-To:</strong> Queue for responses (if request-reply pattern)</li>
            <li><strong>Correlation ID:</strong> Links messages in a conversation</li>
          </ul>

          <h2>Message Brokers & Technologies</h2>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th>Technology</th>
                <th>Type</th>
                <th>Best For</th>
                <th>Key Features</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>RabbitMQ</strong></td>
                <td>Message Broker</td>
                <td>Complex routing, enterprise messaging</td>
                <td>AMQP protocol, flexible routing, plugins</td>
              </tr>
              <tr>
                <td><strong>Azure Service Bus</strong></td>
                <td>Message Broker</td>
                <td>Azure integration, enterprise patterns</td>
                <td>Topics/queues, sessions, transactions</td>
              </tr>
              <tr>
                <td><strong>Amazon SQS</strong></td>
                <td>Queue Service</td>
                <td>Simple queuing, AWS integration</td>
                <td>Fully managed, FIFO queues, scalable</td>
              </tr>
              <tr>
                <td><strong>Amazon SNS</strong></td>
                <td>Pub/Sub Service</td>
                <td>Fan-out notifications, mobile push</td>
                <td>Topics, SMS/email/mobile endpoints</td>
              </tr>
              <tr>
                <td><strong>Google Cloud Pub/Sub</strong></td>
                <td>Messaging Service</td>
                <td>GCP applications, global distribution</td>
                <td>At-least-once delivery, ordered messages</td>
              </tr>
              <tr>
                <td><strong>Azure Queue Storage</strong></td>
                <td>Queue Service</td>
                <td>Simple queuing, cost-effective</td>
                <td>REST API, large message volumes</td>
              </tr>
              <tr>
                <td><strong>ActiveMQ</strong></td>
                <td>Message Broker</td>
                <td>Java applications, JMS support</td>
                <td>Multiple protocols, clustering</td>
              </tr>
              <tr>
                <td><strong>NATS</strong></td>
                <td>Message System</td>
                <td>Cloud-native, microservices</td>
                <td>High performance, lightweight, simple</td>
              </tr>
            </tbody>
          </table>

          <h2>Advanced Messaging Patterns</h2>
          
          <h3>1. Priority Queue</h3>
          <p>Messages with higher priority are processed before lower priority messages.</p>

          <h3>2. Dead Letter Queue (DLQ)</h3>
          <p>Failed messages sent to special queue for later inspection and handling.</p>

          <h3>3. Message Routing</h3>
          <p>Route messages based on content, headers, or rules to different queues or consumers.</p>

          <h3>4. Content-Based Routing</h3>
          <p>Messages routed to different destinations based on message content or properties.</p>

          <h3>5. Message Aggregator</h3>
          <p>Combine multiple related messages into a single message.</p>

          <h3>6. Message Splitter</h3>
          <p>Break a single message into multiple messages for parallel processing.</p>

          <div class="mermaid">
graph TB
    Source[Message Source] --> Router[Content-Based Router]
    
    Router --> Q1[High Priority Queue]
    Router --> Q2[Medium Priority Queue]
    Router --> Q3[Low Priority Queue]
    
    Q1 --> C1[Fast Consumer]
    Q2 --> C2[Normal Consumer]
    Q3 --> C3[Batch Consumer]
    
    C1 -.fails.-> DLQ[Dead Letter Queue]
    C2 -.fails.-> DLQ
    C3 -.fails.-> DLQ
    
    DLQ --> Manual[Manual Review/<br/>Retry Logic]
    
    style Router fill:#3b82f6,stroke:#2563eb,stroke-width:3px,color:#fff
    style Q1 fill:#ef4444,stroke:#dc2626,stroke-width:2px,color:#fff
    style Q2 fill:#f59e0b,stroke:#d97706,stroke-width:2px,color:#fff
    style Q3 fill:#10b981,stroke:#059669,stroke-width:2px,color:#fff
    style DLQ fill:#64748b,stroke:#475569,stroke-width:2px,color:#fff
          </div>

          <h2>Benefits of Message-Driven Architecture</h2>
          <ul>
            <li><strong>Loose Coupling:</strong> Services don't need to know about each other, only message formats</li>
            <li><strong>Resilience:</strong> If consumer is down, messages are queued and processed when it recovers</li>
            <li><strong>Scalability:</strong> Add more consumers to handle increased load</li>
            <li><strong>Load Leveling:</strong> Smooth out traffic spikes by queuing messages</li>
            <li><strong>Asynchronous Processing:</strong> Improve response times by offloading work to background</li>
            <li><strong>Reliability:</strong> Message brokers provide persistence and delivery guarantees</li>
            <li><strong>Decoupling Temporal:</strong> Producer and consumer don't need to be online simultaneously</li>
            <li><strong>Transaction Support:</strong> Atomic operations across message send/receive</li>
          </ul>

          <h2>Challenges and Considerations</h2>
          <ul>
            <li><strong>Complexity:</strong> Additional infrastructure and operational overhead</li>
            <li><strong>Message Ordering:</strong> Maintaining order can be difficult in distributed systems</li>
            <li><strong>Idempotency:</strong> Consumers must handle duplicate messages safely</li>
            <li><strong>Debugging:</strong> Harder to trace message flows than synchronous calls</li>
            <li><strong>Latency:</strong> Asynchronous nature adds latency compared to direct calls</li>
            <li><strong>Message Versioning:</strong> Handling schema changes across producers/consumers</li>
            <li><strong>Monitoring:</strong> Need to track queue depths, processing rates, errors</li>
            <li><strong>Dead Letters:</strong> Must handle failed messages appropriately</li>
          </ul>

          <h2>Best Practices</h2>
          <div class="row g-3 mb-4">
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-blue-sky">
                <div class="card-body">
                  <h4>‚úÖ Design Practices</h4>
                  <ul class="mb-0">
                    <li>Keep messages small and focused</li>
                    <li>Include correlation IDs for tracing</li>
                    <li>Version your message schemas</li>
                    <li>Use appropriate delivery guarantees</li>
                    <li>Design idempotent consumers</li>
                    <li>Set appropriate TTL (time-to-live)</li>
                  </ul>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-green-light">
                <div class="card-body">
                  <h4>üîß Operational Practices</h4>
                  <ul class="mb-0">
                    <li>Monitor queue depths and lag</li>
                    <li>Implement dead letter queues</li>
                    <li>Use circuit breakers for consumers</li>
                    <li>Set up alerting for failures</li>
                    <li>Plan for message replay scenarios</li>
                    <li>Test failure scenarios regularly</li>
                  </ul>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-purple">
                <div class="card-body">
                  <h4>üîí Security Practices</h4>
                  <ul class="mb-0">
                    <li>Encrypt messages in transit and at rest</li>
                    <li>Implement authentication and authorization</li>
                    <li>Validate message content</li>
                    <li>Use secure protocols (TLS/SSL)</li>
                    <li>Audit message access</li>
                    <li>Sanitize sensitive data in logs</li>
                  </ul>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-orange">
                <div class="card-body">
                  <h4>‚ö° Performance Practices</h4>
                  <ul class="mb-0">
                    <li>Batch messages when appropriate</li>
                    <li>Use competing consumers for parallelism</li>
                    <li>Implement prefetch/batch retrieval</li>
                    <li>Consider message compression</li>
                    <li>Use appropriate message priorities</li>
                    <li>Scale consumers based on queue depth</li>
                  </ul>
                </div>
              </div>
            </div>
          </div>

          <h2>Message-Driven vs Direct Communication</h2>
          <div class="mermaid">
graph TB
    subgraph Direct[Direct Communication - Synchronous]
        S1[Service A] -->|HTTP/gRPC| S2[Service B]
        S2 -->|Response| S1
        S1 -.blocked<br/>waiting.-> S1
    end
    
    subgraph MessageDriven[Message-Driven - Asynchronous]
        MS1[Service A] -->|Send Message| MQ[Message Queue]
        MQ -->|Deliver| MS2[Service B]
        MS1 -.continues<br/>processing.-> MS1
        MS2 -.processes<br/>when ready.-> MS2
    end
    
    style Direct fill:#fecaca,stroke:#dc2626,stroke-width:2px
    style MessageDriven fill:#bbf7d0,stroke:#16a34a,stroke-width:2px
    style MQ fill:#3b82f6,stroke:#2563eb,stroke-width:2px,color:#fff
          </div>

          <h2>When to Use Message-Driven Architecture</h2>
          <div class="row g-3 mb-4">
            <div class="col-md-12">
              <div class="card border-0 shadow-sm bg-gradient-green-light">
                <div class="card-body">
                  <h3>‚úÖ Good Fit</h3>
                  <ul class="mb-0">
                    <li>Microservices requiring loose coupling</li>
                    <li>Asynchronous workflows and background processing</li>
                    <li>Systems requiring high availability and resilience</li>
                    <li>Load leveling and traffic spike handling</li>
                    <li>Distributed transactions across services</li>
                    <li>Long-running processes or batch jobs</li>
                    <li>Integration with external systems</li>
                    <li>Need for guaranteed delivery</li>
                  </ul>
                </div>
              </div>
            </div>
            <div class="col-md-12">
              <div class="card border-0 shadow-sm bg-gradient-red">
                <div class="card-body">
                  <h3>‚ùå Overkill For</h3>
                  <ul class="mb-0">
                    <li>Simple synchronous request-response patterns</li>
                    <li>Real-time user interactions requiring immediate feedback</li>
                    <li>Monolithic applications with in-process communication</li>
                    <li>Very low latency requirements (microseconds)</li>
                    <li>Small applications with limited complexity</li>
                    <li>Team without distributed systems experience</li>
                  </ul>
                </div>
              </div>
            </div>
          </div>

          <h2>Common Use Cases</h2>
          <ul>
            <li><strong>Order Processing:</strong> Decouple order placement from fulfillment workflows</li>
            <li><strong>Email/Notifications:</strong> Async sending without blocking user requests</li>
            <li><strong>Image Processing:</strong> Background processing of uploads</li>
            <li><strong>Data Synchronization:</strong> Keep multiple data stores in sync</li>
            <li><strong>Audit Logging:</strong> Reliable capture of audit events</li>
            <li><strong>Workflow Orchestration:</strong> Multi-step business processes</li>
            <li><strong>Integration:</strong> Connect disparate systems reliably</li>
            <li><strong>Load Distribution:</strong> Distribute work across multiple workers</li>
          </ul>

          <div class="callout">
            <strong>üí° Key Takeaway:</strong> Message-Driven Architecture enables resilient, scalable systems through asynchronous 
            communication via message brokers. Choose point-to-point for task distribution and pub/sub for broadcast patterns. 
            Implement at-least-once delivery with idempotent consumers for reliability. Use dead letter queues for failed messages. 
            Message-driven systems excel at decoupling services, handling load spikes, and ensuring reliable delivery, but add 
            operational complexity. Start with managed message brokers (Azure Service Bus, AWS SQS/SNS) to minimize infrastructure 
            overhead. Design messages carefully with correlation IDs, versioning, and appropriate payloads. Monitor queue depths 
            and consumer health continuously.
          </div>
        </section>

        <!-- Clean Architecture Section -->
        <section id="clean-architecture" role="article">
          <h1>üèõÔ∏è Clean Architecture</h1>
          <span class="badge">clean</span>
          <span class="badge">layered</span>
          <span class="badge">dependency</span>
          
          <h2>What is Clean Architecture?</h2>
          <p>
            <strong>Clean Architecture</strong>, introduced by Robert C. Martin (Uncle Bob), is an architectural pattern that 
            emphasizes separation of concerns through layers, with dependencies pointing inward toward the business logic. The 
            fundamental principle is that the business rules and domain logic are at the center and know nothing about the outer 
            layers (UI, frameworks, databases, external services).
          </p>
          <p>
            The goal is to make the system independent of frameworks, UI, databases, and any external agency. This makes the 
            codebase highly testable, maintainable, and adaptable to changes in technology or requirements.
          </p>

          <h2>The Clean Architecture Diagram</h2>
          <div class="mermaid">
graph TB
    subgraph External[External Layer - Frameworks & Drivers]
        UI[Web/UI]
        DB[Database]
        External1[External APIs]
        Devices[Devices]
    end
    
    subgraph Interface[Interface Adapters Layer]
        Controllers[Controllers]
        Presenters[Presenters]
        Gateways[Gateways]
    end
    
    subgraph Application[Application Business Rules Layer]
        UseCases[Use Cases]
        Interactors[Interactors]
    end
    
    subgraph Domain[Enterprise Business Rules Layer - Core]
        Entities[Entities]
        DomainLogic[Domain Logic]
    end
    
    External --> Interface
    Interface --> Application
    Application --> Domain
    
    External -.Dependencies<br/>point inward.-> Domain
    
    style Domain fill:#3b82f6,stroke:#2563eb,stroke-width:4px,color:#fff
    style Application fill:#10b981,stroke:#059669,stroke-width:3px,color:#fff
    style Interface fill:#f59e0b,stroke:#d97706,stroke-width:2px,color:#fff
    style External fill:#8b5cf6,stroke:#7c3aed,stroke-width:2px,color:#fff
          </div>

          <h2>The Four Layers</h2>
          <div class="row g-3 mb-4">
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-blue">
                <div class="card-body">
                  <h3>1Ô∏è‚É£ Entities (Core)</h3>
                  <p><strong>Purpose:</strong> Enterprise-wide business rules</p>
                  <p><strong>Contains:</strong> Domain entities, business objects</p>
                  <p><strong>Dependencies:</strong> None - most independent</p>
                  <p class="mb-0"><strong>Change Frequency:</strong> Rarely changes</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-green">
                <div class="card-body">
                  <h3>2Ô∏è‚É£ Use Cases</h3>
                  <p><strong>Purpose:</strong> Application-specific business rules</p>
                  <p><strong>Contains:</strong> Interactors, application services</p>
                  <p><strong>Dependencies:</strong> Only on Entities layer</p>
                  <p class="mb-0"><strong>Change Frequency:</strong> Changes with features</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-orange">
                <div class="card-body">
                  <h3>3Ô∏è‚É£ Interface Adapters</h3>
                  <p><strong>Purpose:</strong> Convert data formats</p>
                  <p><strong>Contains:</strong> Controllers, presenters, gateways</p>
                  <p><strong>Dependencies:</strong> On Use Cases layer</p>
                  <p class="mb-0"><strong>Change Frequency:</strong> Changes with interfaces</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-purple">
                <div class="card-body">
                  <h3>4Ô∏è‚É£ Frameworks & Drivers</h3>
                  <p><strong>Purpose:</strong> External tools and delivery mechanisms</p>
                  <p><strong>Contains:</strong> UI, DB, web frameworks, devices</p>
                  <p><strong>Dependencies:</strong> On Interface Adapters</p>
                  <p class="mb-0"><strong>Change Frequency:</strong> Changes with technology</p>
                </div>
              </div>
            </div>
          </div>

          <h2>The Dependency Rule</h2>
          <p>
            <strong>The most important rule:</strong> Dependencies only point inward. Nothing in an inner circle can know anything 
            about something in an outer circle. Specifically:
          </p>
          <ul>
            <li>Entities don't depend on Use Cases, Interface Adapters, or Frameworks</li>
            <li>Use Cases depend only on Entities</li>
            <li>Interface Adapters depend on Use Cases (but not on Frameworks)</li>
            <li>Frameworks depend on Interface Adapters</li>
          </ul>

          <div class="callout">
            <strong>Key Insight:</strong> When outer layers need to call inner layers, we use the Dependency Inversion Principle. 
            The inner layer defines an interface, and the outer layer implements it. This maintains the dependency direction 
            while allowing communication both ways.
          </div>

          <h2>Clean Architecture Flow</h2>
          <div class="mermaid">
sequenceDiagram
    participant User
    participant Controller
    participant UseCase
    participant Entity
    participant Gateway
    participant Database
    
    User->>Controller: HTTP Request
    Controller->>UseCase: Execute Use Case
    UseCase->>Gateway: Call Interface (Repository)
    Gateway->>Database: Query Data
    Database-->>Gateway: Return Data
    Gateway-->>UseCase: Domain Model
    UseCase->>Entity: Apply Business Rules
    Entity-->>UseCase: Updated Entity
    UseCase-->>Controller: Response DTO
    Controller-->>User: HTTP Response
    
    Note over UseCase: Business Logic<br/>Lives Here
    Note over Gateway: Implements<br/>Repository Interface<br/>defined by Use Case
          </div>

          <h2>Layer Responsibilities</h2>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th>Layer</th>
                <th>What It Contains</th>
                <th>What It Knows</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Entities</strong></td>
                <td>Business objects, domain models, enterprise rules</td>
                <td>Nothing else - pure business logic</td>
              </tr>
              <tr>
                <td><strong>Use Cases</strong></td>
                <td>Application logic, orchestration, use case interactors</td>
                <td>Only Entities</td>
              </tr>
              <tr>
                <td><strong>Interface Adapters</strong></td>
                <td>Controllers, presenters, view models, DTOs, repository interfaces</td>
                <td>Use Cases and Entities</td>
              </tr>
              <tr>
                <td><strong>Frameworks</strong></td>
                <td>Web frameworks, ORMs, UI components, external libraries</td>
                <td>Everything (outermost layer)</td>
              </tr>
            </tbody>
          </table>

          <h2>Benefits of Clean Architecture</h2>
          <ul>
            <li><strong>Independent of Frameworks:</strong> Business logic doesn't depend on frameworks like React or Spring</li>
            <li><strong>Testable:</strong> Business rules can be tested without UI, database, or external dependencies</li>
            <li><strong>Independent of UI:</strong> Swap UI without changing business logic (Web ‚Üí Mobile ‚Üí CLI)</li>
            <li><strong>Independent of Database:</strong> Change from SQL to NoSQL without affecting business rules</li>
            <li><strong>Independent of External Services:</strong> Business logic doesn't know about external APIs</li>
            <li><strong>Maintainable:</strong> Clear separation of concerns makes code easier to understand and modify</li>
            <li><strong>Flexible:</strong> Easy to adapt to new requirements or technology changes</li>
          </ul>

          <h2>Key Patterns in Clean Architecture</h2>
          <div class="row g-3 mb-4">
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-blue-sky">
                <div class="card-body">
                  <h4>Dependency Inversion</h4>
                  <p>Inner layers define interfaces, outer layers implement them. Use Cases define repository interfaces, Infrastructure implements them.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-green-light">
                <div class="card-body">
                  <h4>Data Transfer Objects (DTOs)</h4>
                  <p>Convert between layer-specific data structures. Controllers convert HTTP requests to DTOs for Use Cases.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-purple">
                <div class="card-body">
                  <h4>Repository Pattern</h4>
                  <p>Abstraction over data access. Use Case depends on repository interface, not implementation.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-orange">
                <div class="card-body">
                  <h4>Use Case Interactors</h4>
                  <p>Each use case is a class with single responsibility. Makes business logic explicit and testable.</p>
                </div>
              </div>
            </div>
          </div>

          <h2>Clean Architecture vs Other Patterns</h2>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th>Pattern</th>
                <th>Similarity to Clean Architecture</th>
                <th>Key Difference</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Hexagonal Architecture</strong></td>
                <td>Both use ports/adapters and dependency inversion</td>
                <td>Hexagonal focuses on ports/adapters; Clean has explicit layers</td>
              </tr>
              <tr>
                <td><strong>Onion Architecture</strong></td>
                <td>Both have concentric circles with domain at center</td>
                <td>Very similar; Onion emphasizes domain modeling more</td>
              </tr>
              <tr>
                <td><strong>Layered Architecture</strong></td>
                <td>Both use layers for separation</td>
                <td>Clean inverts dependencies; Layered has top-down dependencies</td>
              </tr>
              <tr>
                <td><strong>DDD</strong></td>
                <td>Both prioritize domain logic</td>
                <td>DDD is about domain modeling; Clean is architectural structure</td>
              </tr>
            </tbody>
          </table>

          <h2>Common Mistakes</h2>
          <ul>
            <li><strong>Leaking Dependencies:</strong> Allowing outer layer types (ORMs, DTOs) into inner layers</li>
            <li><strong>Bypassing Use Cases:</strong> Controllers directly accessing repositories</li>
            <li><strong>Anemic Domain Models:</strong> Entities with only getters/setters, no behavior</li>
            <li><strong>Too Many Layers:</strong> Over-engineering with excessive abstraction</li>
            <li><strong>Ignoring the Dependency Rule:</strong> Inner layers depending on outer layers</li>
            <li><strong>Framework in Domain:</strong> Using framework annotations in entities</li>
          </ul>

          <h2>Project Structure Example</h2>
          <pre style="background: #1e293b; color: #e2e8f0; padding: 1rem; border-radius: 0.5rem; overflow-x: auto;">
MyApp/
‚îú‚îÄ‚îÄ Domain/                    # Entities Layer
‚îÇ   ‚îú‚îÄ‚îÄ Entities/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Customer.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Order.cs
‚îÇ   ‚îî‚îÄ‚îÄ ValueObjects/
‚îÇ       ‚îî‚îÄ‚îÄ Money.cs
‚îÇ
‚îú‚îÄ‚îÄ Application/               # Use Cases Layer
‚îÇ   ‚îú‚îÄ‚îÄ UseCases/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CreateOrder/
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CreateOrderUseCase.cs
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CreateOrderRequest.cs
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ CreateOrderResponse.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ GetCustomer/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ GetCustomerUseCase.cs
‚îÇ   ‚îî‚îÄ‚îÄ Interfaces/
‚îÇ       ‚îî‚îÄ‚îÄ IOrderRepository.cs
‚îÇ
‚îú‚îÄ‚îÄ Infrastructure/            # Frameworks & Drivers
‚îÇ   ‚îú‚îÄ‚îÄ Persistence/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ AppDbContext.cs
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ OrderRepository.cs  # Implements IOrderRepository
‚îÇ   ‚îú‚îÄ‚îÄ ExternalServices/
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ PaymentGateway.cs
‚îÇ   ‚îî‚îÄ‚îÄ Configuration/
‚îÇ
‚îî‚îÄ‚îÄ Presentation/              # Interface Adapters
    ‚îú‚îÄ‚îÄ API/
    ‚îÇ   ‚îî‚îÄ‚îÄ Controllers/
    ‚îÇ       ‚îî‚îÄ‚îÄ OrderController.cs
    ‚îî‚îÄ‚îÄ ViewModels/
          </pre>

          <h2>When to Use Clean Architecture</h2>
          <div class="row g-3 mb-4">
            <div class="col-md-12">
              <div class="card border-0 shadow-sm bg-gradient-green-light">
                <div class="card-body">
                  <h3>‚úÖ Good Fit</h3>
                  <ul class="mb-0">
                    <li>Complex business logic that needs to be protected from external changes</li>
                    <li>Long-lived applications that will evolve over time</li>
                    <li>Systems requiring high testability</li>
                    <li>Multiple interfaces to the same core logic (Web, Mobile, CLI)</li>
                    <li>Teams that value maintainability and clean code</li>
                    <li>Enterprise applications with complex domains</li>
                  </ul>
                </div>
              </div>
            </div>
            <div class="col-md-12">
              <div class="card border-0 shadow-sm bg-gradient-red">
                <div class="card-body">
                  <h3>‚ùå Overkill For</h3>
                  <ul class="mb-0">
                    <li>Simple CRUD applications with minimal business logic</li>
                    <li>Short-term prototypes or proof-of-concepts</li>
                    <li>Very small applications (< 10 files)</li>
                    <li>Scripts and utilities</li>
                    <li>Teams unfamiliar with these patterns (steep learning curve)</li>
                  </ul>
                </div>
              </div>
            </div>
          </div>

          <div class="callout">
            <strong>üí° Key Takeaway:</strong> Clean Architecture prioritizes business logic independence through layered structure 
            with inward-pointing dependencies. Keep your domain pure - no frameworks, no databases, no external dependencies. Use 
            dependency inversion to maintain the dependency direction. Each layer has a clear responsibility and knows only about 
            inner layers. The architecture makes your system testable, maintainable, and adaptable to change. Start with the domain, 
            add use cases, then build adapters and frameworks around them. Remember: it's called "Clean" Architecture because it 
            keeps the core clean from external concerns.
          </div>
        </section>

        <!-- Hexagonal Architecture Section -->
        <section id="hexagonal" role="article">
          <h1>Hexagonal Architecture (Ports & Adapters)</h1>
          <span class="badge">hexagonal</span>
          <span class="badge">ports</span>
          <span class="badge">adapters</span>
          
          <h2>What is Hexagonal Architecture?</h2>
          <p>
            <strong>Hexagonal Architecture</strong>, also known as <strong>Ports and Adapters</strong>, was introduced by Alistair 
            Cockburn. The core idea is to isolate the application's business logic from external concerns (UI, database, external 
            services) by defining clear boundaries called <strong>ports</strong> and connecting to them through <strong>adapters</strong>.
          </p>
          <p>
            The "hexagon" shape is just a visual metaphor - it could be any polygon. The important aspect is that the application 
            is at the center and all external interactions happen through ports at the boundaries.
          </p>

          <h2>Hexagonal Architecture Diagram</h2>
          <div class="mermaid">
graph TB
    subgraph External[External World]
        UI[Web UI]
        Mobile[Mobile App]
        CLI[CLI]
        DB[Database]
        API[External API]
        Queue[Message Queue]
    end
    
    subgraph Adapters[Adapters Layer]
        WebAdapter[Web Adapter]
        MobileAdapter[Mobile Adapter]
        CLIAdapter[CLI Adapter]
        DBAdapter[DB Adapter]
        APIAdapter[API Adapter]
        QueueAdapter[Queue Adapter]
    end
    
    subgraph Core[Application Core - Business Logic]
        Ports[Ports<br/>Input/Output Interfaces]
        BusinessLogic[Business Logic]
        DomainModel[Domain Model]
        
        Ports --> BusinessLogic
        BusinessLogic --> DomainModel
    end
    
    UI --> WebAdapter
    Mobile --> MobileAdapter
    CLI --> CLIAdapter
    
    WebAdapter --> Ports
    MobileAdapter --> Ports
    CLIAdapter --> Ports
    
    Ports --> DBAdapter
    Ports --> APIAdapter
    Ports --> QueueAdapter
    
    DBAdapter --> DB
    APIAdapter --> API
    QueueAdapter --> Queue
    
    style Core fill:#3b82f6,stroke:#2563eb,stroke-width:4px,color:#fff
    style Adapters fill:#f59e0b,stroke:#d97706,stroke-width:2px
    style External fill:#8b5cf6,stroke:#7c3aed,stroke-width:2px
          </div>

          <h2>Ports and Adapters Explained</h2>
          <div class="row g-3 mb-4">
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-blue">
                <div class="card-body">
                  <h3>üîå Ports</h3>
                  <p><strong>Definition:</strong> Interfaces that define how the application communicates with the outside world</p>
                  <p><strong>Types:</strong></p>
                  <ul>
                    <li><strong>Primary (Driving):</strong> Application uses these (e.g., Repository interface)</li>
                    <li><strong>Secondary (Driven):</strong> External actors use these (e.g., REST API interface)</li>
                  </ul>
                  <p class="mb-0"><strong>Location:</strong> Defined in the core domain</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-green">
                <div class="card-body">
                  <h3>üîß Adapters</h3>
                  <p><strong>Definition:</strong> Implementations that connect external systems to ports</p>
                  <p><strong>Types:</strong></p>
                  <ul>
                    <li><strong>Primary (Driving):</strong> Initiate interactions (UI, REST controllers)</li>
                    <li><strong>Secondary (Driven):</strong> Invoked by application (DB repositories, external APIs)</li>
                  </ul>
                  <p class="mb-0"><strong>Location:</strong> Infrastructure/external layers</p>
                </div>
              </div>
            </div>
          </div>

          <h2>Primary vs Secondary Ports</h2>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th>Aspect</th>
                <th>Primary (Driving) Ports</th>
                <th>Secondary (Driven) Ports</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Direction</strong></td>
                <td>External ‚Üí Application</td>
                <td>Application ‚Üí External</td>
              </tr>
              <tr>
                <td><strong>Who Calls</strong></td>
                <td>External actors call application</td>
                <td>Application calls external systems</td>
              </tr>
              <tr>
                <td><strong>Interface Defined By</strong></td>
                <td>Application (use case interfaces)</td>
                <td>Application (repository interfaces)</td>
              </tr>
              <tr>
                <td><strong>Adapter Examples</strong></td>
                <td>REST Controller, GraphQL Resolver, CLI</td>
                <td>Database Repository, Email Service, Payment Gateway</td>
              </tr>
              <tr>
                <td><strong>Purpose</strong></td>
                <td>Expose application functionality</td>
                <td>Access external resources</td>
              </tr>
            </tbody>
          </table>

          <h2>Request Flow Example</h2>
          <div class="mermaid">
sequenceDiagram
    participant User
    participant WebAdapter
    participant Port
    participant UseCase
    participant RepoPort
    participant DBAdapter
    participant Database
    
    User->>WebAdapter: HTTP POST /orders
    WebAdapter->>Port: CreateOrder(command)
    Port->>UseCase: Execute
    UseCase->>RepoPort: SaveOrder(order)
    RepoPort->>DBAdapter: Persist
    DBAdapter->>Database: INSERT
    Database-->>DBAdapter: Success
    DBAdapter-->>RepoPort: Order saved
    RepoPort-->>UseCase: Order entity
    UseCase-->>Port: OrderCreated
    Port-->>WebAdapter: OrderDTO
    WebAdapter-->>User: 201 Created
    
    Note over Port: Primary Port<br/>(Driving)
    Note over RepoPort: Secondary Port<br/>(Driven)
          </div>

          <h2>Benefits of Hexagonal Architecture</h2>
          <ul>
            <li><strong>Technology Independence:</strong> Swap databases, UI frameworks, or APIs without changing business logic</li>
            <li><strong>Testability:</strong> Test business logic in isolation with mock adapters</li>
            <li><strong>Multiple Interfaces:</strong> Support Web, CLI, API, and desktop simultaneously</li>
            <li><strong>Parallel Development:</strong> Teams can work on adapters independently</li>
            <li><strong>Flexibility:</strong> Add new adapters without modifying core logic</li>
            <li><strong>Protection:</strong> Business logic protected from external technology changes</li>
          </ul>

          <h2>Implementation Guidelines</h2>
          
          <h3>1. Define Ports First</h3>
          <p>Start by defining interfaces based on business needs, not technology.</p>

          <h3>2. Keep Core Pure</h3>
          <p>No framework dependencies, no annotations (except language features), no infrastructure code in the core.</p>

          <h3>3. Dependency Direction</h3>
          <p>Always point dependencies toward the core. Adapters depend on ports, not vice versa.</p>

          <h3>4. One Adapter Per Technology</h3>
          <p>Create separate adapters for REST, GraphQL, CLI, PostgreSQL, MongoDB, etc.</p>

          <h2>Project Structure Example</h2>
          <pre style="background: #1e293b; color: #e2e8f0; padding: 1rem; border-radius: 0.5rem; overflow-x: auto;">
MyApp/
‚îú‚îÄ‚îÄ domain/                     # Core/Hexagon Center
‚îÇ   ‚îú‚îÄ‚îÄ model/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ Order.java
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ Customer.java
‚îÇ   ‚îú‚îÄ‚îÄ ports/
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ input/              # Primary Ports
‚îÇ   ‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ CreateOrderUseCase.java
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ GetOrderUseCase.java
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ output/             # Secondary Ports
‚îÇ   ‚îÇ       ‚îú‚îÄ‚îÄ OrderRepository.java
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ PaymentGateway.java
‚îÇ   ‚îî‚îÄ‚îÄ service/
‚îÇ       ‚îî‚îÄ‚îÄ OrderService.java   # Business Logic
‚îÇ
‚îú‚îÄ‚îÄ adapters/
‚îÇ   ‚îú‚îÄ‚îÄ input/                  # Primary Adapters
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ rest/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ OrderController.java
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ graphql/
‚îÇ   ‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ OrderResolver.java
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ cli/
‚îÇ   ‚îÇ       ‚îî‚îÄ‚îÄ OrderCLI.java
‚îÇ   ‚îî‚îÄ‚îÄ output/                 # Secondary Adapters
‚îÇ       ‚îú‚îÄ‚îÄ persistence/
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ PostgresOrderRepository.java
‚îÇ       ‚îú‚îÄ‚îÄ messaging/
‚îÇ       ‚îÇ   ‚îî‚îÄ‚îÄ RabbitMQAdapter.java
‚îÇ       ‚îî‚îÄ‚îÄ external/
‚îÇ           ‚îî‚îÄ‚îÄ StripePaymentAdapter.java
‚îÇ
‚îî‚îÄ‚îÄ config/                     # Wiring/Dependency Injection
    ‚îî‚îÄ‚îÄ ApplicationConfig.java
          </pre>

          <h2>Hexagonal vs Clean Architecture</h2>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th>Aspect</th>
                <th>Hexagonal Architecture</th>
                <th>Clean Architecture</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Visual Model</strong></td>
                <td>Hexagon with ports on edges</td>
                <td>Concentric circles with layers</td>
              </tr>
              <tr>
                <td><strong>Core Concept</strong></td>
                <td>Ports and Adapters</td>
                <td>Layered dependency inversion</td>
              </tr>
              <tr>
                <td><strong>Terminology</strong></td>
                <td>Ports, Adapters, Primary/Secondary</td>
                <td>Entities, Use Cases, Interfaces, Frameworks</td>
              </tr>
              <tr>
                <td><strong>Focus</strong></td>
                <td>Isolation through ports/adapters</td>
                <td>Explicit layer responsibilities</td>
              </tr>
              <tr>
                <td><strong>Similarity</strong></td>
                <td colspan="2">Both prioritize business logic isolation and dependency inversion</td>
              </tr>
            </tbody>
          </table>

          <h2>Common Patterns</h2>
          <div class="row g-3 mb-4">
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-blue-sky">
                <div class="card-body">
                  <h4>Repository Pattern</h4>
                  <p>Port defines data access interface, adapter implements it for specific database (PostgreSQL, MongoDB, etc.)</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-green-light">
                <div class="card-body">
                  <h4>Anti-Corruption Layer</h4>
                  <p>Adapter translates between external system's model and your domain model, preventing external concepts from "corrupting" the core.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-purple">
                <div class="card-body">
                  <h4>Facade Pattern</h4>
                  <p>Primary adapters provide simplified interfaces to complex use cases.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-orange">
                <div class="card-body">
                  <h4>Strategy Pattern</h4>
                  <p>Multiple adapter implementations for the same port (e.g., multiple payment gateways).</p>
                </div>
              </div>
            </div>
          </div>

          <h2>Testing Strategy</h2>
          <ul>
            <li><strong>Unit Tests:</strong> Test business logic with mock ports/adapters</li>
            <li><strong>Integration Tests:</strong> Test adapters with real external systems</li>
            <li><strong>Acceptance Tests:</strong> Test through primary adapters (API tests)</li>
            <li><strong>Contract Tests:</strong> Verify adapters implement ports correctly</li>
          </ul>

          <div class="callout">
            <strong>üí° Key Takeaway:</strong> Hexagonal Architecture isolates business logic through ports (interfaces) and adapters 
            (implementations). Primary ports/adapters handle incoming requests; secondary ports/adapters handle outgoing calls. The 
            core defines all ports - adapters are just pluggable implementations. This makes your system testable with mock adapters, 
            flexible to swap technologies, and able to support multiple interfaces simultaneously. Remember: the hexagon shape is 
            just a metaphor for "multiple ports" - the key is isolating the core through well-defined boundaries. Start with defining 
            ports based on business needs, then create adapters for specific technologies.
          </div>
        </section>

        <!-- Dependency Inversion Section -->
        <section id="dependency-inversion" role="article">
          <h1>Dependency Inversion Principle</h1>
          <span class="badge">dependency</span>
          <span class="badge">inversion</span>
          <span class="badge">solid</span>
          
          <h2>What is Dependency Inversion?</h2>
          <p>
            The <strong>Dependency Inversion Principle (DIP)</strong> is the "D" in SOLID principles. It states:
          </p>
          <div class="callout">
            <strong>1. High-level modules should not depend on low-level modules. Both should depend on abstractions.</strong><br/>
            <strong>2. Abstractions should not depend on details. Details should depend on abstractions.</strong>
          </div>
          <p>
            In simpler terms: Instead of your business logic depending on concrete implementations (database, email service), 
            it should depend on interfaces. The implementations depend on those same interfaces. This "inverts" the traditional 
            dependency direction.
          </p>

          <h2>Traditional Dependency vs Inverted Dependency</h2>
          <div class="mermaid">
graph TB
    subgraph Traditional[Traditional Dependencies - Bad]
        BL1[Business Logic] --> DB1[Database Implementation]
        BL1 --> Email1[Email Service Implementation]
        BL1 -.depends on<br/>concrete classes.-> BL1
    end
    
    subgraph Inverted[Inverted Dependencies - Good]
        BL2[Business Logic] --> IRepo[IRepository Interface]
        BL2 --> IEmail[IEmailService Interface]
        
        DBImpl[Database Implementation] -.implements.-> IRepo
        EmailImpl[Email Service] -.implements.-> IEmail
        
        BL2 -.depends on<br/>abstractions.-> BL2
    end
    
    style Traditional fill:#fecaca,stroke:#dc2626,stroke-width:2px
    style Inverted fill:#bbf7d0,stroke:#16a34a,stroke-width:2px
    style BL2 fill:#3b82f6,stroke:#2563eb,stroke-width:3px,color:#fff
          </div>

          <h2>Why Invert Dependencies?</h2>
          <div class="row g-3 mb-4">
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-blue">
                <div class="card-body">
                  <h3>üîì Loose Coupling</h3>
                  <p class="mb-0">Business logic doesn't know about concrete implementations. Change databases without touching business code.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-green">
                <div class="card-body">
                  <h3>üß™ Testability</h3>
                  <p class="mb-0">Inject mock implementations during testing. Test business logic without databases or external services.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-purple">
                <div class="card-body">
                  <h3>üîÑ Flexibility</h3>
                  <p class="mb-0">Swap implementations at runtime. Use SQL in production, in-memory in tests, NoSQL for analytics.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-orange">
                <div class="card-body">
                  <h3>üì¶ Reusability</h3>
                  <p class="mb-0">Business logic can be reused with different implementations across projects or contexts.</p>
                </div>
              </div>
            </div>
          </div>

          <h2>Implementation Techniques</h2>
          
          <h3>1. Interface Abstraction</h3>
          <p>Define interfaces for all external dependencies:</p>
          <pre style="background: #1e293b; color: #e2e8f0; padding: 1rem; border-radius: 0.5rem; overflow-x: auto;">
// Domain Layer - Interface defined here
public interface IOrderRepository {
    Order GetById(int id);
    void Save(Order order);
}

// Business Logic - Depends on interface
public class OrderService {
    private readonly IOrderRepository _repository;
    
    public OrderService(IOrderRepository repository) {
        _repository = repository;  // Injected
    }
    
    public void ProcessOrder(int orderId) {
        var order = _repository.GetById(orderId);
        // Business logic here...
        _repository.Save(order);
    }
}

// Infrastructure Layer - Implements interface
public class SqlOrderRepository : IOrderRepository {
    public Order GetById(int id) {
        // SQL implementation
    }
    
    public void Save(Order order) {
        // SQL implementation
    }
}
          </pre>

          <h3>2. Dependency Injection (DI)</h3>
          <p>Inject dependencies through constructor, property, or method injection:</p>
          <ul>
            <li><strong>Constructor Injection:</strong> Dependencies passed via constructor (preferred)</li>
            <li><strong>Property Injection:</strong> Dependencies set via properties</li>
            <li><strong>Method Injection:</strong> Dependencies passed to methods</li>
          </ul>

          <h3>3. IoC Containers</h3>
          <p>Use Inversion of Control containers to manage dependency creation and injection:</p>
          <ul>
            <li>.NET: Microsoft.Extensions.DependencyInjection, Autofac</li>
            <li>Java: Spring, Guice</li>
            <li>Node.js: InversifyJS, TypeDI</li>
            <li>Python: dependency-injector, injector</li>
          </ul>

          <h2>Dependency Flow</h2>
          <div class="mermaid">
sequenceDiagram
    participant Container as DI Container
    participant Controller
    participant Service as OrderService
    participant Repo as IOrderRepository
    participant Impl as SqlOrderRepository
    
    Container->>Impl: Create instance
    Container->>Service: Create with IOrderRepository
    Container->>Controller: Create with OrderService
    
    Controller->>Service: ProcessOrder(id)
    Service->>Repo: GetById(id)
    Note over Repo: Service knows<br/>interface only
    Repo->>Impl: Actual call goes to<br/>concrete implementation
    Impl-->>Repo: Order
    Repo-->>Service: Order
    Service->>Repo: Save(order)
    Repo->>Impl: Persist
    
    Note over Service: Business Logic<br/>Decoupled from<br/>Infrastructure
          </div>

          <h2>Benefits of Dependency Inversion</h2>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th>Benefit</th>
                <th>Description</th>
                <th>Example</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Testability</strong></td>
                <td>Easy to test with mocks</td>
                <td>Test OrderService with in-memory repository</td>
              </tr>
              <tr>
                <td><strong>Maintainability</strong></td>
                <td>Changes isolated to implementations</td>
                <td>Switch from MySQL to PostgreSQL without touching business logic</td>
              </tr>
              <tr>
                <td><strong>Flexibility</strong></td>
                <td>Multiple implementations possible</td>
                <td>Use different payment gateways per region</td>
              </tr>
              <tr>
                <td><strong>Parallel Development</strong></td>
                <td>Teams work independently</td>
                <td>Business logic team works with mocks while infrastructure team builds real implementation</td>
              </tr>
              <tr>
                <td><strong>Reusability</strong></td>
                <td>Core logic reusable</td>
                <td>Same business logic works with different databases</td>
              </tr>
            </tbody>
          </table>

          <h2>Common Patterns Using DIP</h2>
          <div class="row g-3 mb-4">
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-blue-sky">
                <div class="card-body">
                  <h4>Repository Pattern</h4>
                  <p>Abstraction over data access. Business logic depends on IRepository, not specific database implementation.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-green-light">
                <div class="card-body">
                  <h4>Strategy Pattern</h4>
                  <p>Different algorithms implementing same interface. Business logic chooses strategy without knowing implementation details.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-purple">
                <div class="card-body">
                  <h4>Factory Pattern</h4>
                  <p>Create objects through interfaces. Business logic requests objects without knowing how they're created.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-orange">
                <div class="card-body">
                  <h4>Adapter Pattern</h4>
                  <p>Adapt external systems to interfaces your code expects. Protects your code from external changes.</p>
                </div>
              </div>
            </div>
          </div>

          <h2>DIP in Different Architectures</h2>
          <ul>
            <li><strong>Clean Architecture:</strong> Use Cases depend on repository interfaces defined in Application layer, implemented in Infrastructure</li>
            <li><strong>Hexagonal Architecture:</strong> Core defines ports (interfaces), adapters implement them</li>
            <li><strong>Onion Architecture:</strong> Inner layers define interfaces, outer layers implement them</li>
            <li><strong>Microservices:</strong> Services depend on client interfaces, not direct HTTP calls</li>
          </ul>

          <h2>Best Practices</h2>
          <ul>
            <li><strong>Prefer Constructor Injection:</strong> Makes dependencies explicit and enables immutability</li>
            <li><strong>Interface Segregation:</strong> Keep interfaces focused and minimal (ISP - another SOLID principle)</li>
            <li><strong>Depend on Abstractions:</strong> Never inject concrete classes if you can avoid it</li>
            <li><strong>Define Interfaces in Core:</strong> Business logic layer owns the interfaces</li>
            <li><strong>Use DI Containers:</strong> Automate dependency wiring and lifecycle management</li>
            <li><strong>Avoid Service Locator:</strong> Anti-pattern that hides dependencies</li>
            <li><strong>Test with Mocks:</strong> Verify DIP by testing with mock implementations</li>
          </ul>

          <h2>Common Mistakes</h2>
          <ul>
            <li><strong>Interface in Wrong Layer:</strong> Putting IRepository in infrastructure instead of domain</li>
            <li><strong>Too Many Interfaces:</strong> Creating interfaces for everything, even when not needed</li>
            <li><strong>Leaky Abstractions:</strong> Interface exposing implementation details</li>
            <li><strong>Service Locator:</strong> Using static methods to get dependencies instead of injection</li>
            <li><strong>Circular Dependencies:</strong> A depends on B, B depends on A</li>
            <li><strong>New Keyword Abuse:</strong> Creating dependencies directly instead of injecting them</li>
          </ul>

          <h2>Before and After Example</h2>
          <pre style="background: #1e293b; color: #e2e8f0; padding: 1rem; border-radius: 0.5rem; overflow-x: auto;">
// ‚ùå Before - Tight Coupling
public class OrderService {
    private SqlDatabase db = new SqlDatabase();  // Direct dependency
    
    public void ProcessOrder(int orderId) {
        var order = db.ExecuteQuery("SELECT * FROM Orders WHERE Id = " + orderId);
        // Business logic...
        db.ExecuteCommand("UPDATE Orders...");
    }
}

// ‚úÖ After - Dependency Inversion
public interface IOrderRepository {
    Order GetById(int id);
    void Update(Order order);
}

public class OrderService {
    private readonly IOrderRepository _repository;
    
    public OrderService(IOrderRepository repository) {
        _repository = repository;  // Injected dependency
    }
    
    public void ProcessOrder(int orderId) {
        var order = _repository.GetById(orderId);
        // Business logic...
        _repository.Update(order);
    }
}

// Implementation can be anything
public class SqlOrderRepository : IOrderRepository { /* ... */ }
public class MongoOrderRepository : IOrderRepository { /* ... */ }
public class InMemoryOrderRepository : IOrderRepository { /* ... */ }
          </pre>

          <div class="callout">
            <strong>üí° Key Takeaway:</strong> Dependency Inversion is fundamental to modern architecture patterns. High-level business 
            logic should depend on abstractions (interfaces), not concrete implementations. Define interfaces in your core/domain 
            layer, implement them in infrastructure/outer layers. This enables testability (inject mocks), flexibility (swap 
            implementations), and maintainability (change details without affecting business logic). Use constructor injection and 
            DI containers to wire dependencies. The "inversion" refers to reversing the traditional top-down dependency flow - 
            instead of business logic depending on infrastructure, both depend on abstractions defined by business needs. Master 
            this principle to build truly decoupled, testable, and maintainable systems.
          </div>
        </section>

        <!-- API Design Patterns Section -->
        <section id="api-design" role="article">
          <h1>üåê API Design Patterns</h1>
          <span class="badge">api</span>
          <span class="badge">rest</span>
          <span class="badge">design</span>
          
          <h2>What are API Design Patterns?</h2>
          <p>
            <strong>API Design Patterns</strong> are proven solutions to common challenges in designing application programming 
            interfaces (APIs). Good API design is critical for system integration, developer experience, and long-term maintainability. 
            These patterns help create APIs that are intuitive, consistent, secure, and scalable.
          </p>
          <p>
            APIs are the contracts between systems and services. Well-designed APIs reduce friction, enable interoperability, and 
            make systems easier to evolve. Poor API design leads to confusion, integration difficulties, and technical debt.
          </p>

          <h2>Types of APIs</h2>
          <div class="row g-3 mb-4">
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-blue">
                <div class="card-body">
                  <h3>üåç RESTful APIs</h3>
                  <p><strong>Style:</strong> Architectural style using HTTP</p>
                  <p><strong>Resources:</strong> Entities exposed via URLs</p>
                  <p><strong>Operations:</strong> HTTP methods (GET, POST, PUT, DELETE)</p>
                  <p class="mb-0"><strong>Best For:</strong> Web services, CRUD operations, public APIs</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-green">
                <div class="card-body">
                  <h3>üìä GraphQL</h3>
                  <p><strong>Style:</strong> Query language for APIs</p>
                  <p><strong>Resources:</strong> Graph of interconnected data</p>
                  <p><strong>Operations:</strong> Queries and mutations</p>
                  <p class="mb-0"><strong>Best For:</strong> Complex data fetching, mobile apps, flexible queries</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-purple">
                <div class="card-body">
                  <h3>‚ö° gRPC</h3>
                  <p><strong>Style:</strong> High-performance RPC framework</p>
                  <p><strong>Resources:</strong> Service definitions with methods</p>
                  <p><strong>Operations:</strong> Remote procedure calls</p>
                  <p class="mb-0"><strong>Best For:</strong> Microservices, low latency, internal APIs</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-orange">
                <div class="card-body">
                  <h3>üí¨ WebSocket</h3>
                  <p><strong>Style:</strong> Full-duplex communication</p>
                  <p><strong>Resources:</strong> Persistent connections</p>
                  <p><strong>Operations:</strong> Bidirectional messaging</p>
                  <p class="mb-0"><strong>Best For:</strong> Real-time apps, chat, live updates</p>
                </div>
              </div>
            </div>
          </div>

          <h2>API Architectural Styles Comparison</h2>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th>Aspect</th>
                <th>REST</th>
                <th>GraphQL</th>
                <th>gRPC</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Protocol</strong></td>
                <td>HTTP/HTTPS</td>
                <td>HTTP/HTTPS</td>
                <td>HTTP/2</td>
              </tr>
              <tr>
                <td><strong>Format</strong></td>
                <td>JSON, XML</td>
                <td>JSON</td>
                <td>Protocol Buffers (binary)</td>
              </tr>
              <tr>
                <td><strong>Data Fetching</strong></td>
                <td>Multiple endpoints, over/under-fetching</td>
                <td>Single endpoint, precise data fetching</td>
                <td>Service methods, streaming support</td>
              </tr>
              <tr>
                <td><strong>Type Safety</strong></td>
                <td>Schema optional (OpenAPI/Swagger)</td>
                <td>Strongly typed (schema required)</td>
                <td>Strongly typed (.proto files)</td>
              </tr>
              <tr>
                <td><strong>Performance</strong></td>
                <td>Good</td>
                <td>Good (reduces over-fetching)</td>
                <td>Excellent (binary, HTTP/2)</td>
              </tr>
              <tr>
                <td><strong>Browser Support</strong></td>
                <td>Excellent</td>
                <td>Excellent</td>
                <td>Limited (needs grpc-web)</td>
              </tr>
              <tr>
                <td><strong>Caching</strong></td>
                <td>Built-in HTTP caching</td>
                <td>Complex caching</td>
                <td>No built-in caching</td>
              </tr>
              <tr>
                <td><strong>Learning Curve</strong></td>
                <td>Low</td>
                <td>Medium</td>
                <td>Medium-High</td>
              </tr>
            </tbody>
          </table>

          <h2>Core API Design Principles</h2>
          
          <h3>1. Consistency</h3>
          <p>Use consistent naming, structure, error handling, and behavior across all endpoints.</p>

          <h3>2. Simplicity</h3>
          <p>Keep APIs simple and intuitive. Avoid unnecessary complexity in request/response structures.</p>

          <h3>3. Predictability</h3>
          <p>Follow conventions and standards. Developers should be able to predict API behavior.</p>

          <h3>4. Flexibility</h3>
          <p>Design for evolution. Use versioning, support optional fields, allow for backward compatibility.</p>

          <h3>5. Security</h3>
          <p>Implement authentication, authorization, rate limiting, and input validation from the start.</p>

          <h3>6. Documentation</h3>
          <p>Provide comprehensive, accurate, and up-to-date documentation with examples.</p>

          <h2>Common API Design Patterns</h2>
          <div class="row g-3 mb-4">
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-blue-sky">
                <div class="card-body">
                  <h4>Resource-Based URLs</h4>
                  <p>Use nouns for resources, not verbs. Let HTTP methods define actions.</p>
                  <p class="mb-0"><code>GET /users/123</code> not <code>GET /getUser?id=123</code></p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-green-light">
                <div class="card-body">
                  <h4>Pagination</h4>
                  <p>Limit response size for collections. Use cursor or offset-based pagination.</p>
                  <p class="mb-0"><code>GET /users?page=2&limit=20</code></p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-purple">
                <div class="card-body">
                  <h4>Filtering & Sorting</h4>
                  <p>Allow clients to filter and sort results via query parameters.</p>
                  <p class="mb-0"><code>GET /products?category=electronics&sort=price</code></p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-orange">
                <div class="card-body">
                  <h4>HATEOAS</h4>
                  <p>Include links to related resources in responses for discoverability.</p>
                  <p class="mb-0">Response includes <code>_links</code> with navigation URLs</p>
                </div>
              </div>
            </div>
          </div>

          <h2>API Security Patterns</h2>
          <ul>
            <li><strong>OAuth 2.0:</strong> Industry-standard authorization framework</li>
            <li><strong>API Keys:</strong> Simple authentication for service-to-service communication</li>
            <li><strong>JWT (JSON Web Tokens):</strong> Stateless authentication with claims</li>
            <li><strong>Rate Limiting:</strong> Prevent abuse with request limits per time window</li>
            <li><strong>API Gateway:</strong> Centralized authentication, authorization, and routing</li>
            <li><strong>CORS:</strong> Control cross-origin resource sharing</li>
            <li><strong>Input Validation:</strong> Validate and sanitize all inputs</li>
            <li><strong>HTTPS Only:</strong> Encrypt all API traffic</li>
          </ul>

          <h2>Error Handling Best Practices</h2>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th>HTTP Status</th>
                <th>Usage</th>
                <th>Example</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>200 OK</strong></td>
                <td>Successful GET, PUT, PATCH</td>
                <td>Resource retrieved/updated successfully</td>
              </tr>
              <tr>
                <td><strong>201 Created</strong></td>
                <td>Successful POST creating resource</td>
                <td>New user created</td>
              </tr>
              <tr>
                <td><strong>204 No Content</strong></td>
                <td>Successful DELETE</td>
                <td>Resource deleted successfully</td>
              </tr>
              <tr>
                <td><strong>400 Bad Request</strong></td>
                <td>Invalid request data</td>
                <td>Validation errors, malformed JSON</td>
              </tr>
              <tr>
                <td><strong>401 Unauthorized</strong></td>
                <td>Authentication required</td>
                <td>Missing or invalid credentials</td>
              </tr>
              <tr>
                <td><strong>403 Forbidden</strong></td>
                <td>Authenticated but not authorized</td>
                <td>Insufficient permissions</td>
              </tr>
              <tr>
                <td><strong>404 Not Found</strong></td>
                <td>Resource doesn't exist</td>
                <td>User ID not found</td>
              </tr>
              <tr>
                <td><strong>429 Too Many Requests</strong></td>
                <td>Rate limit exceeded</td>
                <td>API quota exceeded</td>
              </tr>
              <tr>
                <td><strong>500 Internal Server Error</strong></td>
                <td>Server-side error</td>
                <td>Unhandled exception</td>
              </tr>
            </tbody>
          </table>

          <h2>API Versioning Strategies</h2>
          <div class="row g-3 mb-4">
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-blue">
                <div class="card-body">
                  <h4>URI Versioning</h4>
                  <p><code>GET /api/v1/users</code></p>
                  <p><code>GET /api/v2/users</code></p>
                  <p class="mb-0"><strong>Pros:</strong> Clear, easy to understand<br/><strong>Cons:</strong> Clutters URLs</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-green">
                <div class="card-body">
                  <h4>Header Versioning</h4>
                  <p><code>GET /api/users</code></p>
                  <p><code>Accept: application/vnd.api+json;version=2</code></p>
                  <p class="mb-0"><strong>Pros:</strong> Clean URLs<br/><strong>Cons:</strong> Less discoverable</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-purple">
                <div class="card-body">
                  <h4>Query Parameter</h4>
                  <p><code>GET /api/users?version=2</code></p>
                  <p class="mb-0"><strong>Pros:</strong> Flexible<br/><strong>Cons:</strong> Can be ignored by clients</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-orange">
                <div class="card-body">
                  <h4>Content Negotiation</h4>
                  <p><code>Accept: application/vnd.company.v2+json</code></p>
                  <p class="mb-0"><strong>Pros:</strong> RESTful<br/><strong>Cons:</strong> Complex to implement</p>
                </div>
              </div>
            </div>
          </div>

          <h2>API Documentation Tools</h2>
          <ul>
            <li><strong>OpenAPI/Swagger:</strong> Industry standard for REST API documentation</li>
            <li><strong>Postman:</strong> API testing and documentation platform</li>
            <li><strong>GraphQL Playground:</strong> Interactive GraphQL IDE</li>
            <li><strong>Redoc:</strong> OpenAPI documentation renderer</li>
            <li><strong>API Blueprint:</strong> Markdown-based API documentation</li>
            <li><strong>Stoplight:</strong> API design and documentation platform</li>
          </ul>

          <div class="callout">
            <strong>üí° Key Takeaway:</strong> Great API design balances consistency, simplicity, and flexibility. Choose the right 
            API style (REST, GraphQL, gRPC) based on your use case. Follow RESTful principles for public APIs, consider GraphQL 
            for flexible data fetching, and use gRPC for high-performance internal communication. Always version your APIs, provide 
            comprehensive documentation, implement proper error handling, and secure your endpoints from day one. Good API design 
            is an investment in developer experience and long-term maintainability.
          </div>
        </section>

        <!-- RESTful APIs Section -->
        <section id="restful" role="article">
          <h1>RESTful APIs</h1>
          <span class="badge">rest</span>
          <span class="badge">http</span>
          <span class="badge">resources</span>
          
          <h2>What is REST?</h2>
          <p>
            <strong>REST (Representational State Transfer)</strong> is an architectural style for designing networked applications. 
            Introduced by Roy Fielding in 2000, REST uses HTTP methods to perform operations on resources identified by URLs. 
            RESTful APIs are stateless, cacheable, and leverage the existing HTTP infrastructure.
          </p>
          <p>
            REST is not a protocol or standard but a set of architectural constraints. An API that conforms to REST principles is 
            called "RESTful."
          </p>

          <h2>REST Architectural Constraints</h2>
          <div class="row g-3 mb-4">
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-blue">
                <div class="card-body">
                  <h3>1Ô∏è‚É£ Client-Server</h3>
                  <p class="mb-0">Separation of concerns - client handles UI, server handles data storage and business logic.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-green">
                <div class="card-body">
                  <h3>2Ô∏è‚É£ Stateless</h3>
                  <p class="mb-0">Each request contains all information needed. Server doesn't store client context between requests.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-purple">
                <div class="card-body">
                  <h3>3Ô∏è‚É£ Cacheable</h3>
                  <p class="mb-0">Responses must define themselves as cacheable or non-cacheable to improve performance.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-orange">
                <div class="card-body">
                  <h3>4Ô∏è‚É£ Uniform Interface</h3>
                  <p class="mb-0">Consistent interface between client and server simplifies architecture and improves visibility.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-yellow">
                <div class="card-body">
                  <h3>5Ô∏è‚É£ Layered System</h3>
                  <p class="mb-0">Client cannot tell if connected directly to server or through intermediary (load balancer, proxy).</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-red">
                <div class="card-body">
                  <h3>6Ô∏è‚É£ Code on Demand (Optional)</h3>
                  <p class="mb-0">Server can extend client functionality by transferring executable code (JavaScript).</p>
                </div>
              </div>
            </div>
          </div>

          <h2>HTTP Methods (Verbs)</h2>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th>Method</th>
                <th>Purpose</th>
                <th>Idempotent</th>
                <th>Safe</th>
                <th>Example</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>GET</strong></td>
                <td>Retrieve resource(s)</td>
                <td>‚úÖ Yes</td>
                <td>‚úÖ Yes</td>
                <td><code>GET /users/123</code></td>
              </tr>
              <tr>
                <td><strong>POST</strong></td>
                <td>Create new resource</td>
                <td>‚ùå No</td>
                <td>‚ùå No</td>
                <td><code>POST /users</code></td>
              </tr>
              <tr>
                <td><strong>PUT</strong></td>
                <td>Update/replace resource</td>
                <td>‚úÖ Yes</td>
                <td>‚ùå No</td>
                <td><code>PUT /users/123</code></td>
              </tr>
              <tr>
                <td><strong>PATCH</strong></td>
                <td>Partially update resource</td>
                <td>‚ùå No</td>
                <td>‚ùå No</td>
                <td><code>PATCH /users/123</code></td>
              </tr>
              <tr>
                <td><strong>DELETE</strong></td>
                <td>Remove resource</td>
                <td>‚úÖ Yes</td>
                <td>‚ùå No</td>
                <td><code>DELETE /users/123</code></td>
              </tr>
              <tr>
                <td><strong>HEAD</strong></td>
                <td>Get headers only</td>
                <td>‚úÖ Yes</td>
                <td>‚úÖ Yes</td>
                <td><code>HEAD /users/123</code></td>
              </tr>
              <tr>
                <td><strong>OPTIONS</strong></td>
                <td>Get supported methods</td>
                <td>‚úÖ Yes</td>
                <td>‚úÖ Yes</td>
                <td><code>OPTIONS /users</code></td>
              </tr>
            </tbody>
          </table>

          <h2>Resource Naming Conventions</h2>
          <ul>
            <li><strong>Use Nouns:</strong> <code>/users</code> not <code>/getUsers</code></li>
            <li><strong>Plural for Collections:</strong> <code>/users</code> not <code>/user</code></li>
            <li><strong>Hierarchical Structure:</strong> <code>/users/123/orders</code></li>
            <li><strong>Lowercase:</strong> <code>/product-categories</code> not <code>/ProductCategories</code></li>
            <li><strong>Hyphens for Readability:</strong> <code>/order-items</code> not <code>/orderitems</code></li>
            <li><strong>No Trailing Slash:</strong> <code>/users</code> not <code>/users/</code></li>
            <li><strong>Versioning:</strong> <code>/api/v1/users</code></li>
          </ul>

          <h2>RESTful URL Examples</h2>
          <pre style="background: #1e293b; color: #e2e8f0; padding: 1rem; border-radius: 0.5rem; overflow-x: auto;">
# Collection Operations
GET     /api/v1/users                  # Get all users
POST    /api/v1/users                  # Create new user
GET     /api/v1/users?role=admin       # Filter users by role
GET     /api/v1/users?page=2&limit=20  # Paginated users

# Single Resource Operations
GET     /api/v1/users/123              # Get user by ID
PUT     /api/v1/users/123              # Update entire user
PATCH   /api/v1/users/123              # Partially update user
DELETE  /api/v1/users/123              # Delete user

# Nested Resources
GET     /api/v1/users/123/orders       # Get user's orders
POST    /api/v1/users/123/orders       # Create order for user
GET     /api/v1/users/123/orders/456   # Get specific order

# Filtering, Sorting, Pagination
GET     /api/v1/products?category=electronics&sort=price&order=asc&page=1&limit=10
          </pre>

          <h2>Response Structure Best Practices</h2>
          <pre style="background: #1e293b; color: #e2e8f0; padding: 1rem; border-radius: 0.5rem; overflow-x: auto;">
{
  "data": {
    "id": "123",
    "name": "John Doe",
    "email": "john@example.com",
    "createdAt": "2026-01-06T10:30:00Z"
  },
  "metadata": {
    "timestamp": "2026-01-06T10:35:22Z",
    "version": "1.0"
  },
  "links": {
    "self": "/api/v1/users/123",
    "orders": "/api/v1/users/123/orders"
  }
}

// Collection Response
{
  "data": [ /* array of users */ ],
  "pagination": {
    "page": 1,
    "limit": 20,
    "total": 157,
    "pages": 8
  },
  "links": {
    "first": "/api/v1/users?page=1",
    "next": "/api/v1/users?page=2",
    "last": "/api/v1/users?page=8"
  }
}

// Error Response
{
  "error": {
    "code": "VALIDATION_ERROR",
    "message": "Invalid email format",
    "details": [
      { "field": "email", "issue": "must be valid email" }
    ]
  }
}
          </pre>

          <h2>HATEOAS (Hypermedia as the Engine of Application State)</h2>
          <p>
            Include links to related resources in API responses, making the API self-descriptive and discoverable.
          </p>
          <pre style="background: #1e293b; color: #e2e8f0; padding: 1rem; border-radius: 0.5rem; overflow-x: auto;">
{
  "id": "123",
  "status": "pending",
  "_links": {
    "self": { "href": "/orders/123" },
    "cancel": { "href": "/orders/123/cancel", "method": "POST" },
    "pay": { "href": "/orders/123/payment", "method": "POST" },
    "items": { "href": "/orders/123/items" }
  }
}
          </pre>

          <h2>REST API Best Practices</h2>
          <ul>
            <li><strong>Use HTTP Status Codes Correctly:</strong> 2xx for success, 4xx for client errors, 5xx for server errors</li>
            <li><strong>Support Content Negotiation:</strong> Accept JSON, XML via Accept header</li>
            <li><strong>Implement Pagination:</strong> Limit large result sets</li>
            <li><strong>Enable Filtering & Sorting:</strong> Allow clients to query specific data</li>
            <li><strong>Use ETags for Caching:</strong> Enable conditional requests</li>
            <li><strong>Support Compression:</strong> Use gzip encoding for large responses</li>
            <li><strong>Implement Rate Limiting:</strong> Protect API from abuse</li>
            <li><strong>Provide API Documentation:</strong> Use OpenAPI/Swagger</li>
            <li><strong>Version Your API:</strong> Allow evolution without breaking clients</li>
            <li><strong>Use HTTPS:</strong> Always encrypt API traffic</li>
          </ul>

          <h2>REST API Tools & Frameworks</h2>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th>Language/Platform</th>
                <th>Popular Frameworks</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Node.js</strong></td>
                <td>Express.js, Fastify, NestJS, Koa</td>
              </tr>
              <tr>
                <td><strong>.NET</strong></td>
                <td>ASP.NET Core Web API, Nancy</td>
              </tr>
              <tr>
                <td><strong>Java</strong></td>
                <td>Spring Boot, JAX-RS, Micronaut, Quarkus</td>
              </tr>
              <tr>
                <td><strong>Python</strong></td>
                <td>FastAPI, Flask-RESTful, Django REST Framework</td>
              </tr>
              <tr>
                <td><strong>Go</strong></td>
                <td>Gin, Echo, Fiber</td>
              </tr>
              <tr>
                <td><strong>Ruby</strong></td>
                <td>Ruby on Rails, Sinatra, Grape</td>
              </tr>
            </tbody>
          </table>

          <div class="callout">
            <strong>üí° Key Takeaway:</strong> RESTful APIs leverage HTTP's built-in features for creating intuitive, scalable web 
            services. Use nouns for resources, HTTP methods for actions, and proper status codes for responses. Keep APIs stateless, 
            cacheable, and self-descriptive with HATEOAS. Follow consistent naming conventions, implement pagination for collections, 
            and provide comprehensive documentation. REST's simplicity and HTTP compatibility make it the default choice for public 
            APIs and web services, though consider GraphQL or gRPC for specific use cases requiring more flexibility or performance.
          </div>
        </section>

        <!-- Best Practices Section -->
        <section id="best-practices" role="article">
          <h1>‚ú® Best Practices</h1>
          <span class="badge">guidelines</span>
          <span class="badge">tips</span>
          <span class="badge">patterns</span>
          
         
         
        </section>

        <!-- Resources Section -->
        <section id="resources" role="article">
          <h1>üìö Resources</h1>
          <span class="badge">docs</span>
          <span class="badge">community</span>
          <span class="badge">links</span>
          


          <hr />
          <div class="document-footer">
            <p>
              <strong>Last Updated:</strong> January 2026 | 
              <strong>Curated by:</strong> Murthy Vepa with ‚ù§Ô∏è | <strong>Powered by:</strong> GitHub Copilot
            </p>
          </div>
        </section>

       
        </div>
      </main>
    </div>
    
    <nav class="controls" role="navigation" aria-label="Pagination">
      <div class="btn-group" role="group">
        <button class="btn btn-outline-info btn-sm" id="prevBtn" title="Previous" aria-label="Previous concept">&nbsp;&lt;&nbsp;</button>
        <button class="btn btn-outline-info btn-sm" id="nextBtn" title="Next" aria-label="Next concept">&nbsp;&gt;&nbsp;</button>
      </div>
    </nav>
  </div>  <div class="offcanvas offcanvas-start" tabindex="-1" id="sidebarOffcanvas" aria-labelledby="sidebarLabel">
    <div class="offcanvas-header">
      <h5 class="offcanvas-title" id="sidebarLabel">Contents</h5>
      <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close"></button>
    </div>
    <div class="offcanvas-body p-0">
      <ul class="list-group list-group-flush w-100" id="tocMobile"></ul>
    </div>
  </div>

  <script>
    // ---- Mermaid Initialization ----
    document.addEventListener('DOMContentLoaded', () => {
      if (window.mermaid) {
        window.mermaid.contentLoaded();
      }
    });

    // ---- Configuration ----
    const sectionConfig = [
      { id: "overview", title: "üìñ Overview", tags: ["intro", "overview", "basics", "architecture"] },
      
      // Microservices Architecture
      { id: "microservices", title: "üî∑ Microservices Architecture", tags: ["microservices", "distributed", "scalability"] },
      { id: "service-decomposition", title: "Service Decomposition", tags: ["microservices", "decomposition", "design"] },
      { id: "api-gateway", title: "API Gateway Pattern", tags: ["microservices", "gateway", "routing"] },
      { id: "service-mesh", title: "Service Mesh", tags: ["microservices", "communication", "infrastructure"] },
      { id: "saga-pattern", title: "Saga Pattern", tags: ["microservices", "transactions", "distributed"] },
      
      // Domain-Driven Design
      { id: "ddd", title: "üéØ Domain-Driven Design (DDD)", tags: ["ddd", "domain", "design"] },
      { id: "bounded-context", title: "Bounded Contexts", tags: ["ddd", "context", "boundaries"] },
      { id: "aggregates", title: "Aggregates & Entities", tags: ["ddd", "aggregates", "entities"] },
      { id: "domain-events", title: "Domain Events", tags: ["ddd", "events", "communication"] },
      
      // Event-Driven Architecture
      { id: "event-driven", title: "‚ö° Event-Driven Architecture", tags: ["events", "messaging", "async"] },
      { id: "event-sourcing", title: "Event Sourcing", tags: ["events", "sourcing", "history"] },
      { id: "cqrs", title: "CQRS Pattern", tags: ["cqrs", "commands", "queries"] },
      { id: "message-driven", title: "Message-Driven Systems", tags: ["messaging", "async", "communication"] },
      
      // Clean & Hexagonal Architecture
      { id: "clean-architecture", title: "üèõÔ∏è Clean Architecture", tags: ["clean", "layered", "dependency"] },
      { id: "hexagonal", title: "Hexagonal Architecture", tags: ["hexagonal", "ports", "adapters"] },
      { id: "dependency-inversion", title: "Dependency Inversion", tags: ["dependency", "inversion", "solid"] },
      
      // API Design Patterns
      { id: "api-design", title: "üåê API Design Patterns", tags: ["api", "rest", "design"] },
      { id: "restful", title: "RESTful APIs", tags: ["rest", "http", "resources"] },
      { id: "graphql", title: "GraphQL", tags: ["graphql", "queries", "api"] },
      { id: "grpc", title: "gRPC", tags: ["grpc", "rpc", "protocol"] },
      { id: "bff-pattern", title: "Backend for Frontend (BFF)", tags: ["bff", "api", "frontend"] },
      { id: "api-versioning", title: "API Versioning", tags: ["versioning", "api", "evolution"] },
      
      // Traditional & Modern Structural Patterns
      { id: "traditional-patterns", title: "üèóÔ∏è Structural Patterns", tags: ["patterns", "traditional", "classic", "modern"] },
      { id: "layered", title: "Layered Architecture", tags: ["layered", "n-tier", "separation"] },
      { id: "vertical-slice", title: "Vertical Slice Architecture", tags: ["vertical", "slice", "feature"] },
      { id: "modular-monolith", title: "Modular Monolith", tags: ["monolith", "modular", "modules"] },
      { id: "mvc", title: "MVC Pattern", tags: ["mvc", "presentation", "pattern"] },
      { id: "mvvm", title: "MVVM Pattern", tags: ["mvvm", "binding", "ui"] },
      { id: "microkernel", title: "Microkernel Pattern", tags: ["microkernel", "plugins", "extensibility"] },
      
      // Cloud-Native Patterns
      { id: "cloud-native", title: "‚òÅÔ∏è Cloud-Native Patterns", tags: ["cloud", "serverless", "modern"] },
      { id: "serverless", title: "Serverless Architecture", tags: ["serverless", "faas", "lambda"] },
      
      // Additional Patterns
      { id: "security-patterns", title: "üîê Security Architecture", tags: ["security", "zero-trust", "defense"] },
      { id: "database-patterns", title: "üíæ Database Design Patterns", tags: ["database", "sharding", "replication"] },
      { id: "integration-patterns", title: "üîó Integration Patterns", tags: ["integration", "eip", "patterns"] },
      { id: "strangler-fig", title: "Strangler Fig Pattern", tags: ["migration", "modernization", "legacy"] },
      { id: "scalability-patterns", title: "üìà Scalability Patterns", tags: ["scalability", "performance", "caching"] },
      
      { id: "best-practices", title: "‚ú® Best Practices", tags: ["guidelines", "tips", "recommendations"] },
      { id: "resources", title: "üìö Resources", tags: ["docs", "community", "links"] }
    ];

    // ---- State & rendering ----
    const state = {
      index: 0,
      filtered: sectionConfig.map((_, i) => i), // indices
    };

    const els = {
      toc: document.getElementById('toc'),
      tocMobile: document.getElementById('tocMobile'),
      prev: document.getElementById('prevBtn'),
      next: document.getElementById('nextBtn'),
      toggleSidebar: document.getElementById('toggleSidebar'),
      themeToggle: document.getElementById('themeToggle'),
      main: document.getElementById('main'),
      sidebar: document.querySelector('nav.sidebar'),
      sidebarOffcanvas: document.getElementById('sidebarOffcanvas')
    };

    function buildTOC(){
      // Clear both TOC lists
      els.toc.innerHTML = '';
      els.tocMobile.innerHTML = '';
      
      state.filtered.forEach((idx) => {
        const s = sectionConfig[idx];
        
        // Check if this is a sub-item
        const isSubItem = [
          'service-decomposition', 'api-gateway', 'service-mesh', 'saga-pattern',
          'bounded-context', 'aggregates', 'domain-events',
          'event-sourcing', 'cqrs', 'message-driven',
          'hexagonal', 'dependency-inversion',
          'restful', 'graphql', 'grpc', 'bff-pattern', 'api-versioning',
          'layered', 'vertical-slice', 'modular-monolith', 'mvc', 'mvvm', 'microkernel',
          'serverless',
          'strangler-fig'
        ].includes(s.id);
        
        // Desktop sidebar
        const liDesktop = document.createElement('li');
        liDesktop.className = isSubItem ? 'list-group-sub-item' : 'list-group-item';
        const aDesktop = document.createElement('a');
        aDesktop.href = `#${s.id}`;
        aDesktop.textContent = s.title;
        aDesktop.addEventListener('click', (e) => {
          e.preventDefault();
          navigateToId(s.id);
          closeSidebar();
        });
        liDesktop.appendChild(aDesktop);
        els.toc.appendChild(liDesktop);
        
        // Mobile offcanvas
        const liMobile = document.createElement('li');
        liMobile.className = isSubItem ? 'list-group-sub-item' : 'list-group-item';
        const aMobile = document.createElement('a');
        aMobile.href = `#${s.id}`;
        aMobile.textContent = s.title;
        aMobile.addEventListener('click', (e) => {
          e.preventDefault();
          navigateToId(s.id);
          closeSidebar();
        });
        liMobile.appendChild(aMobile);
        els.tocMobile.appendChild(liMobile);
      });
      highlightActiveTOC();
    }

    function setActiveByIndex(i){
      const ids = state.filtered.map(idx => sectionConfig[idx].id);
      document.querySelectorAll('section').forEach(s => s.classList.remove('active'));
      const id = ids[i];
      const active = document.getElementById(id);
      if (active){
        active.classList.add('active');
        active.setAttribute('tabindex', '-1');
        active.focus({preventScroll:true});
      }
      updateControls();
      highlightActiveTOC();
      updateURLHash(id);
    }

    function updateControls(){
      const count = state.filtered.length;
      els.prev.disabled = state.index <= 0;
      els.next.disabled = state.index >= count - 1;
    }

    function filterTOC(query){
      const q = query.trim().toLowerCase();
      state.filtered = sectionConfig
        .map((s, i) => ({s, i}))
        .filter(({s}) => s.title.toLowerCase().includes(q) || s.tags.some(t => t.toLowerCase().includes(q)))
        .map(({i}) => i);

      state.index = Math.min(state.index, Math.max(0, state.filtered.length - 1));
      buildTOC();
      setActiveByIndex(state.index);
    }

    function navigate(delta){
      const count = state.filtered.length;
      const nextIndex = Math.min(Math.max(state.index + delta, 0), count - 1);
      if (nextIndex !== state.index){
        state.index = nextIndex;
        setActiveByIndex(state.index);
        // Scroll content to top
        const contentEl = document.querySelector('.content');
        if (contentEl) contentEl.scrollTop = 0;
      }
    }

    function navigateToId(id){
      const idxInFiltered = state.filtered.findIndex(fi => sectionConfig[fi].id === id);
      if (idxInFiltered !== -1){
        state.index = idxInFiltered;
        setActiveByIndex(state.index);
        // Scroll content to top
        const contentEl = document.querySelector('.content');
        if (contentEl) contentEl.scrollTop = 0;
      } else {
        state.filtered = sectionConfig.map((_, i) => i);
        buildTOC();
        navigateToId(id);
      }
    }

    function updateURLHash(id){
      const url = new URL(window.location);
      url.hash = id;
      history.replaceState(null, '', url);
    }

    function highlightActiveTOC(){
      const ids = state.filtered.map(idx => sectionConfig[idx].id);
      const activeId = ids[state.index];
      // Highlight desktop sidebar
      els.toc.querySelectorAll('a').forEach(a => {
        const isActive = a.getAttribute('href') === `#${activeId}`;
        a.classList.toggle('active', isActive);
        // Also toggle active on parent li for sub-items
        if (a.parentElement.classList.contains('list-group-sub-item')) {
          a.parentElement.classList.toggle('active', isActive);
        }
      });
      // Highlight mobile offcanvas
      els.tocMobile.querySelectorAll('a').forEach(a => {
        const isActive = a.getAttribute('href') === `#${activeId}`;
        a.classList.toggle('active', isActive);
        // Also toggle active on parent li for sub-items
        if (a.parentElement.classList.contains('list-group-sub-item')) {
          a.parentElement.classList.toggle('active', isActive);
        }
      });
    }

    function openSidebar(){
      const offcanvas = new bootstrap.Offcanvas(document.getElementById('sidebarOffcanvas'));
      offcanvas.show();
    }
    function closeSidebar(){
      const offcanvasElement = document.getElementById('sidebarOffcanvas');
      const offcanvas = bootstrap.Offcanvas.getInstance(offcanvasElement);
      if(offcanvas) offcanvas.hide();
    }

    // ---- Events ----
    els.prev.addEventListener('click', () => navigate(-1));
    els.next.addEventListener('click', () => navigate(1));

    // Keyboard navigation
    window.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowLeft') navigate(-1);
      else if (e.key === 'ArrowRight') navigate(1);
      else if (e.key === 'Escape') closeSidebar();
    });

    // Deep linking on load/hash change
    window.addEventListener('hashchange', () => {
      const id = location.hash.replace('#','');
      if (id) navigateToId(id);
    });

    // Sidebar toggle (mobile)
    els.toggleSidebar.addEventListener('click', () => {
      openSidebar();
    });

    // Restore theme
    (function(){
      try {
        const saved = localStorage.getItem('concepts-theme');
        if (saved) { 
          document.documentElement.setAttribute('data-theme', saved);
          els.themeToggle.textContent = saved === 'light' ? 'üåó' : 'üåô';
        }
      } catch {}
    })();

    // Initial render
    buildTOC();
    
    // Navigate to hash if present, otherwise show first section
    const initialId = location.hash.replace('#','');
    if (initialId){ 
    navigateToId(initialId); 
    } else {
    setActiveByIndex(0);
    // Scroll content to top on initial load
    const contentEl = document.querySelector('.content');
    if (contentEl) contentEl.scrollTop = 0;
    }

  </script>
  <!-- Bootstrap JS -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>