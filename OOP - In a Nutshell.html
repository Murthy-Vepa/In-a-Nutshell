<!DOCTYPE html>
<html lang="en" data-theme="light">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Object Oriented Programming - In a Nutshell</title>
  <meta name="description" content="A comprehensive guide to Object Oriented Programming." />
  <!-- Bootstrap CSS -->
  <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/css/bootstrap.min.css" rel="stylesheet">
  <style>
    :root{
      --bg: #ffffff;
      --fg: #0f172a;
      --muted: #64748b;
      --accent: #3b82f6;
      --accent-light: #dbeafe;
      --border: #e2e8f0;
      --sidebar-bg: #ffffff;
      --sidebar-fg: #0f172a;
      --code-bg: linear-gradient(90deg, rgba(59, 130, 246, 0.08) 0%, rgba(59, 130, 246, 0.12) 100%);
      --focus: #10b981;
      --shadow-sm: 0 1px 3px rgba(0,0,0,0.08);
      --shadow-md: 0 4px 6px rgba(0,0,0,0.1), 0 2px 4px rgba(0,0,0,0.06);
      --shadow-lg: 0 10px 20px rgba(0,0,0,0.12), 0 6px 6px rgba(0,0,0,0.08);
      --gradient: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%);
    }
    
    /* Bootstrap Gradient Utility Classes */
    .bg-gradient-blue { background: linear-gradient(135deg, #dbeafe 0%, #bfdbfe 100%) !important; }
    .bg-gradient-green { background: linear-gradient(135deg, #dcfce7 0%, #bbf7d0 100%) !important; }
    .bg-gradient-yellow { background: linear-gradient(135deg, #fef3c7 0%, #fde68a 100%) !important; }
    .bg-gradient-pink { background: linear-gradient(135deg, #fce7f3 0%, #fbcfe8 100%) !important; }
    .bg-gradient-purple { background: linear-gradient(135deg, #e9d5ff 0%, #d8b4fe 100%) !important; }
    .bg-gradient-teal { background: linear-gradient(135deg, #ccfbf1 0%, #99f6e4 100%) !important; }
    .bg-gradient-blue-dark { background: linear-gradient(135deg, #3b82f6 0%, #2563eb 100%) !important; }
    .bg-gradient-gray { background: linear-gradient(135deg, #64748b 0%, #475569 100%) !important; }
    .bg-gradient-purple-dark { background: linear-gradient(135deg, #a855f7 0%, #9333ea 100%) !important; }
    .bg-gradient-teal-dark { background: linear-gradient(135deg, #14b8a6 0%, #0d9488 100%) !important; }
    .bg-gradient-green-dark { background: linear-gradient(135deg, #10b981 0%, #059669 100%) !important; }
    .bg-gradient-red { background: linear-gradient(135deg, #fee2e2 0%, #fecaca 100%) !important; }
    .bg-gradient-green-light { background: linear-gradient(135deg, #d1fae5 0%, #a7f3d0 100%) !important; }
    .bg-gradient-blue-sky { background: linear-gradient(135deg, #f0f9ff 0%, #e0f2fe 100%) !important; }
    .bg-gradient-red-dark { background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%) !important; }
    .bg-gradient-indigo { background: linear-gradient(135deg, #4f46e5 0%, #4338ca 100%) !important; }
    .bg-gradient-green-medium { background: linear-gradient(135deg, #10b981 0%, #059669 100%) !important; }
    .bg-gradient-orange { background: linear-gradient(135deg, #f97316 0%, #ea580c 100%) !important; }
    .bg-gradient-violet { background: linear-gradient(135deg, #8b5cf6 0%, #7c3aed 100%) !important; }
    .bg-gradient-lime { background: linear-gradient(135deg, #84cc16 0%, #65a30d 100%) !important; }
    .bg-gradient-sky { background: linear-gradient(135deg, #0284c7 0%, #0369a1 100%) !important; }
    
    /* Apply theme colors to Bootstrap elements */
    body { background-color: var(--bg); color: var(--fg); overflow: hidden; }
    .navbar { background-color: var(--fg) !important; border-bottom: none !important; box-shadow: var(--shadow-md) !important; }
    .navbar-brand { cursor: pointer; color: var(--bg) !important; font-weight: 600; letter-spacing: 0px; }
    .navbar-toggler-icon { 
      filter: invert(1);
      background-image: url("data:image/svg+xml,%3csvg xmlns='http://www.w3.org/2000/svg' viewBox='0 0 30 30'%3e%3cpath stroke='rgba%2896, 165, 250, 0.9%29' stroke-linecap='round' stroke-miterlimit='10' stroke-width='2' d='M4 7h22M4 15h22M4 23h22'/%3e%3c/svg%3e");
    }
    
    .btn-outline-secondary { border-color: var(--border) !important; color: var(--fg) !important; }
    .btn-outline-secondary:hover { background-color: var(--accent-light) !important; border-color: var(--accent) !important; color: var(--accent) !important; }
    
    /* Sidebar - Modern Design */
    nav.sidebar { 
      background: linear-gradient(180deg, #f3f4f6 0%, #e5e7eb 100%); 
      border-right: 1px solid rgba(0, 0, 0, 0.05) !important;  
      overflow-y: auto; 
      box-shadow: 4px 0 16px rgba(0, 0, 0, 0.06);
      padding-top: 0;
    }
    
    .menu-header {  
      background: linear-gradient(135deg, rgba(0, 0, 0, 0.15), rgba(0, 0, 0, 0.1) 100%);
      font-weight: bold; 
      padding: 1.25rem 1.25rem; 
      letter-spacing: 0px; 
      font-size: 1.1rem;
      position: relative;
      overflow: hidden;
      border: none;
      border-bottom: 2px solid #a5aab3;
      box-shadow: 0 2px 6px rgba(0, 0, 0, 0.12);
      color: #0c346c;
      text-shadow: none;
      margin: 0;
      text-transform: none;
    }
    .menu-header::before {
      content: '';
      position: absolute;
      top: 0;
      left: -100%;
      width: 100%;
      height: 100%;
      background: linear-gradient(90deg, transparent, rgba(255, 255, 255, 0.15), transparent);
      transition: left 0.6s ease;
    }
    .menu-header:hover::before {
      left: 100%;
    }
    .menu-header::after {
      content: 'üìã';
      position: absolute;
      right: 1.5rem;
      top: 50%;
      transform: translateY(-50%);
      font-size: 1.3rem;
      opacity: 0.9;
      filter: drop-shadow(0 1px 2px rgba(0, 0, 0, 0.2));
    }
    
    .toc { 
      list-style: none; 
      padding: 0rem 0; 
      margin: 0; 
      background: transparent;
    }
    .toc li { 
      margin: 0; 
    }
    
    /* Section grouping */
    .toc li[data-group="overview"] { margin-bottom: 0.75rem; }
    .toc li[data-group="solid"]:first-of-type { 
      margin-top: 1rem; 
      border-top: 2px solid rgba(59, 130, 246, 0.15);
      padding-top: 1rem;
    }
    .toc li[data-group="other-principles"]:first-of-type { 
      margin-top: 1rem; 
      border-top: 2px solid rgba(16, 185, 129, 0.15);
      padding-top: 1rem;
    }
    .toc li[data-group="resources"] { 
      margin-top: 1rem; 
      border-top: 2px solid rgba(100, 116, 139, 0.15);
      padding-top: 1rem;
    }
    
    .list-group-item { 
      background: transparent; 
      border-color: transparent; 
      padding: 0; 
      margin: 0.25rem 0.75rem; 
      border-radius: 0rem;
      transition: all 0.2s ease;
    }
    .list-group-item a { 
      color: #1f2937; 
      text-decoration: none; 
      display: flex; 
      flex-direction: column; 
      align-items: flex-start; 
      gap: 0.4rem; 
      border-left: 3px solid transparent; 
      padding: 0.85rem 1.25rem; 
      transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1); 
      font-weight: 500; 
      border-radius: 0rem;
      font-size: 0.95rem;
      position: relative;
      overflow: hidden;
      background: linear-gradient(90deg, rgba(255, 255, 255, 0.4) 0%, rgba(255, 255, 255, 0.1) 100%);
      border: 1px solid rgba(0, 0, 0, 0.06);
      -webkit-backdrop-filter: blur(10px);
      backdrop-filter: blur(10px);
      box-shadow: 0 1px 3px rgba(0, 0, 0, 0.05);
    }
    .list-group-item a::before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      width: 4px;
      background: linear-gradient(180deg, #3b82f6 0%, #2563eb 100%);
      transform: scaleY(0);
      transition: transform 0.3s ease;
      border-radius: 0 0px 0px 0;
    }
    .list-group-item a::after {
      content: '‚ñ∂';
      position: absolute;
      right: 1rem;
      top: 50%;
      transform: translateY(-50%) scale(0.7);
      font-size: 0.7rem;
      color: #9ca3af;
      opacity: 0;
      transition: all 0.3s ease;
    }
    .list-group-item a:hover { 
      background: linear-gradient(90deg, rgba(59, 130, 246, 0.15) 0%, rgba(59, 130, 246, 0.08) 100%); 
      border-left-color: transparent;
      color: #1e40af;
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.2), 0 2px 4px rgba(0, 0, 0, 0.08);
      border-color: rgba(59, 130, 246, 0.2);
      text-decoration: none;
    }
    .list-group-item a:hover::before {
      transform: scaleY(1);
    }
    .list-group-item a:hover::after {
      opacity: 1;
      transform: translateY(-50%) scale(1);
      color: #3b82f6;
    }
    .list-group-item a.active { 
      background: linear-gradient(90deg, rgba(59, 130, 246, 0.22) 0%, rgba(59, 130, 246, 0.12) 100%); 
      color: #1e40af; 
      font-weight: 600; 
      border-left-color: transparent;
      box-shadow: 0 4px 16px rgba(59, 130, 246, 0.25), inset 0 1px 0 rgba(255, 255, 255, 0.3);
      border-color: rgba(59, 130, 246, 0.3);
    }
    .list-group-item a.active::before {
      transform: scaleY(1);
      background: linear-gradient(180deg, #3b82f6 0%, #2563eb 100%);
      width: 5px;
      box-shadow: 0 0 8px rgba(59, 130, 246, 0.5);
    }
    .list-group-item a.active::after {
      opacity: 1;
      color: #2563eb;
      transform: translateY(-50%) scale(1);
    }
    .list-group-item a.active:hover { 
      background: linear-gradient(90deg, rgba(59, 130, 246, 0.28) 0%, rgba(59, 130, 246, 0.16) 100%); 
      box-shadow: 0 6px 20px rgba(59, 130, 246, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.4);
    }
    
    /* Sub-items tree connectors */
    .list-group-sub-item a::before { 
      content: '‚îú‚îÄ';
      font-size: 0.85rem;
      margin-right: 0.5rem;
      color: #6b7280;
      z-index: 1;
      position: relative;
    }
    
    /* Sub-items styling - similar to main items but smaller and indented */
    .list-group-sub-item {
      background: transparent; 
      border-color: transparent; 
      padding: 0px; 
      margin: 0.2rem 0.75rem 0.2rem 1.5rem;
      border-radius: 0rem;
      transition: all 0.2s ease;
      position: relative;
      list-style-type: none;
    }
    .list-group-sub-item::before {
      content: '';
      position: absolute;
      left: 0;
      top: 0;
      height: 100%;
      width: 4px;
      background: linear-gradient(180deg, #3b82f6 0%, #2563eb 100%);
      transform: scaleY(0);
      transition: transform 0.3s ease;
      border-radius: 0 0px 0px 0;
      z-index: 1;
    }
    .list-group-sub-item a {
      color: #1f2937; 
      text-decoration: none; 
      display: block;
      border-left: 3px solid transparent; 
      padding: 0.65rem 1rem 0.65rem 2.00rem;
      transition: all 0.2s ease; 
      font-weight: 500; 
      border-radius: 0rem;
      font-size: 0.8125rem;
      line-height: 1.4;
      position: relative;
      overflow: hidden;
      background: rgba(255, 255, 255, 0.5);
      border: 1px solid rgba(0, 0, 0, 0.04);
      box-shadow: 0 1px 2px rgba(0, 0, 0, 0.04);
    }
    
    /* Sub-items hover and active states - same as main items */
    .list-group-sub-item a::after {
      content: '‚ñ∂';
      position: absolute;
      right: 1rem;
      top: 50%;
      transform: translateY(-50%) scale(0.7);
      font-size: 0.7rem;
      color: #9ca3af;
      opacity: 0;
      transition: all 0.3s ease;
    }
    
    .list-group-sub-item:hover::before {
      transform: scaleY(1);
    }
    .list-group-sub-item a:hover { 
      background: linear-gradient(90deg, rgba(59, 130, 246, 0.15) 0%, rgba(59, 130, 246, 0.08) 100%); 
      border-left-color: transparent;
      color: #1e40af;
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.2), 0 2px 4px rgba(0, 0, 0, 0.08);
      border-color: rgba(59, 130, 246, 0.2);
      text-decoration: none;
    }
    .list-group-sub-item a:hover::after {
      opacity: 1;
      transform: translateY(-50%) scale(1);
      color: #3b82f6;
    }
    
    .list-group-sub-item.active::before {
      transform: scaleY(1);
      width: 5px;
      box-shadow: 0 0 8px rgba(59, 130, 246, 0.5);
    }
    .list-group-sub-item a.active { 
      background: linear-gradient(90deg, rgba(59, 130, 246, 0.22) 0%, rgba(59, 130, 246, 0.12) 100%); 
      color: #1e40af; 
      font-weight: 600; 
      border-left-color: transparent;
      box-shadow: 0 4px 16px rgba(59, 130, 246, 0.25), inset 0 1px 0 rgba(255, 255, 255, 0.3);
      border-color: rgba(59, 130, 246, 0.3);
    }
    .list-group-sub-item a.active::after {
      opacity: 1;
      color: #2563eb;
      transform: translateY(-50%) scale(1);
    }
    .list-group-sub-item a.active:hover { 
      background: linear-gradient(90deg, rgba(59, 130, 246, 0.28) 0%, rgba(59, 130, 246, 0.16) 100%); 
      box-shadow: 0 6px 20px rgba(59, 130, 246, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.4);
    }
    
    .list-group-item a::after {
      content: '‚ñ∂';
      position: absolute;
      right: 1rem;
      top: 50%;
      transform: translateY(-50%) scale(0.7);
      font-size: 0.7rem;
      color: #9ca3af;
      opacity: 0;
      transition: all 0.3s ease;
    }
    
    .list-group-item a:hover { 
      background: linear-gradient(90deg, rgba(59, 130, 246, 0.15) 0%, rgba(59, 130, 246, 0.08) 100%); 
      border-left-color: transparent;
      color: #1e40af;
      box-shadow: 0 4px 12px rgba(59, 130, 246, 0.2), 0 2px 4px rgba(0, 0, 0, 0.08);
      border-color: rgba(59, 130, 246, 0.2);
      text-decoration: none;
    }
    .list-group-item a:hover::before {
      transform: scaleY(1);
    }
    .list-group-item a:hover::after {
      opacity: 1;
      transform: translateY(-50%) scale(1);
      color: #3b82f6;
    }
    .list-group-item a.active { 
      background: linear-gradient(90deg, rgba(59, 130, 246, 0.22) 0%, rgba(59, 130, 246, 0.12) 100%); 
      color: #1e40af; 
      font-weight: 600; 
      border-left-color: transparent;
      box-shadow: 0 4px 16px rgba(59, 130, 246, 0.25), inset 0 1px 0 rgba(255, 255, 255, 0.3);
      border-color: rgba(59, 130, 246, 0.3);
    }
    .list-group-item a.active::after {
      opacity: 1;
      color: #2563eb;
      transform: translateY(-50%) scale(1);
    }
    .list-group-item a.active:hover { 
      background: linear-gradient(90deg, rgba(59, 130, 246, 0.28) 0%, rgba(59, 130, 246, 0.16) 100%); 
      box-shadow: 0 6px 20px rgba(59, 130, 246, 0.3), inset 0 1px 0 rgba(255, 255, 255, 0.4);
    }
    
    /* Badge styling */
    .badge { font-size: 0.8rem; padding: 0.15rem 0.4rem; background: var(--accent-light); color: var(--accent); border: 1px solid var(--accent); font-weight: 600; border-radius: 0.25rem; font-style: normal; line-height: 1.2; opacity: 0.9; }
    .badge { background: var(--accent); color: white; border: none; font-size: 0.6rem; padding: 0.25rem 0.5rem; font-weight: 600; text-transform: uppercase; letter-spacing: 0.5px; display: inline-block; margin-top: 0.5rem; margin-right: 0.35rem; }
    .list-group-item a:hover .badge { opacity: 1; background: var(--accent); color: white; }
    .list-group-item a.active .badge { background: rgba(255, 255, 255, 0.3); color: white; border-color: rgba(255, 255, 255, 0.6); font-weight: 600; opacity: 1; }
        
    /* Content */
    .content { width: 100%; max-width: 100%; margin: 0 auto; background: #ffffff; padding: 2rem; border-radius: 0.75rem; box-shadow: 0 4px 20px rgba(0, 0, 0, 0.08); }
    section { display: none !important; margin-bottom: 2rem; }
    section.active { display: block !important; }
    @keyframes fadeIn { from { opacity: 0; } to { opacity: 1; } }
    
    h1 { font-size: 2rem; font-weight: 700; margin: 1rem 0 0.25rem 0; letter-spacing: -0.5px; color: var(--fg); display: block; border: none; }
    h2 { font-size: 1.5rem; font-weight: 600; margin: 1.5rem 0 0.75rem 0; color: var(--fg); border-bottom: 2px solid var(--accent-light); padding-bottom: 0.5rem; }
    h3 { font-size: 1.1rem; color: var(--accent); font-weight: 600; margin: 1rem 0 0.5rem 0; }
    h4 { font-size: 0.8rem; color: var(--fg); font-weight: 600; margin: 0.75rem 0 0.4rem 0; }
    p { margin: 1rem 0; line-height: 1.65; color: var(--fg); }
    ul, ol { margin: 1rem 0; padding-left: 2rem; }
    li { margin: 0.5rem 0; color: var(--fg); }
    
    code { background: var(--code-bg); border: 1px solid var(--border); padding: 0.2rem 0.5rem; font-family: ui-monospace, 'Cascadia Code', 'Source Code Pro', monospace; font-size: 0.9em; color: var(--accent); border-radius: 0.5rem; }
    pre { background: var(--code-bg); border: 0px solid var(--border); padding: 1rem; border-radius: 0.5rem; overflow: auto; box-shadow: var(--shadow-sm); margin: 1rem 0; }
    pre code { padding: 0; background: transparent; border: none; color: var(--fg); }
    
    .callout { border-left: 5px solid var(--accent); background: var(--accent-light); padding: 1rem 1.2rem; margin: 1.5rem 0; border-radius: 0.5rem; box-shadow: var(--shadow-sm); font-weight: 500; color: var(--fg); }
    
    /* Table styling */
    .table { color: var(--fg); }
    .table thead th { background: var(--accent-light); color: var(--accent); border-color: var(--border); font-weight: 600; }
    .table tbody td { border-color: var(--border); }
    .table-striped tbody tr:nth-of-type(odd) { background-color: rgba(0,0,0,0.02); }
    .table-striped tbody tr:hover { background-color: var(--accent-light); }
    
    /* Controls/Pagination */
    .controls { opacity: 0.5; position: fixed; bottom: 0.25rem; right: 1rem; width: auto; z-index: 1000; background: transparent; display: flex; align-items: center; justify-content: center; gap: 0rem; padding: 0; min-height: 40px; }
    @media (max-width: 991px) {
      .controls { bottom: 0.25rem; right: 1rem; }
      .menu-header { color: var(--focus); }
    }
    .controls:hover { opacity: 1; }
    
    .page-indicator { color: var(--accent); font-weight: 600; font-size: 0.875rem; }
    .btn-group .btn { margin: 0px 2px; padding: 0.2rem 0.5rem; background: var(--accent); color: white; border-color: var(--accent); font-size: 1rem; font-weight: bold; }
    .btn-group .btn:hover { background: var(--accent); }
    .btn-group .btn + .btn { margin-left: -1px; }
    
    /* Mobile/Offcanvas */
    .offcanvas { background: var(--bg) !important; }
    .offcanvas-header { border-bottom: 1px solid var(--border); }
    .offcanvas-title { color: var(--fg); font-weight: 600; }
    .btn-close { color: var(--fg); }
    
    /* Scrollbar */
    nav.sidebar::-webkit-scrollbar { width: 6px; }
    nav.sidebar::-webkit-scrollbar-track { background: rgba(0, 0, 0, 0.05); }
    nav.sidebar::-webkit-scrollbar-thumb { background: rgba(0, 0, 0, 0.2); border-radius: 0px; }
    nav.sidebar::-webkit-scrollbar-thumb:hover { background: rgba(0, 0, 0, 0.3); }
    
    /* Mermaid Diagrams */
    .mermaid {
      background: #ffffff;
      border: 1px solid #e2e8f0;
      border-radius: 0.5rem;
      padding: 2rem;
      margin: 1.5rem 0;
      min-height: 400px;
      display: flex;
      align-items: center;
      justify-content: center;
      overflow: visible;
      position: relative;
    }
    .mermaid.rendered {
      min-height: 0;
    }
    .mermaid svg {
      max-width: 100%;
      height: auto;
      min-height: 300px;
      transition: transform 0.3s ease;
      transform-origin: center center;
    }
    .mermaid.zoomed {
      overflow: auto;
      cursor: grab;
    }
    .mermaid.zoomed:active {
      cursor: grabbing;
    }
    .mermaid svg text {
      font-size: 14px !important;
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif !important;
    }
    
    /* Mermaid title styling */
    .mermaid svg text, .diagram-modal-content svg text {
      font-size: 1rem !important;
      font-weight: bold !important;
      fill: var(--fg) !important;
      font-family: 'Segoe UI', system-ui, -apple-system, sans-serif !important;
    }

    .mermaid svg *
    {
        color: #333;
    }

    .mermaid[data-processed="true"] {
      min-height: 0;
    }
    
    .mermaid svg {
      max-width: 100%;
      height: auto;
      display: inline-block;
    }
    
    /* Zoom controls */
    .zoom-controls {
      position: absolute;
      top: 10px;
      right: 10px;
      z-index: 10;
      opacity: 0.5;
      transition: opacity 0.3s ease;
    }
    .mermaid:hover .zoom-controls {
      opacity: 1;
    }
    .zoom-btn {
      background: var(--accent);
      color: white;
      border: none;
      border-radius: 0.25rem;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 16px;
      font-weight: bold;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      transition: all 0.2s ease;
    }
    .zoom-btn:hover {
      background: #2563eb;
      transform: scale(1.1);
    }

    /* Modal for diagram zoom */
    .diagram-modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: rgba(0, 0, 0, 0.95);
      z-index: 9999;
      align-items: center;
      justify-content: center;
      padding: 0;
    }
    .diagram-modal.active {
      display: flex;
    }
    .diagram-modal-content {
      position: relative;
      width: 100%;
      height: 100%;
      background: white;
      border-radius: 0;
      padding: 3rem 3rem 3rem 3rem;
      overflow: auto;
      display: flex;
      align-items: flex-start;
      justify-content: center;
    }
    .diagram-modal-content svg {
      max-width: 100%;
      height: auto;
    }
    .modal-close {
      position: fixed;
      top: 1.5rem;
      right: 1.5rem;
      background: #ef4444;
      color: white;
      border: none;
      border-radius: 50%;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 16px;
      font-weight: bold;
      box-shadow: 0 4px 8px rgba(0,0,0,0.3);
      transition: all 0.2s ease;
      z-index: 10000;
    }
    .modal-close:hover {
      background: #dc2626;
      transform: scale(1.1);
    }
    .modal-zoom-controls {
      position: fixed;
      bottom: 1.5rem;
      right: 1.5rem;
      display: flex;
      gap: 0.5rem;
      z-index: 10000;
      padding: 0rem;
      border-radius: 0.4rem;
    }
    .modal-zoom-btn {
      background: var(--accent);
      color: white;
      border: none;
      border-radius: 0.25rem;
      width: 32px;
      height: 32px;
      display: flex;
      align-items: center;
      justify-content: center;
      cursor: pointer;
      font-size: 16px;
      font-weight: bold;
      box-shadow: 0 2px 4px rgba(0,0,0,0.2);
      transition: all 0.2s ease;
    }
    .modal-zoom-btn:hover {
      background: #2563eb;
      transform: scale(1.1);
    }
    
    /* Utilities */
    .search { height: 0; overflow: hidden; padding: 0 !important; }
    .search input { display: none; }
    .min-vh-100 { min-height: 100vh; }
    .skip-link { position: absolute; left: -9999px; top: auto; width: 1px; height: 1px; overflow: hidden; }
    .skip-link:focus { position: static; width: auto; height: auto; padding: 0.4rem 0.6rem; background: var(--accent); color: white; border-radius: 0.4rem; }
    
    /* Override Bootstrap defaults for theme */
    a { color: var(--accent); }
    a:hover { color: var(--accent); text-decoration: underline; }
    
    /* Responsive - keep sidebar visible on desktop, offcanvas on mobile */
    @media (max-width: 991px) {
      nav.sidebar { display: none; }
      #main { width: 100%; }
      .row { --bs-gutter-x: 0; }
    }
    
    /* Layout - prevent unnecessary scrolling */
    html, body { height: 100%; margin: 0; }
    #appContainer { display: flex; flex-direction: column; height: calc(100vh - 50px); }
    #mainRow { flex: 1; overflow: hidden; display: flex; }
    nav.sidebar { overflow-y: auto; max-height: 100%; position: relative; padding-bottom: 0px; }
    #main { overflow: hidden; display: flex; flex-direction: column; height: 100%; -webkit-tap-highlight-color: transparent; outline: none; border: none; }
    #main:focus { outline: none; }
    .content { overflow-y: auto; flex: 1; width: 100%; min-height: 0; padding: 0rem 1.5rem 0rem 1.5rem; }
    
    /* Contact Info */
    .contact-info {
      font-weight: 400 !important;
      padding: 0.5rem 0.75rem;
      font-size: 0.75rem;
      color: var(--accent-light);
      margin: 0;
      opacity: 0.5;
      white-space: nowrap;
      cursor: pointer;
    }
    .contact-info:hover {
      opacity: 0.9;
      text-decoration: none;
    }
    @media (max-width: 991px) {
      .navbar-brand {
        font-size: 1rem !important;
        flex: 1;
      }
      .contact-info {
        font-size: 0.7rem;
        padding: 0.25rem 0.5rem;
      }
    }
    @media (max-width: 576px) {
      .navbar-brand {
        font-size: 0.9rem !important;
      }
      .contact-info {
        font-size: 0.65rem;
        padding: 0.2rem 0.4rem;
      }
    }

    .list-style-none {
      list-style: none;
      padding: 0;
      margin: 0;
    }

    /* JSON Syntax Highlighting */
    pre code.language-json {
      display: block;
      white-space: pre;
      font-family: 'Cascadia Code', 'Consolas', 'Monaco', 'Courier New', monospace;
    }

    pre code.language-json .json-key {
      color: #0451a5;
      font-weight: 500;
    }

    pre code.language-json .json-string {
      color: #a31515;
    }

    pre code.language-json .json-number {
      color: #098658;
    }

    pre code.language-json .json-boolean {
      color: #0000ff;
      font-weight: 600;
    }

    pre code.language-json .json-null {
      color: #0000ff;
      font-weight: 600;
    }

    pre code.language-json .json-punctuation {
      color: #333;
    }

    /* SQL Syntax Highlighting */
    pre code.language-sql {
      display: block;
      white-space: pre;
      font-family: 'Cascadia Code', 'Consolas', 'Monaco', 'Courier New', monospace;
    }

    pre code.language-sql .sql-keyword {
      color: #0000ff;
      font-weight: 600;
      text-transform: uppercase;
    }

    pre code.language-sql .sql-string {
      color: #a31515;
    }

    pre code.language-sql .sql-number {
      color: #098658;
    }

    pre code.language-sql .sql-comment {
      color: #008000;
      font-style: italic;
    }

    pre code.language-sql .sql-function {
      color: #795e26;
      font-weight: 500;
    }

    pre code.language-sql .sql-operator {
      color: #666;
      font-weight: 500;
    }

    /* Language Label for Code Blocks */
    pre[data-language]::before {
      content: attr(data-language);
      position: absolute;
      top: 8px;
      right: 12px;
      font-size: 0.75em;
      color: #6a737d;
      text-transform: uppercase;
      font-weight: 600;
      letter-spacing: 0.5px;
      background: var(--bg);
      padding: 0.2rem 0.5rem;
      border-radius: 0.25rem;
      border: 1px solid var(--border);
    }

    /* Enhanced pre/code styling for syntax highlighted blocks */
    pre.syntax-highlighted {
      position: relative;
      background: var(--code-bg);
      border: 1px solid var(--border);
      padding: 1.5rem 1rem 1rem 1rem;
      border-radius: 0.5rem;
      overflow-x: auto;
      box-shadow: var(--shadow-sm);
      margin: 1rem 0;
    }

    pre.syntax-highlighted code {
      background: transparent;
      padding: 0;
      border: none;
      color: var(--fg);
      font-size: 0.875rem;
      line-height: 1.6;
    }

    ul
    {
        list-style-type: none;
    }

    /* Code Tabs Styling */
    .code-tabs {
      margin: 1.5rem 0;
    }
    .code-tabs .nav-tabs {
      border-bottom: 2px solid var(--border);
      margin-bottom: 0;
    }
    .code-tabs .nav-link {
      color: var(--muted);
      border: none;
      border-bottom: 3px solid transparent;
      padding: 0.75rem 1.5rem;
      font-weight: 600;
      transition: all 0.3s ease;
      background: transparent;
    }
    .code-tabs .nav-link:hover {
      color: var(--accent);
      background: var(--accent-light);
      border-bottom-color: var(--accent);
    }
    .code-tabs .nav-link.active {
      color: var(--accent);
      background: var(--accent-light);
      border-bottom-color: var(--accent);
    }
    .code-tabs .tab-content {
      background: var(--code-bg);
      border: 1px solid var(--border);
      border-top: none;
      border-radius: 0 0 0.5rem 0.5rem;
      padding: 0;
    }
    .code-tabs .tab-pane {
      padding: 0;
    }
    .code-tabs pre {
      margin: 0;
      border: none;
      border-radius: 0 0 0.5rem 0.5rem;
    }

  /* Document Footer */
    .document-footer {
      text-align: center;
      padding: 20px;
      background-color: #f8f9fa;
      border-radius: 8px;
      margin-top: 20px;
    }
    .document-footer p {
      margin: 0;
      font-size: 14px;
      color: #6c757d;
      line-height: 1.6;
    }
    .document-footer strong {
      color: #495057;
    }  
  </style>
  <!-- Mermaid.js for diagrams -->
  <script src="https://cdn.jsdelivr.net/npm/mermaid@11/dist/mermaid.min.js"></script>
  <script>
    // Initialize Mermaid with proper configuration
    document.addEventListener('DOMContentLoaded', function() {

      mermaid.initialize({
        startOnLoad: false,
        theme: 'base',
        securityLevel: 'loose',
        logLevel: 'error',
        fontFamily: 'Segoe UI',
        flowchart: {
          useMaxWidth: true,
          htmlLabels: true,
          curve: 'basis',
        },
        sequence: {
          useMaxWidth: false,
          htmlLabels: true,
          diagramMarginX: 50,
          diagramMarginY: 10
        }
      });
      
      // Render all diagrams
      renderMermaidDiagrams();
    });
    
    async function renderMermaidDiagrams() {
      const diagrams = document.querySelectorAll('.mermaid');
      
      for (let i = 0; i < diagrams.length; i++) {
        const diagram = diagrams[i];
        const code = diagram.textContent.trim();
        
        // Store original code
        if (!diagram.hasAttribute('data-original-code')) {
          diagram.setAttribute('data-original-code', code);
        }
        
        try {
          const { svg } = await mermaid.render('mermaid-diagram-' + i, code);
          diagram.innerHTML = svg;
          diagram.setAttribute('data-processed', 'true');
          
          // Add zoom controls
          addZoomControls(diagram);
        } catch (error) {
          console.error('Mermaid rendering error for diagram ' + i + ':', error);
          diagram.innerHTML = '<div class="alert alert-danger border border-danger rounded p-3">Error rendering diagram: ' + error.message + '</div>';
        }
      }
    }
    
    // Add zoom controls to mermaid diagrams
    function addZoomControls(diagram) {
      const controls = document.createElement('div');
      controls.className = 'zoom-controls';
      controls.innerHTML = `
        <button class="zoom-btn" data-action="expand" title="Expand View">‚õ∂</button>
      `;
      
      diagram.style.position = 'relative';
      diagram.insertBefore(controls, diagram.firstChild);
      
      // Expand to modal
      controls.addEventListener('click', (e) => {
        const btn = e.target.closest('.zoom-btn');
        if (!btn) return;
        
        openDiagramModal(diagram);
      });
    }

    // Open diagram in modal
    function openDiagramModal(diagram) {
      // Create modal if it doesn't exist
      let modal = document.getElementById('diagram-modal');
      if (!modal) {
        modal = document.createElement('div');
        modal.id = 'diagram-modal';
        modal.className = 'diagram-modal';
        modal.innerHTML = `
          <button class="modal-close" id="modal-close">√ó</button>
          <div class="diagram-modal-content" id="modal-diagram-content"></div>
          <div class="modal-zoom-controls">
            <button class="modal-zoom-btn" data-action="zoom-in" title="Zoom In">+</button>
            <button class="modal-zoom-btn" data-action="zoom-out" title="Zoom Out">‚àí</button>
            <button class="modal-zoom-btn" data-action="reset" title="Reset Zoom">‚ü≤</button>
          </div>
        `;
        document.body.appendChild(modal);
        
        // Close modal handlers
        modal.querySelector('#modal-close').addEventListener('click', closeDiagramModal);
        modal.addEventListener('click', (e) => {
          if (e.target === modal) closeDiagramModal();
        });
        document.addEventListener('keydown', (e) => {
          if (e.key === 'Escape' && modal.classList.contains('active')) {
            closeDiagramModal();
          }
        });
        
        // Zoom controls in modal
        let scale = 1;
        let translateX = 0;
        let translateY = 0;
        
        modal.querySelector('.modal-zoom-controls').addEventListener('click', (e) => {
          const btn = e.target.closest('.modal-zoom-btn');
          if (!btn) return;
          
          const action = btn.dataset.action;
          const svg = modal.querySelector('svg');
          if (!svg) return;
          
          if (action === 'zoom-in') {
            scale = Math.min(scale + 0.1, 5);
          } else if (action === 'zoom-out') {
            scale = Math.max(scale - 0.1, 0.5);
          } else if (action === 'reset') {
            scale = 1;
            translateX = 0;
            translateY = 0;
          }
          
          svg.style.transform = `scale(${scale}) translate(${translateX / scale}px, ${translateY / scale}px)`;
        });
      }
      
      // Clone diagram content
      const svg = diagram.querySelector('svg');
      if (svg) {
        const content = modal.querySelector('#modal-diagram-content');
        content.innerHTML = '';
        const clonedSvg = svg.cloneNode(true);
        clonedSvg.style.transform = 'scale(1)';
        clonedSvg.style.maxWidth = '100%';
        clonedSvg.style.height = 'auto';
        content.appendChild(clonedSvg);
      }
      
      modal.classList.add('active');
      document.body.style.overflow = 'hidden';
    }

    function closeDiagramModal() {
      const modal = document.getElementById('diagram-modal');
      if (modal) {
        modal.classList.remove('active');
        document.body.style.overflow = '';
      }
    }
    
    // Re-render on theme change
    window.rerenderMermaid = async function() {
      const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
      
      mermaid.initialize({
        startOnLoad: false,
        theme: isDark ? 'base' : 'base',
        securityLevel: 'loose',
        flowchart: {
          useMaxWidth: true,
          htmlLabels: true,
          curve: 'basis',
        },
        sequence: {
          useMaxWidth: false,
          htmlLabels: true,
          diagramMarginX: 50,
          diagramMarginY: 10
        }
      });
      
      const diagrams = document.querySelectorAll('.mermaid[data-processed="true"]');
      for (let i = 0; i < diagrams.length; i++) {
        const diagram = diagrams[i];
        const code = diagram.getAttribute('data-original-code');
        
        if (code) {
          try {
            const { svg } = await mermaid.render('mermaid-diagram-rerender-' + i + '-' + Date.now(), code);
            diagram.innerHTML = svg;
          } catch (error) {
            console.error('Mermaid re-rendering error:', error);
          }
        }
      }
    };
  </script>
</head>
<body>
  <nav class="navbar navbar-expand-lg sticky-top" aria-label="Top bar">
    <div class="container-fluid d-flex align-items-center">
      <button class="navbar-toggler me-2" id="toggleSidebar" type="button" aria-label="Toggle sidebar">
        <span class="navbar-toggler-icon"></span>
      </button>
        <span class="navbar-brand mb-0 h1 me-auto">üß± Object Oriented Programming - In a Nutshell</span>
        <span class="contact-info mb-0">ü§ù Curated by Murthy Vepa</span>
    </div>      
  </nav>

  <div id="appContainer">
    <div class="row g-0" id="mainRow">
      <nav class="col-lg-3 border-end sidebar" id="sidebar" aria-label="Table of contents">
        <div class="menu-header py-2">Contents</div>
        <ul class="list-group list-group-flush toc" id="toc"></ul>
      </nav>

      <main id="main" class="col-lg-9 d-flex flex-column" tabindex="-1">
        <div class="content" id="content">
        <!-- Overview Section -->
        <section id="overview" role="article">
          <h1>üìñ Overview</h1>
          <span class="badge">intro</span>
          <span class="badge">overview</span>
          <span class="badge">basics</span>
          
          <h2>What is Object-Oriented Programming?</h2>
          <p>
            <strong>Object-Oriented Programming (OOP)</strong> is a programming paradigm based on the concept of <strong>"objects"</strong>, 
            which can contain data (attributes/properties) and code (methods/behaviors). OOP focuses on organizing software design 
            around objects rather than functions and logic.
          </p>

          <h2>Why OOP?</h2>
          <p>OOP provides several advantages that make it one of the most popular programming paradigms:</p>
          
          <div class="row g-3">
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-blue">
                <div class="card-body">
                  <h3>üîÑ Reusability</h3>
                  <p class="mb-0">Code can be reused through inheritance and composition, reducing redundancy and development time.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-green">
                <div class="card-body">
                  <h3>üõ°Ô∏è Modularity</h3>
                  <p class="mb-0">Objects are self-contained modules that can be developed, tested, and maintained independently.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-yellow">
                <div class="card-body">
                  <h3>üîß Maintainability</h3>
                  <p class="mb-0">Changes in one part of the system have minimal impact on other parts, making maintenance easier.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-pink">
                <div class="card-body">
                  <h3>üéØ Real-World Modeling</h3>
                  <p class="mb-0">Objects naturally model real-world entities, making code more intuitive and easier to understand.</p>
                </div>
              </div>
            </div>
          </div>

          <h2>Core Concepts</h2>
          <p>OOP is built on four fundamental pillars:</p>
          <ul>
            <li><strong>Encapsulation:</strong> Bundling data and methods that operate on that data within a single unit</li>
            <li><strong>Abstraction:</strong> Hiding complex implementation details and showing only essential features</li>
            <li><strong>Inheritance:</strong> Creating new classes based on existing classes to promote code reuse</li>
            <li><strong>Polymorphism:</strong> Allowing objects to take many forms and behave differently based on their type</li>
          </ul>

          <h2>OOP vs Procedural Programming</h2>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th>Aspect</th>
                <th>OOP</th>
                <th>Procedural</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Focus</td>
                <td>Objects and their interactions</td>
                <td>Functions and procedures</td>
              </tr>
              <tr>
                <td>Data Security</td>
                <td>High (encapsulation)</td>
                <td>Low (global data)</td>
              </tr>
              <tr>
                <td>Reusability</td>
                <td>High (inheritance, composition)</td>
                <td>Moderate (functions)</td>
              </tr>
              <tr>
                <td>Complexity</td>
                <td>Better for large, complex systems</td>
                <td>Better for simple, linear tasks</td>
              </tr>
              <tr>
                <td>Maintenance</td>
                <td>Easier to maintain and modify</td>
                <td>Harder as complexity grows</td>
              </tr>
            </tbody>
          </table>

          <div class="callout">
            <strong>üí° Key Takeaway:</strong> OOP is not just about using classes and objects‚Äîit's about organizing your code 
            in a way that models real-world problems, promotes reusability, and makes your codebase more maintainable and scalable.
          </div>
        </section>

        <!-- Four Pillars Section -->
        <section id="core-pillars" role="article">
          <h1>üèõÔ∏è Four Pillars of OOP</h1>
          <span class="badge">pillars</span>
          <span class="badge">fundamentals</span>
          <span class="badge">core</span>
          
          <h2>Introduction</h2>
          <p>
            Object-Oriented Programming is built on four fundamental pillars that work together to create robust, 
            maintainable, and scalable software systems. Understanding these pillars is essential for mastering OOP.
          </p>

          <div class="mermaid">
graph TD
    A[Object-Oriented Programming] --> B[Encapsulation]
    A --> C[Abstraction]
    A --> D[Inheritance]
    A --> E[Polymorphism]
    
    B --> B1[Data Hiding]
    B --> B2[Access Control]
    
    C --> C1[Interface]
    C --> C2[Implementation Hiding]
    
    D --> D1[Code Reuse]
    D --> D2[IS-A Relationship]
    
    E --> E1[Method Overloading]
    E --> E2[Method Overriding]
    
    style A fill:#3b82f6,stroke:#2563eb,stroke-width:3px,color:#fff
    style B fill:#10b981,stroke:#059669,stroke-width:2px,color:#fff
    style C fill:#8b5cf6,stroke:#7c3aed,stroke-width:2px,color:#fff
    style D fill:#f59e0b,stroke:#d97706,stroke-width:2px,color:#fff
    style E fill:#ec4899,stroke:#db2777,stroke-width:2px,color:#fff
          </div>

          <h2>The Four Pillars</h2>
          
          <div class="row g-3 mb-4">
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-green">
                <div class="card-body">
                  <h3>üîí Encapsulation</h3>
                  <p><strong>Definition:</strong> Bundling data and methods that operate on that data within a single unit (class).</p>
                  <p><strong>Purpose:</strong> Data hiding, controlled access, and maintaining object integrity.</p>
                  <p><strong>Mechanism:</strong> Access modifiers (private, public, protected, internal).</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-purple">
                <div class="card-body">
                  <h3>üé≠ Abstraction</h3>
                  <p><strong>Definition:</strong> Hiding complex implementation details and showing only essential features.</p>
                  <p><strong>Purpose:</strong> Reduce complexity, focus on what an object does rather than how.</p>
                  <p><strong>Mechanism:</strong> Abstract classes and interfaces.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-orange">
                <div class="card-body">
                  <h3>üß¨ Inheritance</h3>
                  <p><strong>Definition:</strong> Creating new classes based on existing classes to promote code reuse.</p>
                  <p><strong>Purpose:</strong> Code reusability, establishing hierarchical relationships.</p>
                  <p><strong>Mechanism:</strong> Base/parent class and derived/child class relationship.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-pink">
                <div class="card-body">
                  <h3>üé® Polymorphism</h3>
                  <p><strong>Definition:</strong> Allowing objects to take many forms and behave differently based on context.</p>
                  <p><strong>Purpose:</strong> Flexibility, extensibility, and dynamic behavior.</p>
                  <p><strong>Mechanism:</strong> Method overloading (compile-time) and overriding (runtime).</p>
                </div>
              </div>
            </div>
          </div>

          <div class="callout">
            <strong>üí° Key Insight:</strong> These four pillars don't work in isolation‚Äîthey complement each other. 
            Encapsulation protects data, Abstraction simplifies interfaces, Inheritance promotes reuse, and 
            Polymorphism provides flexibility. Together, they form the foundation of robust OOP design.
          </div>
        </section>

        <!-- Encapsulation Section -->
        <section id="encapsulation" role="article">
          <h1>üîí Encapsulation</h1>
          <span class="badge">pillar</span>
          <span class="badge">data-hiding</span>
          <span class="badge">access-modifiers</span>
          
          <h2>What is Encapsulation?</h2>
          <p>
            <strong>Encapsulation</strong> is the mechanism of bundling data (fields) and methods (functions) that operate on that data 
            within a single unit (class), and restricting direct access to some of the object's components. It's often described as 
            <strong>data hiding</strong>.
          </p>

          <h2>Why Encapsulation?</h2>
          <ul>
            <li><strong>Data Protection:</strong> Prevents unauthorized or accidental modification of data</li>
            <li><strong>Flexibility:</strong> Internal implementation can change without affecting external code</li>
            <li><strong>Maintainability:</strong> Changes are localized to the class</li>
            <li><strong>Control:</strong> Validation logic can be enforced when setting values</li>
          </ul>

          <h2>Encapsulation Examples</h2>
          
          <h3>‚ùå Bad Example (No Encapsulation)</h3>
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" id="encap-bad-csharp-tab" data-bs-toggle="tab" data-bs-target="#encap-bad-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" id="encap-bad-java-tab" data-bs-toggle="tab" data-bs-target="#encap-bad-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="encap-bad-csharp" role="tabpanel">
                <pre><code>public class BankAccount
{
    public decimal balance;  // Direct access - dangerous!
    public string accountNumber;
}

// Usage
var account = new BankAccount();
account.balance = -1000;  // Can set invalid values!
account.balance += 500;   // Direct manipulation without validation</code></pre>
              </div>
              <div class="tab-pane fade" id="encap-bad-java" role="tabpanel">
                <pre><code>public class BankAccount {
    public double balance;  // Direct access - dangerous!
    public String accountNumber;
}

// Usage
BankAccount account = new BankAccount();
account.balance = -1000;  // Can set invalid values!
account.balance += 500;   // Direct manipulation without validation</code></pre>
              </div>
            </div>
          </div>

          <h3>‚úÖ Good Example (With Encapsulation)</h3>
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" id="encap-good-csharp-tab" data-bs-toggle="tab" data-bs-target="#encap-good-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" id="encap-good-java-tab" data-bs-toggle="tab" data-bs-target="#encap-good-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="encap-good-csharp" role="tabpanel">
                <pre><code>public class BankAccount
{
    // Private fields (encapsulated data)
    private decimal balance;
    private string accountNumber;
    
    // Public properties with controlled access
    public decimal Balance
    {
        get { return balance; }
        private set { balance = value; }  // Only class can modify
    }
    
    public string AccountNumber
    {
        get { return accountNumber; }
    }
    
    // Constructor
    public BankAccount(string accountNumber, decimal initialBalance)
    {
        this.accountNumber = accountNumber;
        if (initialBalance < 0)
            throw new ArgumentException("Initial balance cannot be negative");
        this.balance = initialBalance;
    }
    
    // Controlled methods to modify data
    public void Deposit(decimal amount)
    {
        if (amount <= 0)
            throw new ArgumentException("Deposit amount must be positive");
        balance += amount;
    }
    
    public void Withdraw(decimal amount)
    {
        if (amount <= 0)
            throw new ArgumentException("Withdrawal amount must be positive");
        if (amount > balance)
            throw new InvalidOperationException("Insufficient funds");
        balance -= amount;
    }
}

// Usage
var account = new BankAccount("ACC001", 1000);
account.Deposit(500);      // ‚úÖ Controlled access with validation
account.Withdraw(200);     // ‚úÖ Controlled access with validation
// account.balance = -1000; // ‚ùå Compilation error - field is private!</code></pre>
              </div>
              <div class="tab-pane fade" id="encap-good-java" role="tabpanel">
                <pre><code>public class BankAccount {
    // Private fields (encapsulated data)
    private double balance;
    private String accountNumber;
    
    // Public getter methods
    public double getBalance() {
        return balance;
    }
    
    public String getAccountNumber() {
        return accountNumber;
    }
    
    // Constructor
    public BankAccount(String accountNumber, double initialBalance) {
        this.accountNumber = accountNumber;
        if (initialBalance < 0)
            throw new IllegalArgumentException("Initial balance cannot be negative");
        this.balance = initialBalance;
    }
    
    // Controlled methods to modify data
    public void deposit(double amount) {
        if (amount <= 0)
            throw new IllegalArgumentException("Deposit amount must be positive");
        balance += amount;
    }
    
    public void withdraw(double amount) {
        if (amount <= 0)
            throw new IllegalArgumentException("Withdrawal amount must be positive");
        if (amount > balance)
            throw new IllegalStateException("Insufficient funds");
        balance -= amount;
    }
}

// Usage
BankAccount account = new BankAccount("ACC001", 1000);
account.deposit(500);      // ‚úÖ Controlled access with validation
account.withdraw(200);     // ‚úÖ Controlled access with validation
// account.balance = -1000; // ‚ùå Compilation error - field is private!</code></pre>
              </div>
            </div>
          </div>

          <h2>Access Modifiers</h2>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th>Modifier</th>
                <th>Access Level</th>
                <th>Use Case</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><code>private</code></td>
                <td>Within the same class only</td>
                <td>Internal implementation details</td>
              </tr>
              <tr>
                <td><code>protected</code></td>
                <td>Within class and derived classes</td>
                <td>Data to be accessed by subclasses</td>
              </tr>
              <tr>
                <td><code>internal</code></td>
                <td>Within the same assembly</td>
                <td>Library-internal implementation</td>
              </tr>
              <tr>
                <td><code>protected internal</code></td>
                <td>Within assembly or derived classes</td>
                <td>Combination of protected and internal</td>
              </tr>
              <tr>
                <td><code>public</code></td>
                <td>Anywhere</td>
                <td>Public API and interfaces</td>
              </tr>
            </tbody>
          </table>

          <h2>Encapsulation Visualization</h2>
          <div class="mermaid">
classDiagram
    class BankAccount {
        -decimal balance
        -string accountNumber
        +decimal Balance
        +string AccountNumber
        +BankAccount(string, decimal)
        +Deposit(decimal)
        +Withdraw(decimal)
    }
    
    class Client {
        +UseBankAccount()
    }
    
    Client ..> BankAccount : uses
    
    note for BankAccount "Private fields are hidden\nPublic methods provide\ncontrolled access"
          </div>

          <div class="callout">
            <strong>üí° Best Practice:</strong> Follow the principle of least privilege‚Äîmake everything as private as possible, 
            and only expose what's necessary through public methods or properties. Use properties instead of public fields 
            to maintain control over data access.
          </div>
        </section>

        <!-- Abstraction Section -->
        <section id="abstraction" role="article">
          <h1>üé≠ Abstraction</h1>
          <span class="badge">pillar</span>
          <span class="badge">interfaces</span>
          <span class="badge">abstract-classes</span>
          
          <h2>What is Abstraction?</h2>
          <p>
            <strong>Abstraction</strong> is the process of hiding complex implementation details and showing only the essential features 
            of an object. It focuses on <strong>what</strong> an object does rather than <strong>how</strong> it does it.
          </p>

          <h2>Abstraction vs Encapsulation</h2>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th>Aspect</th>
                <th>Abstraction</th>
                <th>Encapsulation</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Purpose</td>
                <td>Hide complexity</td>
                <td>Hide data</td>
              </tr>
              <tr>
                <td>Focus</td>
                <td>Design level (what to do)</td>
                <td>Implementation level (how to do)</td>
              </tr>
              <tr>
                <td>Implementation</td>
                <td>Abstract classes, interfaces</td>
                <td>Access modifiers, properties</td>
              </tr>
              <tr>
                <td>Goal</td>
                <td>Reduce complexity</td>
                <td>Improve security and control</td>
              </tr>
            </tbody>
          </table>

          <h2>Abstract Classes</h2>
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" id="abstract-csharp-tab" data-bs-toggle="tab" data-bs-target="#abstract-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" id="abstract-java-tab" data-bs-toggle="tab" data-bs-target="#abstract-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="abstract-csharp" role="tabpanel">
                <pre><code>// Abstract class - cannot be instantiated directly
public abstract class Shape
{
    public string Name { get; set; }
    
    // Abstract method - must be implemented by derived classes
    public abstract double CalculateArea();
    
    // Abstract method
    public abstract double CalculatePerimeter();
    
    // Concrete method - can be inherited as-is
    public void Display()
    {
        Console.WriteLine($"Shape: {Name}");
        Console.WriteLine($"Area: {CalculateArea()}");
        Console.WriteLine($"Perimeter: {CalculatePerimeter()}");
    }
}

// Concrete implementation
public class Circle : Shape
{
    public double Radius { get; set; }
    
    public Circle(double radius)
    {
        Radius = radius;
        Name = "Circle";
    }
    
    public override double CalculateArea()
    {
        return Math.PI * Radius * Radius;
    }
    
    public override double CalculatePerimeter()
    {
        return 2 * Math.PI * Radius;
    }
}

public class Rectangle : Shape
{
    public double Width { get; set; }
    public double Height { get; set; }
    
    public Rectangle(double width, double height)
    {
        Width = width;
        Height = height;
        Name = "Rectangle";
    }
    
    public override double CalculateArea()
    {
        return Width * Height;
    }
    
    public override double CalculatePerimeter()
    {
        return 2 * (Width + Height);
    }
}

// Usage
Shape circle = new Circle(5);
circle.Display();

Shape rectangle = new Rectangle(4, 6);
rectangle.Display();</code></pre>
              </div>
              <div class="tab-pane fade" id="abstract-java" role="tabpanel">
                <pre><code>// Abstract class - cannot be instantiated directly
public abstract class Shape {
    private String name;
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    // Abstract method - must be implemented by derived classes
    public abstract double calculateArea();
    
    // Abstract method
    public abstract double calculatePerimeter();
    
    // Concrete method - can be inherited as-is
    public void display() {
        System.out.println("Shape: " + name);
        System.out.println("Area: " + calculateArea());
        System.out.println("Perimeter: " + calculatePerimeter());
    }
}

// Concrete implementation
public class Circle extends Shape {
    private double radius;
    
    public double getRadius() { return radius; }
    public void setRadius(double radius) { this.radius = radius; }
    
    public Circle(double radius) {
        this.radius = radius;
        setName("Circle");
    }
    
    @Override
    public double calculateArea() {
        return Math.PI * radius * radius;
    }
    
    @Override
    public double calculatePerimeter() {
        return 2 * Math.PI * radius;
    }
}

public class Rectangle extends Shape {
    private double width;
    private double height;
    
    public double getWidth() { return width; }
    public void setWidth(double width) { this.width = width; }
    public double getHeight() { return height; }
    public void setHeight(double height) { this.height = height; }
    
    public Rectangle(double width, double height) {
        this.width = width;
        this.height = height;
        setName("Rectangle");
    }
    
    @Override
    public double calculateArea() {
        return width * height;
    }
    
    @Override
    public double calculatePerimeter() {
        return 2 * (width + height);
    }
}

// Usage
Shape circle = new Circle(5);
circle.display();

Shape rectangle = new Rectangle(4, 6);
rectangle.display();</code></pre>
              </div>
            </div>
          </div>

          <h2>Interfaces</h2>
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" id="interface-csharp-tab" data-bs-toggle="tab" data-bs-target="#interface-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" id="interface-java-tab" data-bs-toggle="tab" data-bs-target="#interface-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="interface-csharp" role="tabpanel">
                <pre><code>// Interface - defines a contract
public interface IPaymentProcessor
{
    bool ProcessPayment(decimal amount);
    void RefundPayment(string transactionId);
    string GetPaymentStatus(string transactionId);
}

// Implementation for Credit Card
public class CreditCardProcessor : IPaymentProcessor
{
    public bool ProcessPayment(decimal amount)
    {
        Console.WriteLine($"Processing credit card payment: ${amount}");
        // Credit card specific logic
        return true;
    }
    
    public void RefundPayment(string transactionId)
    {
        Console.WriteLine($"Refunding credit card transaction: {transactionId}");
        // Credit card refund logic
    }
    
    public string GetPaymentStatus(string transactionId)
    {
        return "Completed";
    }
}

// Implementation for PayPal
public class PayPalProcessor : IPaymentProcessor
{
    public bool ProcessPayment(decimal amount)
    {
        Console.WriteLine($"Processing PayPal payment: ${amount}");
        // PayPal specific logic
        return true;
    }
    
    public void RefundPayment(string transactionId)
    {
        Console.WriteLine($"Refunding PayPal transaction: {transactionId}");
        // PayPal refund logic
    }
    
    public string GetPaymentStatus(string transactionId)
    {
        return "Pending";
    }
}

// Client code - works with abstraction
public class CheckoutService
{
    private readonly IPaymentProcessor paymentProcessor;
    
    public CheckoutService(IPaymentProcessor processor)
    {
        this.paymentProcessor = processor;
    }
    
    public void Checkout(decimal amount)
    {
        if (paymentProcessor.ProcessPayment(amount))
        {
            Console.WriteLine("Checkout successful!");
        }
    }
}

// Usage - can easily switch payment processors
var creditCardCheckout = new CheckoutService(new CreditCardProcessor());
creditCardCheckout.Checkout(100.50m);

var paypalCheckout = new CheckoutService(new PayPalProcessor());
paypalCheckout.Checkout(75.25m);</code></pre>
              </div>
              <div class="tab-pane fade" id="interface-java" role="tabpanel">
                <pre><code>// Interface - defines a contract
public interface PaymentProcessor {
    boolean processPayment(double amount);
    void refundPayment(String transactionId);
    String getPaymentStatus(String transactionId);
}

// Implementation for Credit Card
public class CreditCardProcessor implements PaymentProcessor {
    @Override
    public boolean processPayment(double amount) {
        System.out.println("Processing credit card payment: $" + amount);
        // Credit card specific logic
        return true;
    }
    
    @Override
    public void refundPayment(String transactionId) {
        System.out.println("Refunding credit card transaction: " + transactionId);
        // Credit card refund logic
    }
    
    @Override
    public String getPaymentStatus(String transactionId) {
        return "Completed";
    }
}

// Implementation for PayPal
public class PayPalProcessor implements PaymentProcessor {
    @Override
    public boolean processPayment(double amount) {
        System.out.println("Processing PayPal payment: $" + amount);
        // PayPal specific logic
        return true;
    }
    
    @Override
    public void refundPayment(String transactionId) {
        System.out.println("Refunding PayPal transaction: " + transactionId);
        // PayPal refund logic
    }
    
    @Override
    public String getPaymentStatus(String transactionId) {
        return "Pending";
    }
}

// Client code - works with abstraction
public class CheckoutService {
    private final PaymentProcessor paymentProcessor;
    
    public CheckoutService(PaymentProcessor processor) {
        this.paymentProcessor = processor;
    }
    
    public void checkout(double amount) {
        if (paymentProcessor.processPayment(amount)) {
            System.out.println("Checkout successful!");
        }
    }
}

// Usage - can easily switch payment processors
CheckoutService creditCardCheckout = new CheckoutService(new CreditCardProcessor());
creditCardCheckout.checkout(100.50);

CheckoutService paypalCheckout = new CheckoutService(new PayPalProcessor());
paypalCheckout.checkout(75.25);</code></pre>
              </div>
            </div>
          </div>

          <h2>Abstraction Hierarchy</h2>
          <div class="mermaid">
classDiagram
    class IPaymentProcessor {
        <<interface>>
        +ProcessPayment(decimal) bool
        +RefundPayment(string) void
        +GetPaymentStatus(string) string
    }
    
    class CreditCardProcessor {
        +ProcessPayment(decimal) bool
        +RefundPayment(string) void
        +GetPaymentStatus(string) string
    }
    
    class PayPalProcessor {
        +ProcessPayment(decimal) bool
        +RefundPayment(string) void
        +GetPaymentStatus(string) string
    }
    
    class CheckoutService {
        -IPaymentProcessor processor
        +Checkout(decimal) void
    }
    
    IPaymentProcessor <|.. CreditCardProcessor : implements
    IPaymentProcessor <|.. PayPalProcessor : implements
    CheckoutService --> IPaymentProcessor : uses
          </div>

          <h2>Abstract Class vs Interface</h2>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th>Feature</th>
                <th>Abstract Class</th>
                <th>Interface</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Multiple Inheritance</td>
                <td>‚ùå No (single inheritance only)</td>
                <td>‚úÖ Yes (can implement multiple)</td>
              </tr>
              <tr>
                <td>Implementation</td>
                <td>‚úÖ Can have concrete methods</td>
                <td>‚ùå Only signatures (C# 8+ allows default)</td>
              </tr>
              <tr>
                <td>Fields</td>
                <td>‚úÖ Can have fields</td>
                <td>‚ùå Cannot have fields</td>
              </tr>
              <tr>
                <td>Access Modifiers</td>
                <td>‚úÖ Can have any modifier</td>
                <td>‚ùå Members are public by default</td>
              </tr>
              <tr>
                <td>Constructor</td>
                <td>‚úÖ Can have constructors</td>
                <td>‚ùå Cannot have constructors</td>
              </tr>
              <tr>
                <td>Use Case</td>
                <td>IS-A relationship (inheritance)</td>
                <td>CAN-DO relationship (capability)</td>
              </tr>
            </tbody>
          </table>

          <div class="callout">
            <strong>üí° Best Practice:</strong> Use interfaces to define contracts and capabilities (what a class can do). 
            Use abstract classes when you have common implementation that subclasses should share (what a class is). 
            Favor composition over inheritance when possible.
          </div>
        </section>

        <!-- Inheritance Section -->
        <section id="inheritance" role="article">
          <h1>üß¨ Inheritance</h1>
          <span class="badge">pillar</span>
          <span class="badge">reusability</span>
          <span class="badge">hierarchy</span>
          
          <h2>What is Inheritance?</h2>
          <p>
            <strong>Inheritance</strong> is a mechanism where a new class (derived/child class) is created from an existing class 
            (base/parent class), inheriting its properties and methods. It establishes an <strong>IS-A</strong> relationship.
          </p>

          <h2>Benefits of Inheritance</h2>
          <ul>
            <li><strong>Code Reusability:</strong> Avoid duplicating code by inheriting common functionality</li>
            <li><strong>Extensibility:</strong> Easily extend existing classes with new features</li>
            <li><strong>Polymorphism:</strong> Enables polymorphic behavior through method overriding</li>
            <li><strong>Organization:</strong> Creates logical hierarchies that model real-world relationships</li>
          </ul>

          <h2>Basic Inheritance</h2>
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" id="inherit-basic-csharp-tab" data-bs-toggle="tab" data-bs-target="#inherit-basic-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" id="inherit-basic-java-tab" data-bs-toggle="tab" data-bs-target="#inherit-basic-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="inherit-basic-csharp" role="tabpanel">
                <pre><code>// Base class (Parent)
public class Vehicle
{
    public string Brand { get; set; }
    public string Model { get; set; }
    public int Year { get; set; }
    
    public void Start()
    {
        Console.WriteLine($"{Brand} {Model} is starting...");
    }
    
    public void Stop()
    {
        Console.WriteLine($"{Brand} {Model} is stopping...");
    }
}

// Derived class (Child)
public class Car : Vehicle
{
    public int NumberOfDoors { get; set; }
    
    public void OpenTrunk()
    {
        Console.WriteLine("Trunk is opening...");
    }
}

// Another derived class
public class Motorcycle : Vehicle
{
    public bool HasSidecar { get; set; }
    
    public void Wheelie()
    {
        Console.WriteLine("Doing a wheelie!");
    }
}

// Usage
Car myCar = new Car
{
    Brand = "Toyota",
    Model = "Camry",
    Year = 2024,
    NumberOfDoors = 4
};

myCar.Start();      // Inherited method
myCar.OpenTrunk();  // Car-specific method

Motorcycle myBike = new Motorcycle
{
    Brand = "Harley-Davidson",
    Model = "Street 750",
    Year = 2024,
    HasSidecar = false
};

myBike.Start();     // Inherited method
myBike.Wheelie();   // Motorcycle-specific method</code></pre>
              </div>
              <div class="tab-pane fade" id="inherit-basic-java" role="tabpanel">
                <pre><code>// Base class (Parent)
public class Vehicle {
    private String brand;
    private String model;
    private int year;
    
    public String getBrand() { return brand; }
    public void setBrand(String brand) { this.brand = brand; }
    public String getModel() { return model; }
    public void setModel(String model) { this.model = model; }
    public int getYear() { return year; }
    public void setYear(int year) { this.year = year; }
    
    public void start() {
        System.out.println(brand + " " + model + " is starting...");
    }
    
    public void stop() {
        System.out.println(brand + " " + model + " is stopping...");
    }
}

// Derived class (Child)
public class Car extends Vehicle {
    private int numberOfDoors;
    
    public int getNumberOfDoors() { return numberOfDoors; }
    public void setNumberOfDoors(int numberOfDoors) { this.numberOfDoors = numberOfDoors; }
    
    public void openTrunk() {
        System.out.println("Trunk is opening...");
    }
}

// Another derived class
public class Motorcycle extends Vehicle {
    private boolean hasSidecar;
    
    public boolean isHasSidecar() { return hasSidecar; }
    public void setHasSidecar(boolean hasSidecar) { this.hasSidecar = hasSidecar; }
    
    public void wheelie() {
        System.out.println("Doing a wheelie!");
    }
}

// Usage
Car myCar = new Car();
myCar.setBrand("Toyota");
myCar.setModel("Camry");
myCar.setYear(2024);
myCar.setNumberOfDoors(4);

myCar.start();      // Inherited method
myCar.openTrunk();  // Car-specific method

Motorcycle myBike = new Motorcycle();
myBike.setBrand("Harley-Davidson");
myBike.setModel("Street 750");
myBike.setYear(2024);
myBike.setHasSidecar(false);

myBike.start();     // Inherited method
myBike.wheelie();   // Motorcycle-specific method</code></pre>
              </div>
            </div>
          </div>

          <h2>Method Overriding</h2>
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" id="override-csharp-tab" data-bs-toggle="tab" data-bs-target="#override-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" id="override-java-tab" data-bs-toggle="tab" data-bs-target="#override-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="override-csharp" role="tabpanel">
                <pre><code>public class Animal
{
    public string Name { get; set; }
    
    // Virtual method - can be overridden
    public virtual void MakeSound()
    {
        Console.WriteLine("Some generic animal sound");
    }
    
    public virtual void Eat()
    {
        Console.WriteLine($"{Name} is eating...");
    }
}

public class Dog : Animal
{
    // Override the base method
    public override void MakeSound()
    {
        Console.WriteLine("Woof! Woof!");
    }
    
    // Add new method
    public void Fetch()
    {
        Console.WriteLine($"{Name} is fetching the ball!");
    }
}

public class Cat : Animal
{
    public override void MakeSound()
    {
        Console.WriteLine("Meow! Meow!");
    }
    
    public void Scratch()
    {
        Console.WriteLine($"{Name} is scratching the furniture!");
    }
}

// Usage
Animal myDog = new Dog { Name = "Buddy" };
myDog.MakeSound();  // Output: Woof! Woof! (overridden)

Animal myCat = new Cat { Name = "Whiskers" };
myCat.MakeSound();  // Output: Meow! Meow! (overridden)</code></pre>
              </div>
              <div class="tab-pane fade" id="override-java" role="tabpanel">
                <pre><code>public class Animal {
    private String name;
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    // Method - can be overridden
    public void makeSound() {
        System.out.println("Some generic animal sound");
    }
    
    public void eat() {
        System.out.println(name + " is eating...");
    }
}

public class Dog extends Animal {
    // Override the base method
    @Override
    public void makeSound() {
        System.out.println("Woof! Woof!");
    }
    
    // Add new method
    public void fetch() {
        System.out.println(getName() + " is fetching the ball!");
    }
}

public class Cat extends Animal {
    @Override
    public void makeSound() {
        System.out.println("Meow! Meow!");
    }
    
    public void scratch() {
        System.out.println(getName() + " is scratching the furniture!");
    }
}

// Usage
Animal myDog = new Dog();
myDog.setName("Buddy");
myDog.makeSound();  // Output: Woof! Woof! (overridden)

Animal myCat = new Cat();
myCat.setName("Whiskers");
myCat.makeSound();  // Output: Meow! Meow! (overridden)</code></pre>
              </div>
            </div>
          </div>

          <h2>Using 'base' Keyword (C#) / 'super' Keyword (Java)</h2>
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" id="base-csharp-tab" data-bs-toggle="tab" data-bs-target="#base-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" id="base-java-tab" data-bs-toggle="tab" data-bs-target="#base-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="base-csharp" role="tabpanel">
                <pre><code>public class Employee
{
    public string Name { get; set; }
    public decimal BaseSalary { get; set; }
    
    public Employee(string name, decimal baseSalary)
    {
        Name = name;
        BaseSalary = baseSalary;
    }
    
    public virtual decimal CalculateSalary()
    {
        return BaseSalary;
    }
}

public class Manager : Employee
{
    public decimal Bonus { get; set; }
    
    // Call base constructor
    public Manager(string name, decimal baseSalary, decimal bonus) 
        : base(name, baseSalary)
    {
        Bonus = bonus;
    }
    
    // Override and extend base method
    public override decimal CalculateSalary()
    {
        decimal baseSalary = base.CalculateSalary();  // Call base method
        return baseSalary + Bonus;
    }
}

// Usage
Manager manager = new Manager("John Doe", 80000, 20000);
Console.WriteLine($"Total Salary: ${manager.CalculateSalary()}");  
// Output: Total Salary: $100000</code></pre>
              </div>
              <div class="tab-pane fade" id="base-java" role="tabpanel">
                <pre><code>public class Employee {
    private String name;
    private double baseSalary;
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public double getBaseSalary() { return baseSalary; }
    public void setBaseSalary(double baseSalary) { this.baseSalary = baseSalary; }
    
    public Employee(String name, double baseSalary) {
        this.name = name;
        this.baseSalary = baseSalary;
    }
    
    public double calculateSalary() {
        return baseSalary;
    }
}

public class Manager extends Employee {
    private double bonus;
    
    public double getBonus() { return bonus; }
    public void setBonus(double bonus) { this.bonus = bonus; }
    
    // Call super constructor
    public Manager(String name, double baseSalary, double bonus) {
        super(name, baseSalary);  // Call parent constructor
        this.bonus = bonus;
    }
    
    // Override and extend base method
    @Override
    public double calculateSalary() {
        double baseSal = super.calculateSalary();  // Call parent method
        return baseSal + bonus;
    }
}

// Usage
Manager manager = new Manager("John Doe", 80000, 20000);
System.out.println("Total Salary: $" + manager.calculateSalary());  
// Output: Total Salary: $100000.0</code></pre>
              </div>
            </div>
          </div>

          <h2>Inheritance Hierarchy</h2>
          <div class="mermaid">
classDiagram
    class Vehicle {
        +string Brand
        +string Model
        +int Year
        +Start() void
        +Stop() void
    }
    
    class Car {
        +int NumberOfDoors
        +OpenTrunk() void
    }
    
    class Motorcycle {
        +bool HasSidecar
        +Wheelie() void
    }
    
    class Truck {
        +decimal CargoCapacity
        +LoadCargo() void
    }
    
    Vehicle <|-- Car
    Vehicle <|-- Motorcycle
    Vehicle <|-- Truck
          </div>

          <h2>Types of Inheritance</h2>
          <div class="row g-3">
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-blue">
                <div class="card-body">
                  <h3>Single Inheritance</h3>
                  <p>One child class inherits from one parent class.</p>
                  <p><code>Car : Vehicle</code></p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-green">
                <div class="card-body">
                  <h3>Multilevel Inheritance</h3>
                  <p>A class inherits from a child class.</p>
                  <p><code>SportsCar : Car : Vehicle</code></p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-yellow">
                <div class="card-body">
                  <h3>Hierarchical Inheritance</h3>
                  <p>Multiple child classes inherit from one parent.</p>
                  <p><code>Car : Vehicle, Truck : Vehicle</code></p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-red">
                <div class="card-body">
                  <h3>Multiple Inheritance</h3>
                  <p>‚ùå Not supported in C# (use interfaces instead).</p>
                  <p>Can implement multiple interfaces.</p>
                </div>
              </div>
            </div>
          </div>

          <div class="callout">
            <strong>‚ö†Ô∏è Caution:</strong> Favor composition over inheritance when the relationship is not a true IS-A relationship. 
            Deep inheritance hierarchies can become difficult to maintain. The Liskov Substitution Principle states that 
            derived classes must be substitutable for their base classes.
          </div>
        </section>

        <!-- Polymorphism Section -->
        <section id="polymorphism" role="article">
          <h1>üé® Polymorphism</h1>
          <span class="badge">pillar</span>
          <span class="badge">flexibility</span>
          <span class="badge">dynamic-binding</span>
          
          <h2>What is Polymorphism?</h2>
          <p>
            <strong>Polymorphism</strong> (from Greek: "many forms") is the ability of objects to take on different forms or behave 
            differently based on their actual type. It allows you to write flexible, extensible code that works with objects of 
            different types through a common interface.
          </p>

          <h2>Types of Polymorphism</h2>
          
          <div class="row g-3 mb-4">
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-blue">
                <div class="card-body">
                  <h3>üìã Compile-Time Polymorphism</h3>
                  <p><strong>Also known as:</strong> Static Polymorphism, Early Binding</p>
                  <p><strong>Mechanism:</strong> Method Overloading, Operator Overloading</p>
                  <p><strong>Resolution:</strong> At compile time</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-purple">
                <div class="card-body">
                  <h3>‚ö° Runtime Polymorphism</h3>
                  <p><strong>Also known as:</strong> Dynamic Polymorphism, Late Binding</p>
                  <p><strong>Mechanism:</strong> Method Overriding (virtual/override)</p>
                  <p><strong>Resolution:</strong> At runtime</p>
                </div>
              </div>
            </div>
          </div>

          <h2>1. Compile-Time Polymorphism (Method Overloading)</h2>
          <p>Same method name with different parameters in the same class.</p>
          
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" id="poly-compile-csharp-tab" data-bs-toggle="tab" data-bs-target="#poly-compile-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" id="poly-compile-java-tab" data-bs-toggle="tab" data-bs-target="#poly-compile-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="poly-compile-csharp" role="tabpanel">
                <pre><code>public class Calculator
{
    // Method overloading - same name, different parameters
    
    public int Add(int a, int b)
    {
        return a + b;
    }
    
    public int Add(int a, int b, int c)
    {
        return a + b + c;
    }
    
    public double Add(double a, double b)
    {
        return a + b;
    }
    
    public string Add(string a, string b)
    {
        return a + b;
    }
}

// Usage
Calculator calc = new Calculator();

Console.WriteLine(calc.Add(5, 10));              // Output: 15 (int)
Console.WriteLine(calc.Add(5, 10, 15));          // Output: 30 (int)
Console.WriteLine(calc.Add(5.5, 10.5));          // Output: 16.0 (double)
Console.WriteLine(calc.Add("Hello", "World"));   // Output: HelloWorld (string)</code></pre>
              </div>
              <div class="tab-pane fade" id="poly-compile-java" role="tabpanel">
                <pre><code>public class Calculator {
    // Method overloading - same name, different parameters
    
    public int add(int a, int b) {
        return a + b;
    }
    
    public int add(int a, int b, int c) {
        return a + b + c;
    }
    
    public double add(double a, double b) {
        return a + b;
    }
    
    public String add(String a, String b) {
        return a + b;
    }
}

// Usage
Calculator calc = new Calculator();

System.out.println(calc.add(5, 10));              // Output: 15 (int)
System.out.println(calc.add(5, 10, 15));          // Output: 30 (int)
System.out.println(calc.add(5.5, 10.5));          // Output: 16.0 (double)
System.out.println(calc.add("Hello", "World"));   // Output: HelloWorld (string)</code></pre>
              </div>
            </div>
          </div>

          <h2>2. Runtime Polymorphism (Method Overriding)</h2>
          <p>Derived class provides a specific implementation of a method defined in the base class.</p>
          
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" id="poly-runtime-csharp-tab" data-bs-toggle="tab" data-bs-target="#poly-runtime-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" id="poly-runtime-java-tab" data-bs-toggle="tab" data-bs-target="#poly-runtime-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="poly-runtime-csharp" role="tabpanel">
                <pre><code>public class PaymentMethod
{
    public virtual void ProcessPayment(decimal amount)
    {
        Console.WriteLine($"Processing payment of ${amount}");
    }
}

public class CreditCard : PaymentMethod
{
    public override void ProcessPayment(decimal amount)
    {
        Console.WriteLine($"Processing credit card payment of ${amount}");
        Console.WriteLine("Authorizing with bank...");
        Console.WriteLine("Payment approved!");
    }
}

public class PayPal : PaymentMethod
{
    public override void ProcessPayment(decimal amount)
    {
        Console.WriteLine($"Processing PayPal payment of ${amount}");
        Console.WriteLine("Redirecting to PayPal...");
        Console.WriteLine("Payment completed!");
    }
}

public class Cash : PaymentMethod
{
    public override void ProcessPayment(decimal amount)
    {
        Console.WriteLine($"Receiving cash payment of ${amount}");
        Console.WriteLine("Thank you!");
    }
}

// Usage - Polymorphic behavior
public class PaymentProcessor
{
    public void ProcessOrder(PaymentMethod paymentMethod, decimal amount)
    {
        // Same method call, different behavior based on actual type
        paymentMethod.ProcessPayment(amount);
    }
}

// Client code
var processor = new PaymentProcessor();

PaymentMethod payment1 = new CreditCard();
processor.ProcessOrder(payment1, 100.50m);  // Credit card behavior

PaymentMethod payment2 = new PayPal();
processor.ProcessOrder(payment2, 75.25m);   // PayPal behavior

PaymentMethod payment3 = new Cash();
processor.ProcessOrder(payment3, 50.00m);   // Cash behavior</code></pre>
              </div>
              <div class="tab-pane fade" id="poly-runtime-java" role="tabpanel">
                <pre><code>public class PaymentMethod {
    public void processPayment(double amount) {
        System.out.println("Processing payment of $" + amount);
    }
}

public class CreditCard extends PaymentMethod {
    @Override
    public void processPayment(double amount) {
        System.out.println("Processing credit card payment of $" + amount);
        System.out.println("Authorizing with bank...");
        System.out.println("Payment approved!");
    }
}

public class PayPal extends PaymentMethod {
    @Override
    public void processPayment(double amount) {
        System.out.println("Processing PayPal payment of $" + amount);
        System.out.println("Redirecting to PayPal...");
        System.out.println("Payment completed!");
    }
}

public class Cash extends PaymentMethod {
    @Override
    public void processPayment(double amount) {
        System.out.println("Receiving cash payment of $" + amount);
        System.out.println("Thank you!");
    }
}

// Usage - Polymorphic behavior
public class PaymentProcessor {
    public void processOrder(PaymentMethod paymentMethod, double amount) {
        // Same method call, different behavior based on actual type
        paymentMethod.processPayment(amount);
    }
}

// Client code
PaymentProcessor processor = new PaymentProcessor();

PaymentMethod payment1 = new CreditCard();
processor.processOrder(payment1, 100.50);  // Credit card behavior

PaymentMethod payment2 = new PayPal();
processor.processOrder(payment2, 75.25);   // PayPal behavior

PaymentMethod payment3 = new Cash();
processor.processOrder(payment3, 50.00);   // Cash behavior</code></pre>
              </div>
            </div>
          </div>

          <h2>Polymorphism in Action</h2>
          <div class="mermaid">
sequenceDiagram
    participant Client
    participant PaymentMethod
    participant CreditCard
    participant PayPal
    
    Client->>PaymentMethod: ProcessOrder(payment, 100)
    
    alt payment is CreditCard
        PaymentMethod->>CreditCard: ProcessPayment(100)
        CreditCard-->>PaymentMethod: Credit card processing
    else payment is PayPal
        PaymentMethod->>PayPal: ProcessPayment(100)
        PayPal-->>PaymentMethod: PayPal processing
    end
    
    PaymentMethod-->>Client: Payment completed
          </div>

          <h2>Real-World Example: Drawing Application</h2>
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" id="poly-shape-csharp-tab" data-bs-toggle="tab" data-bs-target="#poly-shape-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" id="poly-shape-java-tab" data-bs-toggle="tab" data-bs-target="#poly-shape-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="poly-shape-csharp" role="tabpanel">
                <pre><code>public abstract class Shape
{
    public string Color { get; set; }
    
    public abstract void Draw();
    public abstract double GetArea();
}

public class Circle : Shape
{
    public double Radius { get; set; }
    
    public override void Draw()
    {
        Console.WriteLine($"Drawing a {Color} circle with radius {Radius}");
    }
    
    public override double GetArea()
    {
        return Math.PI * Radius * Radius;
    }
}

public class Rectangle : Shape
{
    public double Width { get; set; }
    public double Height { get; set; }
    
    public override void Draw()
    {
        Console.WriteLine($"Drawing a {Color} rectangle {Width}x{Height}");
    }
    
    public override double GetArea()
    {
        return Width * Height;
    }
}

public class Triangle : Shape
{
    public double Base { get; set; }
    public double Height { get; set; }
    
    public override void Draw()
    {
        Console.WriteLine($"Drawing a {Color} triangle");
    }
    
    public override double GetArea()
    {
        return 0.5 * Base * Height;
    }
}

// Drawing canvas that works polymorphically
public class Canvas
{
    private List<Shape> shapes = new List<Shape>();
    
    public void AddShape(Shape shape)
    {
        shapes.Add(shape);
    }
    
    public void DrawAll()
    {
        foreach (Shape shape in shapes)
        {
            shape.Draw();  // Polymorphic call - each shape draws itself
            Console.WriteLine($"Area: {shape.GetArea():F2}\n");
        }
    }
}

// Usage
Canvas canvas = new Canvas();

canvas.AddShape(new Circle { Color = "Red", Radius = 5 });
canvas.AddShape(new Rectangle { Color = "Blue", Width = 4, Height = 6 });
canvas.AddShape(new Triangle { Color = "Green", Base = 3, Height = 4 });

canvas.DrawAll();</code></pre>
              </div>
              <div class="tab-pane fade" id="poly-shape-java" role="tabpanel">
                <pre><code>import java.util.ArrayList;
import java.util.List;

public abstract class Shape {
    private String color;
    
    public String getColor() { return color; }
    public void setColor(String color) { this.color = color; }
    
    public abstract void draw();
    public abstract double getArea();
}

public class Circle extends Shape {
    private double radius;
    
    public double getRadius() { return radius; }
    public void setRadius(double radius) { this.radius = radius; }
    
    @Override
    public void draw() {
        System.out.println("Drawing a " + getColor() + " circle with radius " + radius);
    }
    
    @Override
    public double getArea() {
        return Math.PI * radius * radius;
    }
}

public class Rectangle extends Shape {
    private double width;
    private double height;
    
    public double getWidth() { return width; }
    public void setWidth(double width) { this.width = width; }
    public double getHeight() { return height; }
    public void setHeight(double height) { this.height = height; }
    
    @Override
    public void draw() {
        System.out.println("Drawing a " + getColor() + " rectangle " + width + "x" + height);
    }
    
    @Override
    public double getArea() {
        return width * height;
    }
}

public class Triangle extends Shape {
    private double base;
    private double height;
    
    public double getBase() { return base; }
    public void setBase(double base) { this.base = base; }
    public double getHeight() { return height; }
    public void setHeight(double height) { this.height = height; }
    
    @Override
    public void draw() {
        System.out.println("Drawing a " + getColor() + " triangle");
    }
    
    @Override
    public double getArea() {
        return 0.5 * base * height;
    }
}

// Drawing canvas that works polymorphically
public class Canvas {
    private List<Shape> shapes = new ArrayList<>();
    
    public void addShape(Shape shape) {
        shapes.add(shape);
    }
    
    public void drawAll() {
        for (Shape shape : shapes) {
            shape.draw();  // Polymorphic call - each shape draws itself
            System.out.printf("Area: %.2f%n%n", shape.getArea());
        }
    }
}

// Usage
Canvas canvas = new Canvas();

Circle circle = new Circle();
circle.setColor("Red");
circle.setRadius(5);
canvas.addShape(circle);

Rectangle rectangle = new Rectangle();
rectangle.setColor("Blue");
rectangle.setWidth(4);
rectangle.setHeight(6);
canvas.addShape(rectangle);

Triangle triangle = new Triangle();
triangle.setColor("Green");
triangle.setBase(3);
triangle.setHeight(4);
canvas.addShape(triangle);

canvas.drawAll();</code></pre>
              </div>
            </div>
          </div>

          <h2>Benefits of Polymorphism</h2>
          <ul>
            <li><strong>Flexibility:</strong> Write code that works with multiple types without knowing the specific type</li>
            <li><strong>Extensibility:</strong> Add new types without modifying existing code (Open/Closed Principle)</li>
            <li><strong>Maintainability:</strong> Reduce code duplication and improve organization</li>
            <li><strong>Testability:</strong> Easy to create mock objects for testing</li>
          </ul>

          <div class="callout">
            <strong>üí° Key Insight:</strong> Polymorphism is the cornerstone of flexible, extensible OOP design. It enables the 
            Open/Closed Principle‚Äîyour code is open for extension (add new derived classes) but closed for modification 
            (existing code doesn't change). Always program to an interface or base class, not a concrete implementation.
          </div>
        </section>

        <!-- Classes and Objects Section -->
        <section id="classes-objects" role="article">
          <h1>üß± Classes and Objects</h1>
          <span class="badge">basics</span>
          <span class="badge">blueprint</span>
          <span class="badge">instance</span>
          
          <h2>Understanding Classes and Objects</h2>
          <p>
            <strong>Classes</strong> and <strong>Objects</strong> are the fundamental building blocks of Object-Oriented Programming. 
            A class is a blueprint or template that defines the structure and behavior, while an object is a concrete instance 
            created from that class.
          </p>

          <div class="row g-3 mb-4">
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-blue">
                <div class="card-body">
                  <h3>üìê Class</h3>
                  <p><strong>Definition:</strong> A blueprint/template for creating objects</p>
                  <p><strong>Contains:</strong> Fields, properties, methods, constructors</p>
                  <p><strong>Nature:</strong> Logical concept, no memory allocated</p>
                  <p><strong>Example:</strong> Car blueprint (design document)</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-green">
                <div class="card-body">
                  <h3>üéØ Object</h3>
                  <p><strong>Definition:</strong> An instance of a class</p>
                  <p><strong>Contains:</strong> Actual data/state</p>
                  <p><strong>Nature:</strong> Physical entity, memory allocated</p>
                  <p><strong>Example:</strong> Specific car (Toyota Camry 2024)</p>
                </div>
              </div>
            </div>
          </div>

          <h2>Class Definition</h2>
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" id="class-person-csharp-tab" data-bs-toggle="tab" data-bs-target="#class-person-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" id="class-person-java-tab" data-bs-toggle="tab" data-bs-target="#class-person-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="class-person-csharp" role="tabpanel">
                <pre><code>// Class definition
public class Person
{
    // Fields (private data)
    private string firstName;
    private string lastName;
    private int age;
    
    // Properties (public accessors)
    public string FirstName 
    { 
        get { return firstName; }
        set { firstName = value; }
    }
    
    public string LastName 
    { 
        get { return lastName; }
        set { lastName = value; }
    }
    
    public int Age 
    { 
        get { return age; }
        set 
        { 
            if (value >= 0 && value <= 150)
                age = value;
            else
                throw new ArgumentException("Invalid age");
        }
    }
    
    // Auto-implemented property (shorthand)
    public string Email { get; set; }
    
    // Constructor (default)
    public Person()
    {
        FirstName = "Unknown";
        LastName = "Unknown";
        Age = 0;
    }
    
    // Constructor (parameterized)
    public Person(string firstName, string lastName, int age)
    {
        FirstName = firstName;
        LastName = lastName;
        Age = age;
    }
    
    // Methods (behavior)
    public string GetFullName()
    {
        return $"{FirstName} {LastName}";
    }
    
    public void Introduce()
    {
        Console.WriteLine($"Hi, I'm {GetFullName()} and I'm {Age} years old.");
    }
    
    public bool IsAdult()
    {
        return Age >= 18;
    }
}</code></pre>
              </div>
              <div class="tab-pane fade" id="class-person-java" role="tabpanel">
                <pre><code>// Class definition
public class Person {
    // Fields (private data)
    private String firstName;
    private String lastName;
    private int age;
    private String email;
    
    // Getter and Setter methods (Java approach to properties)
    public String getFirstName() {
        return firstName;
    }
    
    public void setFirstName(String firstName) {
        this.firstName = firstName;
    }
    
    public String getLastName() {
        return lastName;
    }
    
    public void setLastName(String lastName) {
        this.lastName = lastName;
    }
    
    public int getAge() {
        return age;
    }
    
    public void setAge(int age) {
        if (age >= 0 && age <= 150)
            this.age = age;
        else
            throw new IllegalArgumentException("Invalid age");
    }
    
    public String getEmail() {
        return email;
    }
    
    public void setEmail(String email) {
        this.email = email;
    }
    
    // Constructor (default)
    public Person() {
        this.firstName = "Unknown";
        this.lastName = "Unknown";
        this.age = 0;
    }
    
    // Constructor (parameterized)
    public Person(String firstName, String lastName, int age) {
        this.firstName = firstName;
        this.lastName = lastName;
        this.age = age;
    }
    
    // Methods (behavior)
    public String getFullName() {
        return firstName + " " + lastName;
    }
    
    public void introduce() {
        System.out.println("Hi, I'm " + getFullName() + " and I'm " + age + " years old.");
    }
    
    public boolean isAdult() {
        return age >= 18;
    }
}</code></pre>
              </div>
            </div>
          </div>

          <h2>Creating and Using Objects</h2>
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" id="objects-csharp-tab" data-bs-toggle="tab" data-bs-target="#objects-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" id="objects-java-tab" data-bs-toggle="tab" data-bs-target="#objects-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="objects-csharp" role="tabpanel">
                <pre><code>// Creating objects (instances) from the Person class

// Using default constructor
Person person1 = new Person();
person1.FirstName = "John";
person1.LastName = "Doe";
person1.Age = 30;
person1.Email = "john.doe@example.com";

// Using parameterized constructor
Person person2 = new Person("Jane", "Smith", 25);
person2.Email = "jane.smith@example.com";

// Using object initializer syntax
Person person3 = new Person
{
    FirstName = "Bob",
    LastName = "Johnson",
    Age = 35,
    Email = "bob.johnson@example.com"
};

// Using objects
Console.WriteLine(person1.GetFullName());  // Output: John Doe
person2.Introduce();                       // Output: Hi, I'm Jane Smith and I'm 25 years old.

if (person3.IsAdult())
{
    Console.WriteLine($"{person3.GetFullName()} is an adult.");
}</code></pre>
              </div>
              <div class="tab-pane fade" id="objects-java" role="tabpanel">
                <pre><code>// Creating objects (instances) from the Person class

// Using default constructor
Person person1 = new Person();
person1.setFirstName("John");
person1.setLastName("Doe");
person1.setAge(30);
person1.setEmail("john.doe@example.com");

// Using parameterized constructor
Person person2 = new Person("Jane", "Smith", 25);
person2.setEmail("jane.smith@example.com");

// Using parameterized constructor and setters
Person person3 = new Person();
person3.setFirstName("Bob");
person3.setLastName("Johnson");
person3.setAge(35);
person3.setEmail("bob.johnson@example.com");

// Using objects
System.out.println(person1.getFullName());  // Output: John Doe
person2.introduce();                        // Output: Hi, I'm Jane Smith and I'm 25 years old.

if (person3.isAdult()) {
    System.out.println(person3.getFullName() + " is an adult.");
}</code></pre>
              </div>
            </div>
          </div>

          <h2>Class Structure Diagram</h2>
          <div class="mermaid">
classDiagram
    class Person {
        -string firstName
        -string lastName
        -int age
        +string FirstName
        +string LastName
        +int Age
        +string Email
        +Person()
        +Person(string, string, int)
        +GetFullName() string
        +Introduce() void
        +IsAdult() bool
    }
    
    class PersonInstance1 {
        FirstName: "John"
        LastName: "Doe"
        Age: 30
        Email: "john.doe@example.com"
    }
    
    class PersonInstance2 {
        FirstName: "Jane"
        LastName: "Smith"
        Age: 25
        Email: "jane.smith@example.com"
    }
    
    Person <|.. PersonInstance1 : instance of
    Person <|.. PersonInstance2 : instance of
          </div>

          <h2>Real-World Example: BankAccount Class</h2>
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" id="bank-account-csharp-tab" data-bs-toggle="tab" data-bs-target="#bank-account-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" id="bank-account-java-tab" data-bs-toggle="tab" data-bs-target="#bank-account-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="bank-account-csharp" role="tabpanel">
                <pre><code>public class BankAccount
{
    // Static field - shared across all instances
    private static int nextAccountNumber = 1000;
    
    // Instance fields
    private string accountNumber;
    private string accountHolder;
    private decimal balance;
    private List<string> transactionHistory;
    
    // Properties
    public string AccountNumber 
    { 
        get { return accountNumber; } 
    }
    
    public string AccountHolder 
    { 
        get { return accountHolder; }
        set { accountHolder = value; }
    }
    
    public decimal Balance 
    { 
        get { return balance; } 
    }
    
    // Constructor
    public BankAccount(string accountHolder, decimal initialDeposit)
    {
        accountNumber = $"ACC{nextAccountNumber++}";
        this.accountHolder = accountHolder;
        balance = initialDeposit;
        transactionHistory = new List<string>();
        
        AddTransaction($"Account opened with ${initialDeposit}");
    }
    
    // Methods
    public void Deposit(decimal amount)
    {
        if (amount <= 0)
        {
            throw new ArgumentException("Deposit amount must be positive");
        }
        
        balance += amount;
        AddTransaction($"Deposited ${amount}. New balance: ${balance}");
        Console.WriteLine($"Deposited ${amount}. Current balance: ${balance}");
    }
    
    public void Withdraw(decimal amount)
    {
        if (amount <= 0)
        {
            throw new ArgumentException("Withdrawal amount must be positive");
        }
        
        if (amount > balance)
        {
            throw new InvalidOperationException("Insufficient funds");
        }
        
        balance -= amount;
        AddTransaction($"Withdrew ${amount}. New balance: ${balance}");
        Console.WriteLine($"Withdrew ${amount}. Current balance: ${balance}");
    }
    
    public void Transfer(BankAccount targetAccount, decimal amount)
    {
        if (amount <= 0)
        {
            throw new ArgumentException("Transfer amount must be positive");
        }
        
        Withdraw(amount);
        targetAccount.Deposit(amount);
        AddTransaction($"Transferred ${amount} to {targetAccount.AccountNumber}");
    }
    
    public void PrintStatement()
    {
        Console.WriteLine($"\n=== Account Statement ===");
        Console.WriteLine($"Account Number: {AccountNumber}");
        Console.WriteLine($"Account Holder: {AccountHolder}");
        Console.WriteLine($"Current Balance: ${Balance}");
        Console.WriteLine($"\nTransaction History:");
        foreach (var transaction in transactionHistory)
        {
            Console.WriteLine($"  - {transaction}");
        }
        Console.WriteLine("========================\n");
    }
    
    private void AddTransaction(string description)
    {
        string timestamp = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss");
        transactionHistory.Add($"[{timestamp}] {description}");
    }
}

// Usage
BankAccount johnAccount = new BankAccount("John Doe", 1000);
BankAccount janeAccount = new BankAccount("Jane Smith", 500);

johnAccount.Deposit(500);         // John deposits $500
johnAccount.Withdraw(200);        // John withdraws $200
johnAccount.Transfer(janeAccount, 300);  // John transfers $300 to Jane

johnAccount.PrintStatement();
janeAccount.PrintStatement();</code></pre>
              </div>
              <div class="tab-pane fade" id="bank-account-java" role="tabpanel">
                <pre><code>import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;

public class BankAccount {
    // Static field - shared across all instances
    private static int nextAccountNumber = 1000;
    
    // Instance fields
    private String accountNumber;
    private String accountHolder;
    private double balance;
    private List<String> transactionHistory;
    
    // Getters
    public String getAccountNumber() { 
        return accountNumber; 
    }
    
    public String getAccountHolder() { 
        return accountHolder; 
    }
    
    public void setAccountHolder(String accountHolder) { 
        this.accountHolder = accountHolder; 
    }
    
    public double getBalance() { 
        return balance; 
    }
    
    // Constructor
    public BankAccount(String accountHolder, double initialDeposit) {
        this.accountNumber = "ACC" + nextAccountNumber++;
        this.accountHolder = accountHolder;
        this.balance = initialDeposit;
        this.transactionHistory = new ArrayList<>();
        
        addTransaction("Account opened with $" + initialDeposit);
    }
    
    // Methods
    public void deposit(double amount) {
        if (amount <= 0) {
            throw new IllegalArgumentException("Deposit amount must be positive");
        }
        
        balance += amount;
        addTransaction("Deposited $" + amount + ". New balance: $" + balance);
        System.out.println("Deposited $" + amount + ". Current balance: $" + balance);
    }
    
    public void withdraw(double amount) {
        if (amount <= 0) {
            throw new IllegalArgumentException("Withdrawal amount must be positive");
        }
        
        if (amount > balance) {
            throw new IllegalStateException("Insufficient funds");
        }
        
        balance -= amount;
        addTransaction("Withdrew $" + amount + ". New balance: $" + balance);
        System.out.println("Withdrew $" + amount + ". Current balance: $" + balance);
    }
    
    public void transfer(BankAccount targetAccount, double amount) {
        if (amount <= 0) {
            throw new IllegalArgumentException("Transfer amount must be positive");
        }
        
        withdraw(amount);
        targetAccount.deposit(amount);
        addTransaction("Transferred $" + amount + " to " + targetAccount.getAccountNumber());
    }
    
    public void printStatement() {
        System.out.println("\n=== Account Statement ===");
        System.out.println("Account Number: " + accountNumber);
        System.out.println("Account Holder: " + accountHolder);
        System.out.println("Current Balance: $" + balance);
        System.out.println("\nTransaction History:");
        for (String transaction : transactionHistory) {
            System.out.println("  - " + transaction);
        }
        System.out.println("========================\n");
    }
    
    private void addTransaction(String description) {
        LocalDateTime now = LocalDateTime.now();
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        String timestamp = now.format(formatter);
        transactionHistory.add("[" + timestamp + "] " + description);
    }
}

// Usage
BankAccount johnAccount = new BankAccount("John Doe", 1000);
BankAccount janeAccount = new BankAccount("Jane Smith", 500);

johnAccount.deposit(500);         // John deposits $500
johnAccount.withdraw(200);        // John withdraws $200
johnAccount.transfer(janeAccount, 300);  // John transfers $300 to Jane

johnAccount.printStatement();
janeAccount.printStatement();</code></pre>
              </div>
            </div>
          </div>

          <h2>Class Members Overview</h2>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th>Member Type</th>
                <th>Purpose</th>
                <th>Example</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Fields</strong></td>
                <td>Store data (state) of the object</td>
                <td><code>private string firstName;</code></td>
              </tr>
              <tr>
                <td><strong>Properties</strong></td>
                <td>Provide controlled access to fields</td>
                <td><code>public string Name { get; set; }</code></td>
              </tr>
              <tr>
                <td><strong>Methods</strong></td>
                <td>Define behavior and operations</td>
                <td><code>public void Deposit(decimal amount)</code></td>
              </tr>
              <tr>
                <td><strong>Constructors</strong></td>
                <td>Initialize objects when created</td>
                <td><code>public Person(string name)</code></td>
              </tr>
              <tr>
                <td><strong>Events</strong></td>
                <td>Enable notification mechanism</td>
                <td><code>public event EventHandler Changed;</code></td>
              </tr>
              <tr>
                <td><strong>Indexers</strong></td>
                <td>Allow array-like access</td>
                <td><code>public string this[int index]</code></td>
              </tr>
            </tbody>
          </table>

          <h2>Object Lifecycle</h2>
          <div class="mermaid">
sequenceDiagram
    participant Code
    participant Class
    participant Heap
    participant Object
    participant GC as Garbage Collector
    
    Code->>Class: new BankAccount("John", 1000)
    Class->>Heap: Allocate memory
    Heap->>Object: Create object instance
    Object->>Object: Run constructor
    Object-->>Code: Return reference
    
    Code->>Object: Deposit(500)
    Object->>Object: Update balance
    Object-->>Code: Operation complete
    
    Code->>Object: Reference goes out of scope
    Object->>GC: Mark for collection
    GC->>Heap: Free memory
          </div>

          <h2>Key Concepts</h2>
          
          <h3>1. The 'this' Keyword</h3>
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" id="this-keyword-csharp-tab" data-bs-toggle="tab" data-bs-target="#this-keyword-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" id="this-keyword-java-tab" data-bs-toggle="tab" data-bs-target="#this-keyword-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="this-keyword-csharp" role="tabpanel">
                <pre><code>public class Product
{
    private string name;
    private decimal price;
    
    public Product(string name, decimal price)
    {
        // 'this' refers to the current instance
        this.name = name;      // Distinguish parameter from field
        this.price = price;
    }
    
    public Product CreateDiscountedProduct(decimal discountPercent)
    {
        decimal discountedPrice = this.price * (1 - discountPercent / 100);
        return new Product(this.name + " (Discounted)", discountedPrice);
    }
    
    public void CompareWith(Product other)
    {
        if (this.price > other.price)
            Console.WriteLine($"{this.name} is more expensive than {other.name}");
        else
            Console.WriteLine($"{this.name} is cheaper than or equal to {other.name}");
    }
}</code></pre>
              </div>
              <div class="tab-pane fade" id="this-keyword-java" role="tabpanel">
                <pre><code>public class Product {
    private String name;
    private double price;
    
    public Product(String name, double price) {
        // 'this' refers to the current instance
        this.name = name;      // Distinguish parameter from field
        this.price = price;
    }
    
    public Product createDiscountedProduct(double discountPercent) {
        double discountedPrice = this.price * (1 - discountPercent / 100);
        return new Product(this.name + " (Discounted)", discountedPrice);
    }
    
    public void compareWith(Product other) {
        if (this.price > other.price)
            System.out.println(this.name + " is more expensive than " + other.name);
        else
            System.out.println(this.name + " is cheaper than or equal to " + other.name);
    }
}</code></pre>
              </div>
            </div>
          </div>

          <h3>2. Object References vs Value Types</h3>
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" id="ref-val-csharp-tab" data-bs-toggle="tab" data-bs-target="#ref-val-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" id="ref-val-java-tab" data-bs-toggle="tab" data-bs-target="#ref-val-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="ref-val-csharp" role="tabpanel">
                <pre><code>// Reference Type (Class)
Person person1 = new Person("John", "Doe", 30);
Person person2 = person1;  // Both reference same object
person2.Age = 35;
Console.WriteLine(person1.Age);  // Output: 35 (same object!)

// Value Type (Struct)
struct Point
{
    public int X { get; set; }
    public int Y { get; set; }
}

Point point1 = new Point { X = 10, Y = 20 };
Point point2 = point1;  // Creates a copy
point2.X = 30;
Console.WriteLine(point1.X);  // Output: 10 (different copy!)</code></pre>
              </div>
              <div class="tab-pane fade" id="ref-val-java" role="tabpanel">
                <pre><code>// Reference Type (Class)
Person person1 = new Person("John", "Doe", 30);
Person person2 = person1;  // Both reference same object
person2.setAge(35);
System.out.println(person1.getAge());  // Output: 35 (same object!)

// Note: Java doesn't have structs like C#
// All objects are reference types
// Primitive types (int, double, etc.) are value types

int value1 = 10;
int value2 = value1;  // Creates a copy
value2 = 30;
System.out.println(value1);  // Output: 10 (different copy!)

// To get C#-like struct behavior, create immutable classes
class Point {
    private final int x;
    private final int y;
    
    public Point(int x, int y) {
        this.x = x;
        this.y = y;
    }
    
    public int getX() { return x; }
    public int getY() { return y; }
}</code></pre>
              </div>
            </div>
          </div>

          <h3>3. Null References</h3>
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" id="null-ref-csharp-tab" data-bs-toggle="tab" data-bs-target="#null-ref-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" id="null-ref-java-tab" data-bs-toggle="tab" data-bs-target="#null-ref-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="null-ref-csharp" role="tabpanel">
                <pre><code>Person person = null;  // No object created

// Attempting to access members of null object throws NullReferenceException
// person.Introduce();  // ‚ùå Runtime error!

// Safe navigation with null-conditional operator
string name = person?.GetFullName();  // Returns null if person is null
Console.WriteLine(name ?? "Unknown");  // Output: Unknown

// Null-coalescing assignment (C# 8+)
person ??= new Person("Default", "User", 0);  // Create if null</code></pre>
              </div>
              <div class="tab-pane fade" id="null-ref-java" role="tabpanel">
                <pre><code>Person person = null;  // No object created

// Attempting to access members of null object throws NullPointerException
// person.introduce();  // ‚ùå Runtime error!

// Safe navigation using Optional (Java 8+)
import java.util.Optional;

Optional<Person> optionalPerson = Optional.ofNullable(person);
String name = optionalPerson
    .map(Person::getFullName)
    .orElse("Unknown");
System.out.println(name);  // Output: Unknown

// Null check and initialization
if (person == null) {
    person = new Person("Default", "User", 0);
}

// Or using ternary operator
person = (person != null) ? person : new Person("Default", "User", 0);</code></pre>
              </div>
            </div>
          </div>

          <h2>Class vs Object: Analogy</h2>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th>Aspect</th>
                <th>Class</th>
                <th>Object</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td>Definition</td>
                <td>Blueprint/Template</td>
                <td>Instance/Concrete entity</td>
              </tr>
              <tr>
                <td>Memory</td>
                <td>No memory allocated</td>
                <td>Memory allocated on heap</td>
              </tr>
              <tr>
                <td>Count</td>
                <td>Declared once</td>
                <td>Can create many instances</td>
              </tr>
              <tr>
                <td>Keyword</td>
                <td><code>class Person { ... }</code></td>
                <td><code>new Person()</code></td>
              </tr>
              <tr>
                <td>Analogy</td>
                <td>Cookie cutter</td>
                <td>Cookie</td>
              </tr>
              <tr>
                <td>Real-world</td>
                <td>Car blueprint</td>
                <td>Your actual car</td>
              </tr>
            </tbody>
          </table>

          <h2>Best Practices</h2>
          <ul>
            <li><strong>Single Responsibility:</strong> Each class should have one clear purpose</li>
            <li><strong>Meaningful Names:</strong> Use descriptive, noun-based names for classes</li>
            <li><strong>Encapsulation:</strong> Keep fields private, expose through properties</li>
            <li><strong>Immutability:</strong> Consider making objects immutable when appropriate</li>
            <li><strong>Initialize Properly:</strong> Use constructors to ensure objects are in valid state</li>
            <li><strong>Avoid God Classes:</strong> Don't create classes that do too much</li>
            <li><strong>Use Properties:</strong> Prefer properties over public fields for data access</li>
          </ul>

          <div class="callout">
            <strong>üí° Key Takeaway:</strong> A class is a template that defines structure and behavior, while an object 
            is a specific instance with actual data. Think of a class as a recipe and objects as the actual dishes 
            made from that recipe. Each dish (object) follows the recipe (class) but has its own unique ingredients 
            (data).
          </div>
        </section>

        <!-- Object Relationships Section -->
        <section id="relationships" role="article">
          <h1>üîó Object Relationships</h1>
          <span class="badge">associations</span>
          <span class="badge">aggregation</span>
          <span class="badge">composition</span>
          
          <h2>Understanding Object Relationships</h2>
          <p>
            In Object-Oriented Programming, objects rarely exist in isolation. They interact and relate to each other 
            in various ways to model complex real-world systems. Understanding these relationships is crucial for 
            designing maintainable and scalable applications.
          </p>

          <h2>Types of Relationships</h2>
          <div class="row g-3 mb-4">
            <div class="col-md-4">
              <div class="card border-0 shadow-sm h-100 bg-gradient-blue">
                <div class="card-body">
                  <h3>ü§ù Association</h3>
                  <p><strong>Nature:</strong> "Uses-a" or "Has-a" relationship</p>
                  <p><strong>Coupling:</strong> Loose</p>
                  <p><strong>Lifecycle:</strong> Independent objects</p>
                  <p><strong>Example:</strong> Teacher teaches Student</p>
                </div>
              </div>
            </div>
            <div class="col-md-4">
              <div class="card border-0 shadow-sm h-100 bg-gradient-yellow">
                <div class="card-body">
                  <h3>üì¶ Aggregation</h3>
                  <p><strong>Nature:</strong> "Has-a" relationship (weak)</p>
                  <p><strong>Coupling:</strong> Moderate</p>
                  <p><strong>Lifecycle:</strong> Child can exist independently</p>
                  <p><strong>Example:</strong> Department has Employees</p>
                </div>
              </div>
            </div>
            <div class="col-md-4">
              <div class="card border-0 shadow-sm h-100 bg-gradient-pink">
                <div class="card-body">
                  <h3>üß© Composition</h3>
                  <p><strong>Nature:</strong> "Part-of" relationship (strong)</p>
                  <p><strong>Coupling:</strong> Tight</p>
                  <p><strong>Lifecycle:</strong> Child cannot exist without parent</p>
                  <p><strong>Example:</strong> House has Rooms</p>
                </div>
              </div>
            </div>
          </div>

          <h2>Relationship Comparison</h2>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th>Aspect</th>
                <th>Association</th>
                <th>Aggregation</th>
                <th>Composition</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Relationship Type</strong></td>
                <td>Uses-a</td>
                <td>Has-a (weak)</td>
                <td>Part-of (strong)</td>
              </tr>
              <tr>
                <td><strong>Dependency</strong></td>
                <td>Weak</td>
                <td>Moderate</td>
                <td>Strong</td>
              </tr>
              <tr>
                <td><strong>Lifecycle</strong></td>
                <td>Independent</td>
                <td>Child can survive</td>
                <td>Child dies with parent</td>
              </tr>
              <tr>
                <td><strong>Ownership</strong></td>
                <td>No ownership</td>
                <td>Shared ownership</td>
                <td>Exclusive ownership</td>
              </tr>
              <tr>
                <td><strong>UML Symbol</strong></td>
                <td>‚Üí (line with arrow)</td>
                <td>‚óá (empty diamond)</td>
                <td>‚óÜ (filled diamond)</td>
              </tr>
              <tr>
                <td><strong>Real-world Example</strong></td>
                <td>Doctor treats Patient</td>
                <td>Library has Books</td>
                <td>Car has Engine</td>
              </tr>
            </tbody>
          </table>

          <h2>Visual Overview</h2>
          <div class="mermaid">
classDiagram
    class Teacher {
        +string Name
        +Teach(Student)
    }
    
    class Student {
        +string Name
        +Learn()
    }
    
    class Department {
        +string Name
        +List~Employee~ employees
        +AddEmployee()
    }
    
    class Employee {
        +string Name
        +Work()
    }
    
    class House {
        +string Address
        +List~Room~ rooms
        +House()
    }
    
    class Room {
        +string Name
        +double Area
    }
    
    Teacher --> Student : Association
    Department o-- Employee : Aggregation
    House *-- Room : Composition
    
    note for Teacher "Association:
    Loose coupling
    Independent lifecycle"
    note for Department "Aggregation:
    Has-a relationship
    Employees can exist
    without Department"
    note for House "Composition:
    Part-of relationship
    Rooms destroyed
    when House destroyed"
          </div>

          <h2>Choosing the Right Relationship</h2>
          <ul>
            <li><strong>Use Association when:</strong> Objects interact but are independent (e.g., Teacher-Student)</li>
            <li><strong>Use Aggregation when:</strong> One object contains another, but they can exist independently (e.g., Team-Player)</li>
            <li><strong>Use Composition when:</strong> One object is part of another and cannot exist without it (e.g., Car-Engine)</li>
          </ul>

          <div class="callout">
            <strong>üí° Key Principle:</strong> The main distinction is <strong>lifecycle dependency</strong>. In composition, 
            the child object's lifecycle is tightly bound to the parent‚Äîwhen the parent is destroyed, so are its parts. 
            In aggregation, children can outlive the parent. Association is even looser‚Äîobjects simply know about each other.
          </div>
        </section>

        <!-- Association Section -->
        <section id="association" role="article">
          <h1>ü§ù Association</h1>
          <span class="badge">relationship</span>
          <span class="badge">has-a</span>
          <span class="badge">uses-a</span>
          
          <h2>What is Association?</h2>
          <p>
            <strong>Association</strong> represents a relationship between two classes where one class uses or interacts with 
            another. It's the most general form of relationship, indicating that objects of one class are connected to objects 
            of another class. Both objects have independent lifecycles.
          </p>

          <h2>Characteristics</h2>
          <ul>
            <li><strong>Loose Coupling:</strong> Objects are independent and can exist without each other</li>
            <li><strong>No Ownership:</strong> Neither object owns the other</li>
            <li><strong>Bidirectional or Unidirectional:</strong> Can navigate from A to B, or both ways</li>
            <li><strong>Multiplicity:</strong> Can be one-to-one, one-to-many, or many-to-many</li>
          </ul>

          <h2>Example 1: Teacher and Student (Unidirectional)</h2>
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" id="assoc-teacher-csharp-tab" data-bs-toggle="tab" data-bs-target="#assoc-teacher-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" id="assoc-teacher-java-tab" data-bs-toggle="tab" data-bs-target="#assoc-teacher-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="assoc-teacher-csharp" role="tabpanel">
                <pre><code>public class Student
{
    public string Name { get; set; }
    public int RollNumber { get; set; }
    
    public Student(string name, int rollNumber)
    {
        Name = name;
        RollNumber = rollNumber;
    }
    
    public void Learn(string subject)
    {
        Console.WriteLine($"{Name} is learning {subject}");
    }
}

public class Teacher
{
    public string Name { get; set; }
    public string Subject { get; set; }
    
    public Teacher(string name, string subject)
    {
        Name = name;
        Subject = subject;
    }
    
    // Association - Teacher uses Student
    public void Teach(Student student)
    {
        Console.WriteLine($"{Name} is teaching {Subject} to {student.Name}");
        student.Learn(Subject);
    }
}

// Usage
Student student1 = new Student("Alice", 101);
Student student2 = new Student("Bob", 102);

Teacher teacher = new Teacher("Mr. Smith", "Mathematics");

teacher.Teach(student1);  // Teacher teaches student
teacher.Teach(student2);  // Same teacher, different student

// Both Teacher and Student exist independently
// Destroying teacher doesn't affect students</code></pre>
              </div>
              <div class="tab-pane fade" id="assoc-teacher-java" role="tabpanel">
                <pre><code>public class Student {
    private String name;
    private int rollNumber;
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public int getRollNumber() { return rollNumber; }
    public void setRollNumber(int rollNumber) { this.rollNumber = rollNumber; }
    
    public Student(String name, int rollNumber) {
        this.name = name;
        this.rollNumber = rollNumber;
    }
    
    public void learn(String subject) {
        System.out.println(name + " is learning " + subject);
    }
}

public class Teacher {
    private String name;
    private String subject;
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public String getSubject() { return subject; }
    public void setSubject(String subject) { this.subject = subject; }
    
    public Teacher(String name, String subject) {
        this.name = name;
        this.subject = subject;
    }
    
    // Association - Teacher uses Student
    public void teach(Student student) {
        System.out.println(name + " is teaching " + subject + " to " + student.getName());
        student.learn(subject);
    }
}

// Usage
Student student1 = new Student("Alice", 101);
Student student2 = new Student("Bob", 102);

Teacher teacher = new Teacher("Mr. Smith", "Mathematics");

teacher.teach(student1);  // Teacher teaches student
teacher.teach(student2);  // Same teacher, different student

// Both Teacher and Student exist independently
// Destroying teacher doesn't affect students</code></pre>
              </div>
            </div>
          </div>

          <h2>Example 2: Doctor and Patient (Bidirectional)</h2>
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" id="assoc-doctor-csharp-tab" data-bs-toggle="tab" data-bs-target="#assoc-doctor-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" id="assoc-doctor-java-tab" data-bs-toggle="tab" data-bs-target="#assoc-doctor-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="assoc-doctor-csharp" role="tabpanel">
                <pre><code>public class Patient
{
    public string Name { get; set; }
    public string PatientId { get; set; }
    public List<Doctor> Doctors { get; set; }  // Can have multiple doctors
    
    public Patient(string name, string patientId)
    {
        Name = name;
        PatientId = patientId;
        Doctors = new List<Doctor>();
    }
    
    public void RegisterDoctor(Doctor doctor)
    {
        if (!Doctors.Contains(doctor))
        {
            Doctors.Add(doctor);
            doctor.RegisterPatient(this);  // Bidirectional
        }
    }
}

public class Doctor
{
    public string Name { get; set; }
    public string Specialization { get; set; }
    public List<Patient> Patients { get; set; }  // Can have multiple patients
    
    public Doctor(string name, string specialization)
    {
        Name = name;
        Specialization = specialization;
        Patients = new List<Patient>();
    }
    
    public void RegisterPatient(Patient patient)
    {
        if (!Patients.Contains(patient))
        {
            Patients.Add(patient);
            patient.RegisterDoctor(this);  // Bidirectional
        }
    }
    
    public void Treat(Patient patient)
    {
        if (Patients.Contains(patient))
        {
            Console.WriteLine($"Dr. {Name} ({Specialization}) is treating {patient.Name}");
        }
        else
        {
            Console.WriteLine($"{patient.Name} is not registered with Dr. {Name}");
        }
    }
}

// Usage - Many-to-Many Association
Patient patient1 = new Patient("John Doe", "P001");
Patient patient2 = new Patient("Jane Smith", "P002");

Doctor doctor1 = new Doctor("Dr. Brown", "Cardiology");
Doctor doctor2 = new Doctor("Dr. Wilson", "Neurology");

// Register relationships
patient1.RegisterDoctor(doctor1);
patient1.RegisterDoctor(doctor2);  // One patient, multiple doctors
patient2.RegisterDoctor(doctor1);  // One doctor, multiple patients

doctor1.Treat(patient1);
doctor2.Treat(patient1);</code></pre>
              </div>
              <div class="tab-pane fade" id="assoc-doctor-java" role="tabpanel">
                <pre><code>import java.util.ArrayList;
import java.util.List;

public class Patient {
    private String name;
    private String patientId;
    private List<Doctor> doctors;  // Can have multiple doctors
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public String getPatientId() { return patientId; }
    public void setPatientId(String patientId) { this.patientId = patientId; }
    public List<Doctor> getDoctors() { return doctors; }
    
    public Patient(String name, String patientId) {
        this.name = name;
        this.patientId = patientId;
        this.doctors = new ArrayList<>();
    }
    
    public void registerDoctor(Doctor doctor) {
        if (!doctors.contains(doctor)) {
            doctors.add(doctor);
            doctor.registerPatient(this);  // Bidirectional
        }
    }
}

public class Doctor {
    private String name;
    private String specialization;
    private List<Patient> patients;  // Can have multiple patients
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public String getSpecialization() { return specialization; }
    public void setSpecialization(String specialization) { this.specialization = specialization; }
    public List<Patient> getPatients() { return patients; }
    
    public Doctor(String name, String specialization) {
        this.name = name;
        this.specialization = specialization;
        this.patients = new ArrayList<>();
    }
    
    public void registerPatient(Patient patient) {
        if (!patients.contains(patient)) {
            patients.add(patient);
            patient.registerDoctor(this);  // Bidirectional
        }
    }
    
    public void treat(Patient patient) {
        if (patients.contains(patient)) {
            System.out.println("Dr. " + name + " (" + specialization + ") is treating " + patient.getName());
        } else {
            System.out.println(patient.getName() + " is not registered with Dr. " + name);
        }
    }
}

// Usage - Many-to-Many Association
Patient patient1 = new Patient("John Doe", "P001");
Patient patient2 = new Patient("Jane Smith", "P002");

Doctor doctor1 = new Doctor("Dr. Brown", "Cardiology");
Doctor doctor2 = new Doctor("Dr. Wilson", "Neurology");

// Register relationships
patient1.registerDoctor(doctor1);
patient1.registerDoctor(doctor2);  // One patient, multiple doctors
patient2.registerDoctor(doctor1);  // One doctor, multiple patients

doctor1.treat(patient1);
doctor2.treat(patient1);</code></pre>
              </div>
            </div>
          </div>

          <h2>Association Visualization</h2>
          <div class="mermaid">
classDiagram
    class Teacher {
        +string Name
        +string Subject
        +Teach(Student)
    }
    
    class Student {
        +string Name
        +int RollNumber
        +Learn(string)
    }
    
    class Doctor {
        +string Name
        +string Specialization
        +List~Patient~ Patients
        +RegisterPatient(Patient)
        +Treat(Patient)
    }
    
    class Patient {
        +string Name
        +string PatientId
        +List~Doctor~ Doctors
        +RegisterDoctor(Doctor)
    }
    
    Teacher --> Student : teaches (unidirectional)
    Doctor "1..*" <--> "1..*" Patient : treats (bidirectional)
          </div>

          <h2>Real-World Scenarios</h2>
          <ul>
            <li><strong>Customer and Order:</strong> Customer places orders, but both exist independently</li>
            <li><strong>Driver and Car:</strong> Driver drives a car, but the car exists without the driver</li>
            <li><strong>Author and Book:</strong> Author writes books, books can exist after author</li>
            <li><strong>Employee and Project:</strong> Employees work on projects, many-to-many relationship</li>
          </ul>

          <div class="callout">
            <strong>üí° Key Point:</strong> Association represents a "uses-a" or "knows-a" relationship. Objects are 
            loosely coupled and have independent lifecycles. Use association when objects need to interact but should 
            remain independent.
          </div>
        </section>

        <!-- Aggregation Section -->
        <section id="aggregation" role="article">
          <h1>üì¶ Aggregation</h1>
          <span class="badge">relationship</span>
          <span class="badge">whole-part</span>
          <span class="badge">weak</span>
          
          <h2>What is Aggregation?</h2>
          <p>
            <strong>Aggregation</strong> is a specialized form of association representing a "has-a" relationship where one object 
            (the whole) contains references to other objects (the parts), but the parts can exist independently of the whole. 
            It's a <strong>weak ownership</strong> relationship.
          </p>

          <h2>Characteristics</h2>
          <ul>
            <li><strong>Whole-Part Relationship:</strong> Container has components, but doesn't own them exclusively</li>
            <li><strong>Independent Lifecycle:</strong> Parts can exist without the container</li>
            <li><strong>Shared Ownership:</strong> Parts can belong to multiple containers</li>
            <li><strong>Dynamic Association:</strong> Parts can be added or removed from the container</li>
          </ul>

          <h2>Example 1: Department and Employees</h2>
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" id="aggr-dept-csharp-tab" data-bs-toggle="tab" data-bs-target="#aggr-dept-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" id="aggr-dept-java-tab" data-bs-toggle="tab" data-bs-target="#aggr-dept-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="aggr-dept-csharp" role="tabpanel">
                <pre><code>public class Employee
{
    public string Name { get; set; }
    public string EmployeeId { get; set; }
    public string Position { get; set; }
    
    public Employee(string name, string employeeId, string position)
    {
        Name = name;
        EmployeeId = employeeId;
        Position = position;
    }
    
    public void Work()
    {
        Console.WriteLine($"{Name} ({Position}) is working...");
    }
}

public class Department
{
    public string Name { get; set; }
    private List<Employee> employees;
    
    public Department(string name)
    {
        Name = name;
        employees = new List<Employee>();
    }
    
    // Aggregation - Department has employees
    public void AddEmployee(Employee employee)
    {
        if (!employees.Contains(employee))
        {
            employees.Add(employee);
            Console.WriteLine($"{employee.Name} added to {Name} department");
        }
    }
    
    public void RemoveEmployee(Employee employee)
    {
        if (employees.Remove(employee))
        {
            Console.WriteLine($"{employee.Name} removed from {Name} department");
            // Employee still exists after removal!
        }
    }
    
    public void ListEmployees()
    {
        Console.WriteLine($"\nEmployees in {Name} Department:");
        foreach (var emp in employees)
        {
            Console.WriteLine($"  - {emp.Name} ({emp.Position})");
        }
    }
}

// Usage
Employee emp1 = new Employee("Alice Johnson", "E001", "Developer");
Employee emp2 = new Employee("Bob Smith", "E002", "Designer");
Employee emp3 = new Employee("Carol White", "E003", "Manager");

Department itDept = new Department("IT");
Department hrDept = new Department("HR");

itDept.AddEmployee(emp1);
itDept.AddEmployee(emp2);
hrDept.AddEmployee(emp3);

itDept.ListEmployees();

// Remove employee from department
itDept.RemoveEmployee(emp1);

// Employee still exists and can work
emp1.Work();  // ‚úÖ Employee exists independently!</code></pre>
              </div>
              <div class="tab-pane fade" id="aggr-dept-java" role="tabpanel">
                <pre><code>import java.util.ArrayList;
import java.util.List;

public class Employee {
    private String name;
    private String employeeId;
    private String position;
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public String getEmployeeId() { return employeeId; }
    public void setEmployeeId(String employeeId) { this.employeeId = employeeId; }
    public String getPosition() { return position; }
    public void setPosition(String position) { this.position = position; }
    
    public Employee(String name, String employeeId, String position) {
        this.name = name;
        this.employeeId = employeeId;
        this.position = position;
    }
    
    public void work() {
        System.out.println(name + " (" + position + ") is working...");
    }
}

public class Department {
    private String name;
    private List<Employee> employees;
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public Department(String name) {
        this.name = name;
        this.employees = new ArrayList<>();
    }
    
    // Aggregation - Department has employees
    public void addEmployee(Employee employee) {
        if (!employees.contains(employee)) {
            employees.add(employee);
            System.out.println(employee.getName() + " added to " + name + " department");
        }
    }
    
    public void removeEmployee(Employee employee) {
        if (employees.remove(employee)) {
            System.out.println(employee.getName() + " removed from " + name + " department");
            // Employee still exists after removal!
        }
    }
    
    public void listEmployees() {
        System.out.println("\nEmployees in " + name + " Department:");
        for (Employee emp : employees) {
            System.out.println("  - " + emp.getName() + " (" + emp.getPosition() + ")");
        }
    }
}

// Usage
Employee emp1 = new Employee("Alice Johnson", "E001", "Developer");
Employee emp2 = new Employee("Bob Smith", "E002", "Designer");
Employee emp3 = new Employee("Carol White", "E003", "Manager");

Department itDept = new Department("IT");
Department hrDept = new Department("HR");

itDept.addEmployee(emp1);
itDept.addEmployee(emp2);
hrDept.addEmployee(emp3);

itDept.listEmployees();

// Remove employee from department
itDept.removeEmployee(emp1);

// Employee still exists and can work
emp1.work();  // ‚úÖ Employee exists independently!</code></pre>
              </div>
            </div>
          </div>

          <h2>Example 2: University and Students</h2>
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" id="aggr-univ-csharp-tab" data-bs-toggle="tab" data-bs-target="#aggr-univ-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" id="aggr-univ-java-tab" data-bs-toggle="tab" data-bs-target="#aggr-univ-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="aggr-univ-csharp" role="tabpanel">
                <pre><code>public class Student
{
    public string Name { get; set; }
    public string StudentId { get; set; }
    public string Major { get; set; }
    
    public Student(string name, string studentId, string major)
    {
        Name = name;
        StudentId = studentId;
        Major = major;
    }
    
    public void Study()
    {
        Console.WriteLine($"{Name} is studying {Major}");
    }
}

public class University
{
    public string Name { get; set; }
    public string Location { get; set; }
    private List<Student> students;
    
    public University(string name, string location)
    {
        Name = name;
        Location = location;
        students = new List<Student>();
    }
    
    public void EnrollStudent(Student student)
    {
        students.Add(student);
        Console.WriteLine($"{student.Name} enrolled at {Name}");
    }
    
    public void GraduateStudent(Student student)
    {
        if (students.Remove(student))
        {
            Console.WriteLine($"{student.Name} graduated from {Name}");
            // Student continues to exist after graduation
        }
    }
    
    public void PrintStudentList()
    {
        Console.WriteLine($"\nStudents at {Name}:");
        foreach (var student in students)
        {
            Console.WriteLine($"  - {student.Name} ({student.Major})");
        }
    }
}

// Usage
Student student1 = new Student("Emma Davis", "S001", "Computer Science");
Student student2 = new Student("Michael Brown", "S002", "Engineering");

University university = new University("Tech University", "New York");

university.EnrollStudent(student1);
university.EnrollStudent(student2);
university.PrintStudentList();

// Student graduates but still exists
university.GraduateStudent(student1);
student1.Study();  // ‚úÖ Student can still study after leaving university</code></pre>
              </div>
              <div class="tab-pane fade" id="aggr-univ-java" role="tabpanel">
                <pre><code>import java.util.ArrayList;
import java.util.List;

public class Student {
    private String name;
    private String studentId;
    private String major;
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public String getStudentId() { return studentId; }
    public void setStudentId(String studentId) { this.studentId = studentId; }
    public String getMajor() { return major; }
    public void setMajor(String major) { this.major = major; }
    
    public Student(String name, String studentId, String major) {
        this.name = name;
        this.studentId = studentId;
        this.major = major;
    }
    
    public void study() {
        System.out.println(name + " is studying " + major);
    }
}

public class University {
    private String name;
    private String location;
    private List<Student> students;
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public String getLocation() { return location; }
    public void setLocation(String location) { this.location = location; }
    
    public University(String name, String location) {
        this.name = name;
        this.location = location;
        this.students = new ArrayList<>();
    }
    
    public void enrollStudent(Student student) {
        students.add(student);
        System.out.println(student.getName() + " enrolled at " + name);
    }
    
    public void graduateStudent(Student student) {
        if (students.remove(student)) {
            System.out.println(student.getName() + " graduated from " + name);
            // Student continues to exist after graduation
        }
    }
    
    public void printStudentList() {
        System.out.println("\nStudents at " + name + ":");
        for (Student student : students) {
            System.out.println("  - " + student.getName() + " (" + student.getMajor() + ")");
        }
    }
}

// Usage
Student student1 = new Student("Emma Davis", "S001", "Computer Science");
Student student2 = new Student("Michael Brown", "S002", "Engineering");

University university = new University("Tech University", "New York");

university.enrollStudent(student1);
university.enrollStudent(student2);
university.printStudentList();

// Student graduates but still exists
university.graduateStudent(student1);
student1.study();  // ‚úÖ Student can still study after leaving university</code></pre>
              </div>
            </div>
          </div>

          <h2>Example 3: Library and Books (Shared Aggregation)</h2>
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" id="aggr-lib-csharp-tab" data-bs-toggle="tab" data-bs-target="#aggr-lib-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" id="aggr-lib-java-tab" data-bs-toggle="tab" data-bs-target="#aggr-lib-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="aggr-lib-csharp" role="tabpanel">
                <pre><code>public class Book
{
    public string Title { get; set; }
    public string ISBN { get; set; }
    public string Author { get; set; }
    
    public Book(string title, string isbn, string author)
    {
        Title = title;
        ISBN = isbn;
        Author = author;
    }
}

public class Library
{
    public string Name { get; set; }
    private List<Book> books;
    
    public Library(string name)
    {
        Name = name;
        books = new List<Book>();
    }
    
    public void AddBook(Book book)
    {
        books.Add(book);
        Console.WriteLine($"{book.Title} added to {Name}");
    }
    
    public void RemoveBook(Book book)
    {
        if (books.Remove(book))
        {
            Console.WriteLine($"{book.Title} removed from {Name}");
        }
    }
    
    public void ListBooks()
    {
        Console.WriteLine($"\nBooks in {Name}:");
        foreach (var book in books)
        {
            Console.WriteLine($"  - {book.Title} by {book.Author}");
        }
    }
}

// Usage
Book book1 = new Book("Clean Code", "978-0132350884", "Robert C. Martin");
Book book2 = new Book("Design Patterns", "978-0201633610", "Gang of Four");

Library publicLibrary = new Library("Public Library");
Library universityLibrary = new Library("University Library");

// Same book can be in multiple libraries (shared aggregation)
publicLibrary.AddBook(book1);
universityLibrary.AddBook(book1);
publicLibrary.AddBook(book2);

// If one library closes, books still exist
publicLibrary = null;
Console.WriteLine($"Book still exists: {book1.Title}");  // ‚úÖ</code></pre>
              </div>
              <div class="tab-pane fade" id="aggr-lib-java" role="tabpanel">
                <pre><code>import java.util.ArrayList;
import java.util.List;

public class Book {
    private String title;
    private String isbn;
    private String author;
    
    public String getTitle() { return title; }
    public void setTitle(String title) { this.title = title; }
    public String getIsbn() { return isbn; }
    public void setIsbn(String isbn) { this.isbn = isbn; }
    public String getAuthor() { return author; }
    public void setAuthor(String author) { this.author = author; }
    
    public Book(String title, String isbn, String author) {
        this.title = title;
        this.isbn = isbn;
        this.author = author;
    }
}

public class Library {
    private String name;
    private List<Book> books;
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    public Library(String name) {
        this.name = name;
        this.books = new ArrayList<>();
    }
    
    public void addBook(Book book) {
        books.add(book);
        System.out.println(book.getTitle() + " added to " + name);
    }
    
    public void removeBook(Book book) {
        if (books.remove(book)) {
            System.out.println(book.getTitle() + " removed from " + name);
        }
    }
    
    public void listBooks() {
        System.out.println("\nBooks in " + name + ":");
        for (Book book : books) {
            System.out.println("  - " + book.getTitle() + " by " + book.getAuthor());
        }
    }
}

// Usage
Book book1 = new Book("Clean Code", "978-0132350884", "Robert C. Martin");
Book book2 = new Book("Design Patterns", "978-0201633610", "Gang of Four");

Library publicLibrary = new Library("Public Library");
Library universityLibrary = new Library("University Library");

// Same book can be in multiple libraries (shared aggregation)
publicLibrary.addBook(book1);
universityLibrary.addBook(book1);
publicLibrary.addBook(book2);

// If one library closes, books still exist
publicLibrary = null;
System.out.println("Book still exists: " + book1.getTitle());  // ‚úÖ</code></pre>
              </div>
            </div>
          </div>

          <h2>Aggregation Visualization</h2>
          <div class="mermaid">
classDiagram
    class Department {
        +string Name
        -List~Employee~ employees
        +AddEmployee(Employee)
        +RemoveEmployee(Employee)
        +ListEmployees()
    }
    
    class Employee {
        +string Name
        +string EmployeeId
        +string Position
        +Work()
    }
    
    class Library {
        +string Name
        -List~Book~ books
        +AddBook(Book)
        +RemoveBook(Book)
    }
    
    class Book {
        +string Title
        +string ISBN
        +string Author
    }
    
    Department o-- Employee : has (aggregation)
    Library o-- Book : contains (aggregation)
    
    note for Department "Employees can exist\nindependently of\nDepartment"
    note for Library "Books can exist\nin multiple libraries\nor without any library"
          </div>

          <h2>Aggregation vs Association</h2>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th>Aspect</th>
                <th>Association</th>
                <th>Aggregation</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Relationship</strong></td>
                <td>Uses-a, Knows-a</td>
                <td>Has-a (container)</td>
              </tr>
              <tr>
                <td><strong>Ownership</strong></td>
                <td>No ownership</td>
                <td>Weak ownership</td>
              </tr>
              <tr>
                <td><strong>Lifecycle</strong></td>
                <td>Completely independent</td>
                <td>Parts can survive container</td>
              </tr>
              <tr>
                <td><strong>Example</strong></td>
                <td>Teacher teaches Student</td>
                <td>Department has Employees</td>
              </tr>
            </tbody>
          </table>

          <div class="callout">
            <strong>üí° Key Principle:</strong> Use aggregation when you have a container-component relationship where 
            the components have meaning and can exist independently of the container. Think "has-a" with shared or 
            weak ownership‚Äîlike a playlist has songs, but songs exist without the playlist.
          </div>
        </section>

        <!-- Composition Section -->
        <section id="composition" role="article">
          <h1>üß© Composition</h1>
          <span class="badge">relationship</span>
          <span class="badge">strong</span>
          <span class="badge">lifecycle</span>
          
          <h2>What is Composition?</h2>
          <p>
            <strong>Composition</strong> is a strong form of aggregation representing a "part-of" relationship where the parts 
            cannot exist independently of the whole. When the container is destroyed, all its parts are also destroyed. 
            It's a <strong>strong ownership</strong> relationship.
          </p>

          <h2>Characteristics</h2>
          <ul>
            <li><strong>Strong Ownership:</strong> Parent exclusively owns the child objects</li>
            <li><strong>Dependent Lifecycle:</strong> Children cannot exist without the parent</li>
            <li><strong>Part-of Relationship:</strong> Parts are integral components of the whole</li>
            <li><strong>Encapsulation:</strong> Parts are typically created and managed internally</li>
          </ul>

          <h2>Example 1: House and Rooms</h2>
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" id="comp-house-csharp-tab" data-bs-toggle="tab" data-bs-target="#comp-house-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" id="comp-house-java-tab" data-bs-toggle="tab" data-bs-target="#comp-house-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="comp-house-csharp" role="tabpanel">
                <pre><code>public class Room
{
    public string Name { get; set; }
    public double Area { get; set; }
    
    // Rooms are created as part of House, not independently
    internal Room(string name, double area)
    {
        Name = name;
        Area = area;
        Console.WriteLine($"Room '{Name}' created ({Area} sq ft)");
    }
}

public class House
{
    public string Address { get; set; }
    private List<Room> rooms;  // Composition - House owns rooms
    
    public House(string address)
    {
        Address = address;
        rooms = new List<Room>();
        
        // Rooms are created when House is created
        rooms.Add(new Room("Living Room", 300));
        rooms.Add(new Room("Kitchen", 200));
        rooms.Add(new Room("Bedroom", 250));
        rooms.Add(new Room("Bathroom", 100));
        
        Console.WriteLine($"House created at {Address}\n");
    }
    
    public void ListRooms()
    {
        Console.WriteLine($"Rooms in house at {Address}:");
        foreach (var room in rooms)
        {
            Console.WriteLine($"  - {room.Name}: {room.Area} sq ft");
        }
    }
    
    // When House is destroyed, all rooms are destroyed
    ~House()
    {
        Console.WriteLine($"House at {Address} is being demolished.");
        Console.WriteLine("All rooms are destroyed with the house.");
    }
}

// Usage
House myHouse = new House("123 Main Street");
myHouse.ListRooms();

// When myHouse is destroyed or goes out of scope,
// all its rooms are automatically destroyed too
myHouse = null;
GC.Collect();  // Force garbage collection to demonstrate
// Output: House and all rooms are destroyed together</code></pre>
              </div>
              <div class="tab-pane fade" id="comp-house-java" role="tabpanel">
                <pre><code>import java.util.ArrayList;
import java.util.List;

class Room {
    private String name;
    private double area;
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    public double getArea() { return area; }
    public void setArea(double area) { this.area = area; }
    
    // Rooms are created as part of House, not independently
    Room(String name, double area) {
        this.name = name;
        this.area = area;
        System.out.println("Room '" + name + "' created (" + area + " sq ft)");
    }
}

public class House {
    private String address;
    private List<Room> rooms;  // Composition - House owns rooms
    
    public String getAddress() { return address; }
    public void setAddress(String address) { this.address = address; }
    
    public House(String address) {
        this.address = address;
        this.rooms = new ArrayList<>();
        
        // Rooms are created when House is created
        rooms.add(new Room("Living Room", 300));
        rooms.add(new Room("Kitchen", 200));
        rooms.add(new Room("Bedroom", 250));
        rooms.add(new Room("Bathroom", 100));
        
        System.out.println("House created at " + address + "\n");
    }
    
    public void listRooms() {
        System.out.println("Rooms in house at " + address + ":");
        for (Room room : rooms) {
            System.out.println("  - " + room.getName() + ": " + room.getArea() + " sq ft");
        }
    }
    
    // When House is destroyed, all rooms are destroyed
    @Override
    protected void finalize() {
        System.out.println("House at " + address + " is being demolished.");
        System.out.println("All rooms are destroyed with the house.");
    }
}

// Usage
House myHouse = new House("123 Main Street");
myHouse.listRooms();

// When myHouse is destroyed or goes out of scope,
// all its rooms are automatically destroyed too
myHouse = null;
System.gc();  // Force garbage collection to demonstrate
// Output: House and all rooms are destroyed together</code></pre>
              </div>
            </div>
          </div>

          <h2>Example 2: Car and Engine</h2>
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" id="comp-car-csharp-tab" data-bs-toggle="tab" data-bs-target="#comp-car-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" id="comp-car-java-tab" data-bs-toggle="tab" data-bs-target="#comp-car-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="comp-car-csharp" role="tabpanel">
                <pre><code>public class Engine
{
    public string Type { get; set; }
    public int Horsepower { get; set; }
    
    internal Engine(string type, int horsepower)
    {
        Type = type;
        Horsepower = horsepower;
        Console.WriteLine($"Engine created: {Type} ({Horsepower} HP)");
    }
    
    public void Start()
    {
        Console.WriteLine($"{Type} engine started.");
    }
    
    public void Stop()
    {
        Console.WriteLine($"{Type} engine stopped.");
    }
}

public class Transmission
{
    public string Type { get; set; }
    public int Gears { get; set; }
    
    internal Transmission(string type, int gears)
    {
        Type = type;
        Gears = gears;
        Console.WriteLine($"Transmission created: {Type} ({Gears} gears)");
    }
}

public class Car
{
    public string Brand { get; set; }
    public string Model { get; set; }
    
    // Composition - Car owns engine and transmission
    private Engine engine;
    private Transmission transmission;
    
    public Car(string brand, string model)
    {
        Brand = brand;
        Model = model;
        
        // Components are created as part of Car
        engine = new Engine("V6 Turbo", 300);
        transmission = new Transmission("Automatic", 8);
        
        Console.WriteLine($"{Brand} {Model} assembled\n");
    }
    
    public void Start()
    {
        Console.WriteLine($"Starting {Brand} {Model}...");
        engine.Start();
    }
    
    public void Stop()
    {
        engine.Stop();
        Console.WriteLine($"{Brand} {Model} stopped.\n");
    }
    
    // When Car is destroyed, Engine and Transmission are destroyed
    ~Car()
    {
        Console.WriteLine($"{Brand} {Model} is being scrapped.");
        Console.WriteLine("Engine and transmission destroyed with the car.");
    }
}

// Usage
Car myCar = new Car("Toyota", "Camry");
myCar.Start();
myCar.Stop();

// When car is destroyed, engine and transmission are destroyed too
myCar = null;
GC.Collect();</code></pre>
              </div>
              <div class="tab-pane fade" id="comp-car-java" role="tabpanel">
                <pre><code>class Engine {
    private String type;
    private int horsepower;
    
    public String getType() { return type; }
    public void setType(String type) { this.type = type; }
    public int getHorsepower() { return horsepower; }
    public void setHorsepower(int horsepower) { this.horsepower = horsepower; }
    
    Engine(String type, int horsepower) {
        this.type = type;
        this.horsepower = horsepower;
        System.out.println("Engine created: " + type + " (" + horsepower + " HP)");
    }
    
    public void start() {
        System.out.println(type + " engine started.");
    }
    
    public void stop() {
        System.out.println(type + " engine stopped.");
    }
}

class Transmission {
    private String type;
    private int gears;
    
    public String getType() { return type; }
    public void setType(String type) { this.type = type; }
    public int getGears() { return gears; }
    public void setGears(int gears) { this.gears = gears; }
    
    Transmission(String type, int gears) {
        this.type = type;
        this.gears = gears;
        System.out.println("Transmission created: " + type + " (" + gears + " gears)");
    }
}

public class Car {
    private String brand;
    private String model;
    
    // Composition - Car owns engine and transmission
    private Engine engine;
    private Transmission transmission;
    
    public String getBrand() { return brand; }
    public void setBrand(String brand) { this.brand = brand; }
    public String getModel() { return model; }
    public void setModel(String model) { this.model = model; }
    
    public Car(String brand, String model) {
        this.brand = brand;
        this.model = model;
        
        // Components are created as part of Car
        this.engine = new Engine("V6 Turbo", 300);
        this.transmission = new Transmission("Automatic", 8);
        
        System.out.println(brand + " " + model + " assembled\n");
    }
    
    public void start() {
        System.out.println("Starting " + brand + " " + model + "...");
        engine.start();
    }
    
    public void stop() {
        engine.stop();
        System.out.println(brand + " " + model + " stopped.\n");
    }
    
    // When Car is destroyed, Engine and Transmission are destroyed
    @Override
    protected void finalize() {
        System.out.println(brand + " " + model + " is being scrapped.");
        System.out.println("Engine and transmission destroyed with the car.");
    }
}

// Usage
Car myCar = new Car("Toyota", "Camry");
myCar.start();
myCar.stop();

// When car is destroyed, engine and transmission are destroyed too
myCar = null;
System.gc();</code></pre>
              </div>
            </div>
          </div>

          <h2>Example 3: Order and OrderItems</h2>
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" id="comp-order-csharp-tab" data-bs-toggle="tab" data-bs-target="#comp-order-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" id="comp-order-java-tab" data-bs-toggle="tab" data-bs-target="#comp-order-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="comp-order-csharp" role="tabpanel">
                <pre><code>public class OrderItem
{
    public string ProductName { get; set; }
    public int Quantity { get; set; }
    public decimal Price { get; set; }
    
    public decimal Subtotal => Quantity * Price;
    
    internal OrderItem(string productName, int quantity, decimal price)
    {
        ProductName = productName;
        Quantity = quantity;
        Price = price;
    }
}

public class Order
{
    public string OrderId { get; set; }
    public DateTime OrderDate { get; set; }
    public string CustomerName { get; set; }
    
    // Composition - Order owns OrderItems
    private List<OrderItem> items;
    
    public decimal Total
    {
        get { return items.Sum(item => item.Subtotal); }
    }
    
    public Order(string orderId, string customerName)
    {
        OrderId = orderId;
        CustomerName = customerName;
        OrderDate = DateTime.Now;
        items = new List<OrderItem>();
    }
    
    // Create items as part of the order
    public void AddItem(string productName, int quantity, decimal price)
    {
        var item = new OrderItem(productName, quantity, price);
        items.Add(item);
        Console.WriteLine($"Added: {quantity}x {productName} @ ${price} each");
    }
    
    public void PrintOrder()
    {
        Console.WriteLine($"\n===== Order #{OrderId} =====");
        Console.WriteLine($"Customer: {CustomerName}");
        Console.WriteLine($"Date: {OrderDate:yyyy-MM-dd HH:mm}");
        Console.WriteLine($"\nItems:");
        
        foreach (var item in items)
        {
            Console.WriteLine($"  {item.Quantity}x {item.ProductName} - ${item.Subtotal:F2}");
        }
        
        Console.WriteLine($"\nTotal: ${Total:F2}");
        Console.WriteLine("========================\n");
    }
    
    // When Order is cancelled/deleted, all OrderItems are deleted
    public void CancelOrder()
    {
        Console.WriteLine($"Order #{OrderId} cancelled.");
        items.Clear();  // All items are destroyed
        Console.WriteLine("All order items removed.\n");
    }
}

// Usage
Order order = new Order("ORD001", "John Doe");
order.AddItem("Laptop", 1, 1200.00m);
order.AddItem("Mouse", 2, 25.00m);
order.AddItem("Keyboard", 1, 75.00m);

order.PrintOrder();

// OrderItems cannot exist without the Order
order.CancelOrder();  // Order and all items are destroyed together</code></pre>
              </div>
              <div class="tab-pane fade" id="comp-order-java" role="tabpanel">
                <pre><code>import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;

class OrderItem {
    private String productName;
    private int quantity;
    private double price;
    
    public String getProductName() { return productName; }
    public void setProductName(String productName) { this.productName = productName; }
    public int getQuantity() { return quantity; }
    public void setQuantity(int quantity) { this.quantity = quantity; }
    public double getPrice() { return price; }
    public void setPrice(double price) { this.price = price; }
    
    public double getSubtotal() {
        return quantity * price;
    }
    
    OrderItem(String productName, int quantity, double price) {
        this.productName = productName;
        this.quantity = quantity;
        this.price = price;
    }
}

public class Order {
    private String orderId;
    private LocalDateTime orderDate;
    private String customerName;
    
    // Composition - Order owns OrderItems
    private List<OrderItem> items;
    
    public String getOrderId() { return orderId; }
    public void setOrderId(String orderId) { this.orderId = orderId; }
    public LocalDateTime getOrderDate() { return orderDate; }
    public void setOrderDate(LocalDateTime orderDate) { this.orderDate = orderDate; }
    public String getCustomerName() { return customerName; }
    public void setCustomerName(String customerName) { this.customerName = customerName; }
    
    public double getTotal() {
        return items.stream().mapToDouble(OrderItem::getSubtotal).sum();
    }
    
    public Order(String orderId, String customerName) {
        this.orderId = orderId;
        this.customerName = customerName;
        this.orderDate = LocalDateTime.now();
        this.items = new ArrayList<>();
    }
    
    // Create items as part of the order
    public void addItem(String productName, int quantity, double price) {
        OrderItem item = new OrderItem(productName, quantity, price);
        items.add(item);
        System.out.println("Added: " + quantity + "x " + productName + " @ $" + price + " each");
    }
    
    public void printOrder() {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm");
        System.out.println("\n===== Order #" + orderId + " =====");
        System.out.println("Customer: " + customerName);
        System.out.println("Date: " + orderDate.format(formatter));
        System.out.println("\nItems:");
        
        for (OrderItem item : items) {
            System.out.printf("  %dx %s - $%.2f%n", 
                item.getQuantity(), item.getProductName(), item.getSubtotal());
        }
        
        System.out.printf("\nTotal: $%.2f%n", getTotal());
        System.out.println("========================\n");
    }
    
    // When Order is cancelled/deleted, all OrderItems are deleted
    public void cancelOrder() {
        System.out.println("Order #" + orderId + " cancelled.");
        items.clear();  // All items are destroyed
        System.out.println("All order items removed.\n");
    }
}

// Usage
Order order = new Order("ORD001", "John Doe");
order.addItem("Laptop", 1, 1200.00);
order.addItem("Mouse", 2, 25.00);
order.addItem("Keyboard", 1, 75.00);

order.printOrder();

// OrderItems cannot exist without the Order
order.cancelOrder();  // Order and all items are destroyed together</code></pre>
              </div>
            </div>
          </div>

          <h2>Composition Visualization</h2>
          <div class="mermaid">
classDiagram
    class House {
        +string Address
        -List~Room~ rooms
        +House(string)
        +ListRooms()
    }
    
    class Room {
        +string Name
        +double Area
        -Room(string, double)
    }
    
    class Car {
        +string Brand
        +string Model
        -Engine engine
        -Transmission transmission
        +Start()
        +Stop()
    }
    
    class Engine {
        +string Type
        +int Horsepower
        -Engine(string, int)
        +Start()
    }
    
    class Transmission {
        +string Type
        +int Gears
        -Transmission(string, int)
    }
    
    House *-- Room : owns (composition)
    Car *-- Engine : owns (composition)
    Car *-- Transmission : owns (composition)
    
    note for House "When House is destroyed,\nall Rooms are destroyed"
    note for Car "When Car is destroyed,\nEngine and Transmission\nare destroyed"
          </div>

          <h2>Composition vs Aggregation</h2>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th>Aspect</th>
                <th>Aggregation</th>
                <th>Composition</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Relationship Strength</strong></td>
                <td>Weak (Has-a)</td>
                <td>Strong (Part-of)</td>
              </tr>
              <tr>
                <td><strong>Ownership</strong></td>
                <td>Shared/weak ownership</td>
                <td>Exclusive ownership</td>
              </tr>
              <tr>
                <td><strong>Lifecycle</strong></td>
                <td>Parts survive container</td>
                <td>Parts die with container</td>
              </tr>
              <tr>
                <td><strong>Creation</strong></td>
                <td>Parts created externally</td>
                <td>Parts created by container</td>
              </tr>
              <tr>
                <td><strong>UML Diamond</strong></td>
                <td>‚óá Empty diamond</td>
                <td>‚óÜ Filled diamond</td>
              </tr>
              <tr>
                <td><strong>Example</strong></td>
                <td>Library has Books</td>
                <td>House has Rooms</td>
              </tr>
            </tbody>
          </table>

          <h2>When to Use Composition</h2>
          <ul>
            <li><strong>Physical containment:</strong> Car contains Engine, House contains Rooms</li>
            <li><strong>Logical containment:</strong> Order contains OrderItems, Document contains Paragraphs</li>
            <li><strong>Exclusive ownership:</strong> When the part has no meaning without the whole</li>
            <li><strong>Tight coupling is acceptable:</strong> When parts are implementation details</li>
          </ul>

          <h2>Real-World Examples</h2>
          <div class="row g-3">
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-blue">
                <div class="card-body">
                  <h3>Computer System</h3>
                  <p><strong>Whole:</strong> Computer</p>
                  <p><strong>Parts:</strong> CPU, RAM, Motherboard</p>
                  <p>Parts cannot function without the computer system.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-green">
                <div class="card-body">
                  <h3>Human Body</h3>
                  <p><strong>Whole:</strong> Body</p>
                  <p><strong>Parts:</strong> Heart, Brain, Lungs</p>
                  <p>Organs cannot survive independently of the body.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-yellow">
                <div class="card-body">
                  <h3>Book Structure</h3>
                  <p><strong>Whole:</strong> Book</p>
                  <p><strong>Parts:</strong> Chapters, Pages</p>
                  <p>Chapters and pages have no meaning without the book.</p>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-pink">
                <div class="card-body">
                  <h3>GUI Window</h3>
                  <p><strong>Whole:</strong> Window</p>
                  <p><strong>Parts:</strong> Buttons, TextBoxes, Labels</p>
                  <p>UI controls are destroyed when window is closed.</p>
                </div>
              </div>
            </div>
          </div>

          <div class="callout">
            <strong>‚ö†Ô∏è Important:</strong> Composition implies <strong>exclusive ownership</strong> and <strong>lifecycle dependency</strong>. 
            When choosing between aggregation and composition, ask: "If I destroy the container, should the parts be 
            destroyed too?" If yes, use composition. If no, use aggregation. Favor composition over inheritance 
            ("Composition over Inheritance" principle) for flexible design.
          </div>
        </section>

        <!-- Interfaces & Abstract Classes Section -->
        <section id="interfaces" role="article">
          <h1>üìê Interfaces & Abstract Classes</h1>
          <span class="badge">contracts</span>
          <span class="badge">abstraction</span>
          <span class="badge">polymorphism</span>
          
          <h2>Understanding Abstraction Mechanisms</h2>
          <p>
            Both <strong>interfaces</strong> and <strong>abstract classes</strong> are fundamental tools for achieving abstraction 
            in C#. They allow you to define contracts and common behavior while hiding implementation details. However, they 
            serve different purposes and have distinct characteristics.
          </p>

          <h2>Interfaces</h2>
          <p>
            An <strong>interface</strong> defines a contract‚Äîa set of method signatures that implementing classes must provide. 
            It specifies <strong>what</strong> a class can do, not <strong>how</strong> it does it.
          </p>

          <h3>Interface Example: Payment Processing</h3>
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" id="interface-payment-csharp-tab" data-bs-toggle="tab" data-bs-target="#interface-payment-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" id="interface-payment-java-tab" data-bs-toggle="tab" data-bs-target="#interface-payment-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="interface-payment-csharp" role="tabpanel">
                <pre><code>// Interface definition - defines capabilities
public interface IPayable
{
    // Method signatures only (no implementation)
    bool ProcessPayment(decimal amount);
    void RefundPayment(string transactionId);
    string GetTransactionStatus(string transactionId);
}

public interface ILoggable
{
    void LogTransaction(string message);
}

// Class can implement multiple interfaces
public class CreditCardPayment : IPayable, ILoggable
{
    private List<string> transactionLog = new List<string>();
    
    public bool ProcessPayment(decimal amount)
    {
        LogTransaction($\"Processing credit card payment: ${amount}\");
        // Credit card processing logic
        Console.WriteLine($\"Credit card payment of ${amount} processed successfully\");
        return true;
    }
    
    public void RefundPayment(string transactionId)
    {
        LogTransaction($\"Refunding transaction: {transactionId}\");
        Console.WriteLine($\"Transaction {transactionId} refunded\");
    }
    
    public string GetTransactionStatus(string transactionId)
    {
        return \"Completed\";
    }
    
    public void LogTransaction(string message)
    {
        transactionLog.Add($\"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] {message}\");
        Console.WriteLine($\"LOG: {message}\");
    }
}

public class PayPalPayment : IPayable, ILoggable
{
    private List<string> transactionLog = new List<string>();
    
    public bool ProcessPayment(decimal amount)
    {
        LogTransaction($\"Processing PayPal payment: ${amount}\");
        Console.WriteLine($\"PayPal payment of ${amount} processed successfully\");
        return true;
    }
    
    public void RefundPayment(string transactionId)
    {
        LogTransaction($\"Refunding PayPal transaction: {transactionId}\");
        Console.WriteLine($\"PayPal transaction {transactionId} refunded\");
    }
    
    public string GetTransactionStatus(string transactionId)
    {
        return \"Pending\";
    }
    
    public void LogTransaction(string message)
    {
        transactionLog.Add($\"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] {message}\");
        Console.WriteLine($\"LOG: {message}\");
    }
}

// Usage - polymorphic behavior
IPayable payment1 = new CreditCardPayment();
payment1.ProcessPayment(100.00m);

IPayable payment2 = new PayPalPayment();
payment2.ProcessPayment(75.50m);</code></pre>
              </div>
              <div class=\"tab-pane fade\" id=\"interface-payment-java\" role=\"tabpanel\">
                <pre><code>import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;

// Interface definition - defines capabilities
public interface Payable {
    // Method signatures only (no implementation)
    boolean processPayment(double amount);
    void refundPayment(String transactionId);
    String getTransactionStatus(String transactionId);
}

interface Loggable {
    void logTransaction(String message);
}

// Class can implement multiple interfaces
public class CreditCardPayment implements Payable, Loggable {
    private List<String> transactionLog = new ArrayList<>();
    
    @Override
    public boolean processPayment(double amount) {
        logTransaction(\"Processing credit card payment: $\" + amount);
        // Credit card processing logic
        System.out.println(\"Credit card payment of $\" + amount + \" processed successfully\");
        return true;
    }
    
    @Override
    public void refundPayment(String transactionId) {
        logTransaction(\"Refunding transaction: \" + transactionId);
        System.out.println(\"Transaction \" + transactionId + \" refunded\");
    }
    
    @Override
    public String getTransactionStatus(String transactionId) {
        return \"Completed\";
    }
    
    @Override
    public void logTransaction(String message) {
        LocalDateTime now = LocalDateTime.now();
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");
        transactionLog.add(\"[\" + now.format(formatter) + \"] \" + message);
        System.out.println(\"LOG: \" + message);
    }
}

public class PayPalPayment implements Payable, Loggable {
    private List<String> transactionLog = new ArrayList<>();
    
    @Override
    public boolean processPayment(double amount) {
        logTransaction(\"Processing PayPal payment: $\" + amount);
        System.out.println(\"PayPal payment of $\" + amount + \" processed successfully\");
        return true;
    }
    
    @Override
    public void refundPayment(String transactionId) {
        logTransaction(\"Refunding PayPal transaction: \" + transactionId);
        System.out.println(\"PayPal transaction \" + transactionId + \" refunded\");
    }
    
    @Override
    public String getTransactionStatus(String transactionId) {
        return \"Pending\";
    }
    
    @Override
    public void logTransaction(String message) {
        LocalDateTime now = LocalDateTime.now();
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern(\"yyyy-MM-dd HH:mm:ss\");
        transactionLog.add(\"[\" + now.format(formatter) + \"] \" + message);
        System.out.println(\"LOG: \" + message);
    }
}

// Usage - polymorphic behavior
Payable payment1 = new CreditCardPayment();
payment1.processPayment(100.00);

Payable payment2 = new PayPalPayment();
payment2.processPayment(75.50);</code></pre>
              </div>
            </div>
          </div>

          <h2>Abstract Classes</h2>
          <p>
            An <strong>abstract class</strong> is a partially implemented class that can contain both abstract methods 
            (no implementation) and concrete methods (with implementation). It provides a base for derived classes to build upon.
          </p>

          <h3>Abstract Class Example: Database Connection</h3>
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" id="abstract-db-csharp-tab" data-bs-toggle="tab" data-bs-target="#abstract-db-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" id="abstract-db-java-tab" data-bs-toggle="tab" data-bs-target="#abstract-db-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="abstract-db-csharp" role="tabpanel">
                <pre><code>// Abstract class - can have both abstract and concrete members
public abstract class DatabaseConnection
{
    // Concrete properties
    public string ConnectionString { get; set; }
    public bool IsConnected { get; protected set; }
    
    // Constructor
    protected DatabaseConnection(string connectionString)
    {
        ConnectionString = connectionString;
        IsConnected = false;
    }
    
    // Abstract methods - must be implemented by derived classes
    public abstract void Connect();
    public abstract void Disconnect();
    public abstract void ExecuteQuery(string query);
    
    // Concrete method - shared implementation
    public void LogActivity(string activity)
    {
        Console.WriteLine($"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] {activity}");
    }
    
    // Virtual method - can be overridden but has default implementation
    public virtual bool TestConnection()
    {
        Console.WriteLine("Testing connection...");
        return IsConnected;
    }
}

public class SqlServerConnection : DatabaseConnection
{
    public SqlServerConnection(string connectionString) 
        : base(connectionString)
    {
    }
    
    public override void Connect()
    {
        Console.WriteLine($"Connecting to SQL Server: {ConnectionString}");
        IsConnected = true;
        LogActivity("Connected to SQL Server");
    }
    
    public override void Disconnect()
    {
        Console.WriteLine("Disconnecting from SQL Server");
        IsConnected = false;
        LogActivity("Disconnected from SQL Server");
    }
    
    public override void ExecuteQuery(string query)
    {
        if (!IsConnected)
        {
            throw new InvalidOperationException("Not connected to database");
        }
        Console.WriteLine($"Executing SQL Server query: {query}");
        LogActivity($"Query executed: {query}");
    }
}

public class MySqlConnection : DatabaseConnection
{
    public MySqlConnection(string connectionString) 
        : base(connectionString)
    {
    }
    
    public override void Connect()
    {
        Console.WriteLine($"Connecting to MySQL: {ConnectionString}");
        IsConnected = true;
        LogActivity("Connected to MySQL");
    }
    
    public override void Disconnect()
    {
        Console.WriteLine("Disconnecting from MySQL");
        IsConnected = false;
        LogActivity("Disconnected from MySQL");
    }
    
    public override void ExecuteQuery(string query)
    {
        if (!IsConnected)
        {
            throw new InvalidOperationException("Not connected to database");
        }
        Console.WriteLine($"Executing MySQL query: {query}");
        LogActivity($"Query executed: {query}");
    }
    
    // Override virtual method
    public override bool TestConnection()
    {
        Console.WriteLine("Testing MySQL connection with ping...");
        return base.TestConnection();
    }
}

// Usage
DatabaseConnection sqlConn = new SqlServerConnection("Server=localhost;Database=MyDB");
sqlConn.Connect();
sqlConn.ExecuteQuery("SELECT * FROM Users");
sqlConn.Disconnect();

DatabaseConnection mysqlConn = new MySqlConnection("Server=localhost;Database=MyDB");
mysqlConn.Connect();
mysqlConn.TestConnection();
mysqlConn.ExecuteQuery("SELECT * FROM Products");
mysqlConn.Disconnect();</code></pre>
              </div>
              <div class="tab-pane fade" id="abstract-db-java" role="tabpanel">
                <pre><code>import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

// Abstract class - can have both abstract and concrete members
public abstract class DatabaseConnection {
    // Concrete properties
    private String connectionString;
    private boolean isConnected;
    
    public String getConnectionString() { return connectionString; }
    public void setConnectionString(String connectionString) { this.connectionString = connectionString; }
    public boolean isConnected() { return isConnected; }
    protected void setConnected(boolean connected) { isConnected = connected; }
    
    // Constructor
    protected DatabaseConnection(String connectionString) {
        this.connectionString = connectionString;
        this.isConnected = false;
    }
    
    // Abstract methods - must be implemented by derived classes
    public abstract void connect();
    public abstract void disconnect();
    public abstract void executeQuery(String query);
    
    // Concrete method - shared implementation
    public void logActivity(String activity) {
        LocalDateTime now = LocalDateTime.now();
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        System.out.println("[" + now.format(formatter) + "] " + activity);
    }
    
    // Method can be overridden but has default implementation
    public boolean testConnection() {
        System.out.println("Testing connection...");
        return isConnected;
    }
}

public class SqlServerConnection extends DatabaseConnection {
    public SqlServerConnection(String connectionString) {
        super(connectionString);
    }
    
    @Override
    public void connect() {
        System.out.println("Connecting to SQL Server: " + getConnectionString());
        setConnected(true);
        logActivity("Connected to SQL Server");
    }
    
    @Override
    public void disconnect() {
        System.out.println("Disconnecting from SQL Server");
        setConnected(false);
        logActivity("Disconnected from SQL Server");
    }
    
    @Override
    public void executeQuery(String query) {
        if (!isConnected()) {
            throw new IllegalStateException("Not connected to database");
        }
        System.out.println("Executing SQL Server query: " + query);
        logActivity("Query executed: " + query);
    }
}

public class MySqlConnection extends DatabaseConnection {
    public MySqlConnection(String connectionString) {
        super(connectionString);
    }
    
    @Override
    public void connect() {
        System.out.println("Connecting to MySQL: " + getConnectionString());
        setConnected(true);
        logActivity("Connected to MySQL");
    }
    
    @Override
    public void disconnect() {
        System.out.println("Disconnecting from MySQL");
        setConnected(false);
        logActivity("Disconnected from MySQL");
    }
    
    @Override
    public void executeQuery(String query) {
        if (!isConnected()) {
            throw new IllegalStateException("Not connected to database");
        }
        System.out.println("Executing MySQL query: " + query);
        logActivity("Query executed: " + query);
    }
    
    // Override method
    @Override
    public boolean testConnection() {
        System.out.println("Testing MySQL connection with ping...");
        return super.testConnection();
    }
}

// Usage
DatabaseConnection sqlConn = new SqlServerConnection("Server=localhost;Database=MyDB");
sqlConn.connect();
sqlConn.executeQuery("SELECT * FROM Users");
sqlConn.disconnect();

DatabaseConnection mysqlConn = new MySqlConnection("Server=localhost;Database=MyDB");
mysqlConn.connect();
mysqlConn.testConnection();
mysqlConn.executeQuery("SELECT * FROM Products");
mysqlConn.disconnect();</code></pre>
              </div>
            </div>
          </div>

          <h2>Interface vs Abstract Class</h2>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th>Feature</th>
                <th>Interface</th>
                <th>Abstract Class</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Multiple Inheritance</strong></td>
                <td>‚úÖ A class can implement multiple interfaces</td>
                <td>‚ùå A class can inherit only one abstract class</td>
              </tr>
              <tr>
                <td><strong>Implementation</strong></td>
                <td>‚ùå No implementation (C# 8+ allows default)</td>
                <td>‚úÖ Can have both abstract and concrete methods</td>
              </tr>
              <tr>
                <td><strong>Fields/Properties</strong></td>
                <td>‚ùå Cannot have fields</td>
                <td>‚úÖ Can have fields and properties</td>
              </tr>
              <tr>
                <td><strong>Constructor</strong></td>
                <td>‚ùå Cannot have constructors</td>
                <td>‚úÖ Can have constructors</td>
              </tr>
              <tr>
                <td><strong>Access Modifiers</strong></td>
                <td>‚ùå Members are public by default</td>
                <td>‚úÖ Can use any access modifier</td>
              </tr>
              <tr>
                <td><strong>When to Use</strong></td>
                <td>Define capabilities (CAN-DO)</td>
                <td>Define common base (IS-A)</td>
              </tr>
              <tr>
                <td><strong>Example</strong></td>
                <td>IComparable, IDisposable, IEnumerable</td>
                <td>Stream, DbConnection, ControllerBase</td>
              </tr>
            </tbody>
          </table>

          <h2>Combining Both: Real-World Example</h2>
          <pre class="syntax-highlighted" data-language="C#"><code class="language-csharp">// Interface for logging capability
public interface ILogger
{
    void Log(string message);
}

// Interface for disposable resources
public interface IDisposable
{
    void Dispose();
}

// Abstract base class for file operations
public abstract class FileProcessor : ILogger, IDisposable
{
    protected string FilePath { get; set; }
    protected bool IsDisposed { get; set; }
    
    protected FileProcessor(string filePath)
    {
        FilePath = filePath;
        IsDisposed = false;
    }
    
    // Abstract method - must be implemented
    public abstract void ProcessFile();
    
    // Concrete method - shared implementation
    public void Log(string message)
    {
        Console.WriteLine($"[LOG] {message}");
    }
    
    // Virtual method - can be overridden
    public virtual void ValidateFile()
    {
        if (!File.Exists(FilePath))
        {
            throw new FileNotFoundException($"File not found: {FilePath}");
        }
        Log($"File validated: {FilePath}");
    }
    
    public void Dispose()
    {
        if (!IsDisposed)
        {
            Log($"Disposing file processor for: {FilePath}");
            CleanUp();
            IsDisposed = true;
        }
    }
    
    protected virtual void CleanUp()
    {
        // Default cleanup logic
    }
}

// Concrete implementation
public class CsvFileProcessor : FileProcessor
{
    public CsvFileProcessor(string filePath) : base(filePath)
    {
    }
    
    public override void ProcessFile()
    {
        ValidateFile();
        Log($"Processing CSV file: {FilePath}");
        
        // CSV-specific processing
        string[] lines = File.ReadAllLines(FilePath);
        Log($"Read {lines.Length} lines from CSV");
        
        foreach (var line in lines.Take(5))
        {
            Console.WriteLine($"  {line}");
        }
    }
    
    protected override void CleanUp()
    {
        Log("Cleaning up CSV processor resources");
        base.CleanUp();
    }
}

public class XmlFileProcessor : FileProcessor
{
    public XmlFileProcessor(string filePath) : base(filePath)
    {
    }
    
    public override void ProcessFile()
    {
        ValidateFile();
        Log($"Processing XML file: {FilePath}");
        
        // XML-specific processing
        string content = File.ReadAllText(FilePath);
        Log($"Read XML content ({content.Length} characters)");
    }
}

// Usage
using (FileProcessor processor = new CsvFileProcessor("data.csv"))
{
    processor.ProcessFile();
}  // Dispose called automatically</code></pre>

          <h2>Visualization</h2>
          <div class="mermaid">
classDiagram
    class IPayable {
        <<interface>>
        +ProcessPayment(decimal) bool
        +RefundPayment(string) void
        +GetTransactionStatus(string) string
    }
    
    class ILoggable {
        <<interface>>
        +LogTransaction(string) void
    }
    
    class DatabaseConnection {
        <<abstract>>
        +string ConnectionString
        +bool IsConnected
        +Connect()* void
        +Disconnect()* void
        +ExecuteQuery(string)* void
        +LogActivity(string) void
        +TestConnection() bool
    }
    
    class CreditCardPayment {
        +ProcessPayment(decimal) bool
        +RefundPayment(string) void
        +GetTransactionStatus(string) string
        +LogTransaction(string) void
    }
    
    class SqlServerConnection {
        +Connect() void
        +Disconnect() void
        +ExecuteQuery(string) void
        +TestConnection() bool
    }
    
    IPayable <|.. CreditCardPayment : implements
    ILoggable <|.. CreditCardPayment : implements
    DatabaseConnection <|-- SqlServerConnection : extends
    
    note for IPayable "Interface:\\nDefines contract\\nMultiple inheritance allowed"
    note for DatabaseConnection "Abstract Class:\\nPartial implementation\\nSingle inheritance only"
          </div>

          <h2>Best Practices</h2>
          <ul>
            <li><strong>Use Interfaces for:</strong> Defining capabilities/contracts (IDisposable, IComparable, IEnumerable)</li>
            <li><strong>Use Abstract Classes for:</strong> Sharing common implementation among related classes</li>
            <li><strong>Interface Naming:</strong> Prefix interface names with 'I' (IPayable, ILogger)</li>
            <li><strong>Keep Interfaces Focused:</strong> Follow Interface Segregation Principle (small, specific interfaces)</li>
            <li><strong>Favor Composition:</strong> Use interfaces for flexibility; avoid deep inheritance hierarchies</li>
            <li><strong>Program to Interfaces:</strong> Depend on abstractions, not concrete implementations</li>
          </ul>

          <div class="callout">
            <strong>üí° Guideline:</strong> Choose interfaces when you need to define a contract or capability that can be 
            implemented by unrelated classes (e.g., both File and Database can implement IDisposable). Choose abstract 
            classes when you have common implementation to share among related classes (e.g., Stream has FileStream, 
            MemoryStream, NetworkStream all sharing base functionality).
          </div>
        </section>

        <!-- Access Modifiers Section -->
        <section id="access-modifiers" role="article">
          <h1>üîí Access Modifiers</h1>
          <span class="badge">visibility</span>
          <span class="badge">encapsulation</span>
          <span class="badge">security</span>
          
          <h2>What are Access Modifiers?</h2>
          <p>
            <strong>Access Modifiers</strong> (also called access specifiers) control the visibility and accessibility of classes, 
            methods, properties, and other members. They are essential for implementing <strong>encapsulation</strong> and 
            maintaining proper abstraction boundaries.
          </p>

          <h2>C# Access Modifiers</h2>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th>Modifier</th>
                <th>Same Class</th>
                <th>Derived Class</th>
                <th>Same Assembly</th>
                <th>Different Assembly</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><code>public</code></td>
                <td>‚úÖ</td>
                <td>‚úÖ</td>
                <td>‚úÖ</td>
                <td>‚úÖ</td>
              </tr>
              <tr>
                <td><code>private</code></td>
                <td>‚úÖ</td>
                <td>‚ùå</td>
                <td>‚ùå</td>
                <td>‚ùå</td>
              </tr>
              <tr>
                <td><code>protected</code></td>
                <td>‚úÖ</td>
                <td>‚úÖ</td>
                <td>‚ùå</td>
                <td>‚ùå</td>
              </tr>
              <tr>
                <td><code>internal</code></td>
                <td>‚úÖ</td>
                <td>‚úÖ</td>
                <td>‚úÖ</td>
                <td>‚ùå</td>
              </tr>
              <tr>
                <td><code>protected internal</code></td>
                <td>‚úÖ</td>
                <td>‚úÖ</td>
                <td>‚úÖ</td>
                <td>‚úÖ (if derived)</td>
              </tr>
              <tr>
                <td><code>private protected</code></td>
                <td>‚úÖ</td>
                <td>‚úÖ (same assembly)</td>
                <td>‚úÖ (if derived)</td>
                <td>‚ùå</td>
              </tr>
            </tbody>
          </table>

          <h2>1. Public Access Modifier</h2>
          <p>No restrictions on access. Members can be accessed from anywhere.</p>
          
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" data-bs-toggle="tab" data-bs-target="#public-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" data-bs-toggle="tab" data-bs-target="#public-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="public-csharp" role="tabpanel">
                <pre class="syntax-highlighted" data-language="C#"><code class="language-csharp">public class Product
{
    // Public property - accessible everywhere
    public string Name { get; set; }
    public decimal Price { get; set; }
    
    // Public method - accessible everywhere
    public void DisplayInfo()
    {
        Console.WriteLine($"{Name}: ${Price}");
    }
}

// Usage from anywhere
Product product = new Product();
product.Name = "Laptop";      // ‚úÖ Accessible
product.Price = 999.99m;      // ‚úÖ Accessible
product.DisplayInfo();        // ‚úÖ Accessible</code></pre>
              </div>
              <div class="tab-pane fade" id="public-java" role="tabpanel">
                <pre class="syntax-highlighted" data-language="Java"><code class="language-java">public class Product {
    // Public fields with getters/setters - accessible everywhere
    private String name;
    private double price;
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public double getPrice() {
        return price;
    }
    
    public void setPrice(double price) {
        this.price = price;
    }
    
    // Public method - accessible everywhere
    public void displayInfo() {
        System.out.println(name + ": $" + price);
    }
}

// Usage from anywhere
Product product = new Product();
product.setName("Laptop");      // ‚úÖ Accessible
product.setPrice(999.99);       // ‚úÖ Accessible
product.displayInfo();          // ‚úÖ Accessible</code></pre>
              </div>
            </div>
          </div>

          <h2>2. Private Access Modifier</h2>
          <p>Most restrictive. Members can only be accessed within the same class.</p>
          
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" data-bs-toggle="tab" data-bs-target="#private-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" data-bs-toggle="tab" data-bs-target="#private-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="private-csharp" role="tabpanel">
                <pre class="syntax-highlighted" data-language="C#"><code class="language-csharp">public class BankAccount
{
    // Private fields - only accessible within this class
    private string accountNumber;
    private decimal balance;
    private string pin;
    
    public BankAccount(string accountNumber, decimal initialBalance, string pin)
    {
        this.accountNumber = accountNumber;
        this.balance = initialBalance;
        this.pin = pin;
    }
    
    // Public property with private setter
    public decimal Balance 
    { 
        get { return balance; }
        private set { balance = value; }  // Only modifiable within class
    }
    
    // Private method - internal implementation
    private bool ValidatePin(string inputPin)
    {
        return pin == inputPin;
    }
    
    // Public method that uses private members
    public bool Withdraw(decimal amount, string inputPin)
    {
        if (!ValidatePin(inputPin))  // ‚úÖ Can call private method
        {
            Console.WriteLine("Invalid PIN");
            return false;
        }
        
        if (amount > balance)
        {
            Console.WriteLine("Insufficient funds");
            return false;
        }
        
        balance -= amount;  // ‚úÖ Can access private field
        return true;
    }
}

// Usage
BankAccount account = new BankAccount("ACC001", 1000, "1234");
Console.WriteLine(account.Balance);     // ‚úÖ Can read balance
// account.balance = 5000;              // ‚ùå Cannot access private field
// account.ValidatePin("1234");         // ‚ùå Cannot call private method
account.Withdraw(100, "1234");          // ‚úÖ Can call public method</code></pre>
              </div>
              <div class="tab-pane fade" id="private-java" role="tabpanel">
                <pre class="syntax-highlighted" data-language="Java"><code class="language-java">public class BankAccount {
    // Private fields - only accessible within this class
    private String accountNumber;
    private double balance;
    private String pin;
    
    public BankAccount(String accountNumber, double initialBalance, String pin) {
        this.accountNumber = accountNumber;
        this.balance = initialBalance;
        this.pin = pin;
    }
    
    // Public getter for balance
    public double getBalance() {
        return balance;
    }
    
    // Private setter for balance - only modifiable within class
    private void setBalance(double balance) {
        this.balance = balance;
    }
    
    // Private method - internal implementation
    private boolean validatePin(String inputPin) {
        return pin.equals(inputPin);
    }
    
    // Public method that uses private members
    public boolean withdraw(double amount, String inputPin) {
        if (!validatePin(inputPin)) {  // ‚úÖ Can call private method
            System.out.println("Invalid PIN");
            return false;
        }
        
        if (amount > balance) {
            System.out.println("Insufficient funds");
            return false;
        }
        
        balance -= amount;  // ‚úÖ Can access private field
        return true;
    }
}

// Usage
BankAccount account = new BankAccount("ACC001", 1000, "1234");
System.out.println(account.getBalance());  // ‚úÖ Can read balance
// account.balance = 5000;                 // ‚ùå Cannot access private field
// account.validatePin("1234");            // ‚ùå Cannot call private method
account.withdraw(100, "1234");             // ‚úÖ Can call public method</code></pre>
              </div>
            </div>
          </div>

          <h2>3. Protected Access Modifier</h2>
          <p>Accessible within the same class and derived classes.</p>
          
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" data-bs-toggle="tab" data-bs-target="#protected-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" data-bs-toggle="tab" data-bs-target="#protected-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="protected-csharp" role="tabpanel">
                <pre class="syntax-highlighted" data-language="C#"><code class="language-csharp">public class Employee
{
    // Protected fields - accessible in derived classes
    protected string employeeId;
    protected decimal baseSalary;
    
    public string Name { get; set; }
    
    public Employee(string name, string employeeId, decimal baseSalary)
    {
        Name = name;
        this.employeeId = employeeId;
        this.baseSalary = baseSalary;
    }
    
    // Protected method - available to derived classes
    protected virtual decimal CalculateBonus()
    {
        return baseSalary * 0.1m;
    }
    
    public virtual decimal GetTotalCompensation()
    {
        return baseSalary + CalculateBonus();  // ‚úÖ Can call protected method
    }
}

public class Manager : Employee
{
    private decimal managementBonus;
    
    public Manager(string name, string employeeId, decimal baseSalary, decimal managementBonus)
        : base(name, employeeId, baseSalary)
    {
        this.managementBonus = managementBonus;
    }
    
    // Override protected method
    protected override decimal CalculateBonus()
    {
        // ‚úÖ Can access protected field from base class
        return baseSalary * 0.2m + managementBonus;
    }
    
    public void DisplayDetails()
    {
        // ‚úÖ Can access protected members from base class
        Console.WriteLine($"ID: {employeeId}");
        Console.WriteLine($"Base Salary: ${baseSalary}");
        Console.WriteLine($"Total: ${GetTotalCompensation()}");
    }
}

// Usage
Manager manager = new Manager("John Doe", "E001", 80000, 5000);
manager.DisplayDetails();
// manager.baseSalary = 90000;    // ‚ùå Cannot access protected field from outside
// manager.CalculateBonus();      // ‚ùå Cannot call protected method from outside</code></pre>
              </div>
              <div class="tab-pane fade" id="protected-java" role="tabpanel">
                <pre class="syntax-highlighted" data-language="Java"><code class="language-java">public class Employee {
    // Protected fields - accessible in derived classes
    protected String employeeId;
    protected double baseSalary;
    
    private String name;
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public Employee(String name, String employeeId, double baseSalary) {
        this.name = name;
        this.employeeId = employeeId;
        this.baseSalary = baseSalary;
    }
    
    // Protected method - available to derived classes
    protected double calculateBonus() {
        return baseSalary * 0.1;
    }
    
    public double getTotalCompensation() {
        return baseSalary + calculateBonus();  // ‚úÖ Can call protected method
    }
}

class Manager extends Employee {
    private double managementBonus;
    
    public Manager(String name, String employeeId, double baseSalary, double managementBonus) {
        super(name, employeeId, baseSalary);
        this.managementBonus = managementBonus;
    }
    
    // Override protected method
    @Override
    protected double calculateBonus() {
        // ‚úÖ Can access protected field from base class
        return baseSalary * 0.2 + managementBonus;
    }
    
    public void displayDetails() {
        // ‚úÖ Can access protected members from base class
        System.out.println("ID: " + employeeId);
        System.out.println("Base Salary: $" + baseSalary);
        System.out.println("Total: $" + getTotalCompensation());
    }
}

// Usage
Manager manager = new Manager("John Doe", "E001", 80000, 5000);
manager.displayDetails();
// manager.baseSalary = 90000;    // ‚ùå Cannot access protected field from outside
// manager.calculateBonus();      // ‚ùå Cannot call protected method from outside</code></pre>
              </div>
            </div>
          </div>

          <h2>4. Internal Access Modifier</h2>
          <p>Accessible within the same assembly (project). Hidden from other assemblies.</p>
          
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" data-bs-toggle="tab" data-bs-target="#internal-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" data-bs-toggle="tab" data-bs-target="#internal-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="internal-csharp" role="tabpanel">
                <pre class="syntax-highlighted" data-language="C#"><code class="language-csharp">// In Assembly: MyLibrary.dll

// Internal class - only visible within MyLibrary assembly
internal class DatabaseHelper
{
    internal static string ConnectionString { get; set; }
    
    internal static void Initialize()
    {
        ConnectionString = "Server=localhost;Database=MyDB";
    }
}

public class DataService
{
    public DataService()
    {
        // ‚úÖ Can use internal class within same assembly
        DatabaseHelper.Initialize();
    }
    
    // Internal method - only accessible within assembly
    internal void RefreshCache()
    {
        Console.WriteLine("Cache refreshed");
    }
    
    public void GetData()
    {
        RefreshCache();  // ‚úÖ Can call internal method
        Console.WriteLine($"Connecting with: {DatabaseHelper.ConnectionString}");
    }
}

// In Assembly: MyApplication.exe
// var helper = new DatabaseHelper();  // ‚ùå Cannot access internal class
var service = new DataService();       // ‚úÖ Can access public class
service.GetData();                     // ‚úÖ Can call public method
// service.RefreshCache();             // ‚ùå Cannot call internal method</code></pre>
              </div>
              <div class="tab-pane fade" id="internal-java" role="tabpanel">
                <pre class="syntax-highlighted" data-language="Java"><code class="language-java">// In Package: com.mylibrary

// Package-private class - only visible within same package (no modifier)
class DatabaseHelper {
    private static String connectionString;
    
    static String getConnectionString() {
        return connectionString;
    }
    
    static void setConnectionString(String connectionString) {
        DatabaseHelper.connectionString = connectionString;
    }
    
    static void initialize() {
        connectionString = "Server=localhost;Database=MyDB";
    }
}

public class DataService {
    public DataService() {
        // ‚úÖ Can use package-private class within same package
        DatabaseHelper.initialize();
    }
    
    // Package-private method - only accessible within package
    void refreshCache() {
        System.out.println("Cache refreshed");
    }
    
    public void getData() {
        refreshCache();  // ‚úÖ Can call package-private method
        System.out.println("Connecting with: " + DatabaseHelper.getConnectionString());
    }
}

// In Package: com.myapplication
// DatabaseHelper helper = new DatabaseHelper();  // ‚ùå Cannot access package-private class
DataService service = new DataService();          // ‚úÖ Can access public class
service.getData();                                // ‚úÖ Can call public method
// service.refreshCache();                        // ‚ùå Cannot call package-private method</code></pre>
              </div>
            </div>
          </div>

          <h2>5. Protected Internal</h2>
          <p>Accessible within the same assembly OR from derived classes in any assembly.</p>
          
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" data-bs-toggle="tab" data-bs-target="#protectedinternal-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" data-bs-toggle="tab" data-bs-target="#protectedinternal-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="protectedinternal-csharp" role="tabpanel">
                <pre class="syntax-highlighted" data-language="C#"><code class="language-csharp">// In Assembly: BaseLibrary.dll
public class BaseController
{
    // Protected internal - accessible within assembly OR derived classes
    protected internal void LogRequest(string message)
    {
        Console.WriteLine($"[LOG] {message}");
    }
    
    protected internal string GetUserContext()
    {
        return "User123";
    }
}

// In same assembly (BaseLibrary.dll)
public class AdminController : BaseController
{
    public void ProcessRequest()
    {
        LogRequest("Admin request");  // ‚úÖ Accessible (derived class)
    }
}

public class Helper
{
    public void DoSomething()
    {
        var controller = new BaseController();
        controller.LogRequest("Helper");  // ‚úÖ Accessible (same assembly)
    }
}

// In different assembly (MyApp.exe)
public class CustomController : BaseController
{
    public void HandleRequest()
    {
        LogRequest("Custom request");  // ‚úÖ Accessible (derived class)
    }
}

public class ExternalClass
{
    public void Test()
    {
        var controller = new BaseController();
        // controller.LogRequest("Test");  // ‚ùå Not accessible (different assembly, not derived)
    }
}</code></pre>
              </div>
              <div class="tab-pane fade" id="protectedinternal-java" role="tabpanel">
                <pre class="syntax-highlighted" data-language="Java"><code class="language-java">// In Package: com.baselibrary
public class BaseController {
    // Protected - accessible within package AND derived classes
    protected void logRequest(String message) {
        System.out.println("[LOG] " + message);
    }
    
    protected String getUserContext() {
        return "User123";
    }
}

// In same package (com.baselibrary)
public class AdminController extends BaseController {
    public void processRequest() {
        logRequest("Admin request");  // ‚úÖ Accessible (derived class)
    }
}

class Helper {
    public void doSomething() {
        BaseController controller = new BaseController();
        controller.logRequest("Helper");  // ‚úÖ Accessible (same package)
    }
}

// In different package (com.myapp)
import com.baselibrary.BaseController;

public class CustomController extends BaseController {
    public void handleRequest() {
        logRequest("Custom request");  // ‚úÖ Accessible (derived class)
    }
}

class ExternalClass {
    public void test() {
        BaseController controller = new BaseController();
        // controller.logRequest("Test");  // ‚ùå Not accessible (different package, not derived)
    }
}</code></pre>
              </div>
            </div>
          </div>

          <h2>6. Private Protected</h2>
          <p>Accessible only within the same class or derived classes in the same assembly.</p>
          
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" data-bs-toggle="tab" data-bs-target="#privateprotected-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" data-bs-toggle="tab" data-bs-target="#privateprotected-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="privateprotected-csharp" role="tabpanel">
                <pre class="syntax-highlighted" data-language="C#"><code class="language-csharp">// In Assembly: MyLibrary.dll
public class BaseClass
{
    // Private protected - most restrictive combination
    private protected int internalData = 42;
    
    private protected void InternalMethod()
    {
        Console.WriteLine("Internal method called");
    }
}

// In same assembly
public class DerivedClass : BaseClass
{
    public void AccessData()
    {
        Console.WriteLine(internalData);  // ‚úÖ Accessible (derived, same assembly)
        InternalMethod();                 // ‚úÖ Accessible (derived, same assembly)
    }
}

// In different assembly
public class ExternalDerivedClass : BaseClass
{
    public void TryAccess()
    {
        // Console.WriteLine(internalData);  // ‚ùå Not accessible (different assembly)
        // InternalMethod();                 // ‚ùå Not accessible (different assembly)
    }
}</code></pre>
              </div>
              <div class="tab-pane fade" id="privateprotected-java" role="tabpanel">
                <pre class="syntax-highlighted" data-language="Java"><code class="language-java">// In Package: com.mylibrary
// Note: Java doesn't have exact equivalent to C# private protected.
// This uses protected which is closest (package + subclass access)
public class BaseClass {
    // Protected - accessible to derived classes in same package
    // and derived classes in other packages
    protected int internalData = 42;
    
    protected void internalMethod() {
        System.out.println("Internal method called");
    }
}

// In same package
public class DerivedClass extends BaseClass {
    public void accessData() {
        System.out.println(internalData);  // ‚úÖ Accessible (derived, same package)
        internalMethod();                  // ‚úÖ Accessible (derived, same package)
    }
}

// In different package
import com.mylibrary.BaseClass;

public class ExternalDerivedClass extends BaseClass {
    public void tryAccess() {
        System.out.println(internalData);  // ‚úÖ Accessible in Java (protected allows subclass access)
        internalMethod();                  // ‚úÖ Accessible in Java (protected allows subclass access)
        // Note: Java's protected is less restrictive than C#'s private protected
    }
}</code></pre>
              </div>
            </div>
          </div>

          <h2>Access Modifier Hierarchy</h2>
          <div class="mermaid">
graph TD
    A[public] -->|Most Permissive| B[protected internal]
    B --> C[internal]
    B --> D[protected]
    C --> E[private protected]
    D --> E
    E -->|Most Restrictive| F[private]
    
    style A fill:#10b981,stroke:#059669,stroke-width:2px,color:#fff
    style F fill:#ef4444,stroke:#dc2626,stroke-width:2px,color:#fff
          </div>

          <h2>Best Practices</h2>
          <ul>
            <li><strong>Principle of Least Privilege:</strong> Make everything as private as possible, expose only what's necessary</li>
            <li><strong>Default to Private:</strong> Start with private, make public only when needed</li>
            <li><strong>Use Protected for Inheritance:</strong> When you want derived classes to access members</li>
            <li><strong>Internal for Library Design:</strong> Hide implementation details within assembly</li>
            <li><strong>Avoid Public Fields:</strong> Use public properties with private backing fields instead</li>
            <li><strong>Consistent Accessibility:</strong> Return types and parameters should not be more restrictive than the method</li>
          </ul>

          <h2>Common Scenarios</h2>
          <div class="row g-3">
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-green">
                <div class="card-body">
                  <h3>‚úÖ Good Practice</h3>
                  <pre class="mb-0"><code>public class Product
{
    private decimal price;
    
    public decimal Price
    {
        get { return price; }
        set 
        { 
            if (value < 0)
                throw new Exception();
            price = value;
        }
    }
}</code></pre>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-red">
                <div class="card-body">
                  <h3>‚ùå Bad Practice</h3>
                  <pre class="mb-0"><code>public class Product
{
    public decimal price;
    
    // No validation
    // No control
    // Direct access
}</code></pre>
                </div>
              </div>
            </div>
          </div>

          <div class="callout">
            <strong>üí° Key Principle:</strong> Access modifiers are the primary tool for implementing encapsulation. 
            By controlling visibility, you protect the integrity of your objects, hide implementation details, and 
            create clear boundaries between public APIs and internal implementation. Always ask: "What's the minimum 
            visibility this member needs?"
          </div>
        </section>

        <!-- Static vs Instance Members Section -->
        <section id="static-members" role="article">
          <h1>‚ö° Static vs Instance Members</h1>
          <span class="badge">static</span>
          <span class="badge">class-level</span>
          <span class="badge">instance-level</span>
          
          <h2>Understanding Static and Instance Members</h2>
          <p>
            In C#, class members can be either <strong>instance members</strong> (belong to each object) or 
            <strong>static members</strong> (belong to the class itself). Understanding the difference is crucial 
            for proper object-oriented design.
          </p>

          <h2>Instance Members</h2>
          <p>
            <strong>Instance members</strong> belong to a specific instance (object) of a class. Each object has its 
            own copy of instance data. You must create an object to access instance members.
          </p>

          <h3>Instance Members Example</h3>
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" data-bs-toggle="tab" data-bs-target="#instance-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" data-bs-toggle="tab" data-bs-target="#instance-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="instance-csharp" role="tabpanel">
                <pre class="syntax-highlighted" data-language="C#"><code class="language-csharp">public class BankAccount
{
    // Instance fields - each account has its own values
    private string accountNumber;
    private decimal balance;
    
    // Instance properties
    public string AccountHolder { get; set; }
    public decimal Balance 
    { 
        get { return balance; }
        private set { balance = value; }
    }
    
    // Instance constructor
    public BankAccount(string accountNumber, string accountHolder, decimal initialBalance)
    {
        this.accountNumber = accountNumber;
        this.AccountHolder = accountHolder;
        this.balance = initialBalance;
    }
    
    // Instance methods - operate on specific account
    public void Deposit(decimal amount)
    {
        balance += amount;
        Console.WriteLine($"{AccountHolder}'s account: Deposited ${amount}. New balance: ${balance}");
    }
    
    public void Withdraw(decimal amount)
    {
        if (amount <= balance)
        {
            balance -= amount;
            Console.WriteLine($"{AccountHolder}'s account: Withdrew ${amount}. New balance: ${balance}");
        }
    }
}

// Usage - each instance has its own data
BankAccount account1 = new BankAccount("ACC001", "Alice", 1000);
BankAccount account2 = new BankAccount("ACC002", "Bob", 500);

account1.Deposit(200);   // Alice's balance: 1200
account2.Deposit(300);   // Bob's balance: 800

// Each object maintains its own state
Console.WriteLine($"Alice's balance: ${account1.Balance}");  // 1200
Console.WriteLine($"Bob's balance: ${account2.Balance}");    // 800</code></pre>
              </div>
              <div class="tab-pane fade" id="instance-java" role="tabpanel">
                <pre class="syntax-highlighted" data-language="Java"><code class="language-java">public class BankAccount {
    // Instance fields - each account has its own values
    private String accountNumber;
    private double balance;
    
    // Instance fields
    private String accountHolder;
    
    public String getAccountHolder() {
        return accountHolder;
    }
    
    public void setAccountHolder(String accountHolder) {
        this.accountHolder = accountHolder;
    }
    
    public double getBalance() {
        return balance;
    }
    
    private void setBalance(double balance) {
        this.balance = balance;
    }
    
    // Instance constructor
    public BankAccount(String accountNumber, String accountHolder, double initialBalance) {
        this.accountNumber = accountNumber;
        this.accountHolder = accountHolder;
        this.balance = initialBalance;
    }
    
    // Instance methods - operate on specific account
    public void deposit(double amount) {
        balance += amount;
        System.out.println(accountHolder + "'s account: Deposited $" + amount + ". New balance: $" + balance);
    }
    
    public void withdraw(double amount) {
        if (amount <= balance) {
            balance -= amount;
            System.out.println(accountHolder + "'s account: Withdrew $" + amount + ". New balance: $" + balance);
        }
    }
}

// Usage - each instance has its own data
BankAccount account1 = new BankAccount("ACC001", "Alice", 1000);
BankAccount account2 = new BankAccount("ACC002", "Bob", 500);

account1.deposit(200);   // Alice's balance: 1200
account2.deposit(300);   // Bob's balance: 800

// Each object maintains its own state
System.out.println("Alice's balance: $" + account1.getBalance());  // 1200
System.out.println("Bob's balance: $" + account2.getBalance());    // 800</code></pre>
              </div>
            </div>
          </div>

          <h2>Static Members</h2>
          <p>
            <strong>Static members</strong> belong to the class itself, not to any specific instance. There's only one 
            copy shared by all instances. You access static members using the class name, not an object reference.
          </p>

          <h3>Static Members Example</h3>
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" data-bs-toggle="tab" data-bs-target="#static-members-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" data-bs-toggle="tab" data-bs-target="#static-members-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="static-members-csharp" role="tabpanel">
                <pre class="syntax-highlighted" data-language="C#"><code class="language-csharp">public class BankAccount
{
    // Static field - shared across all instances
    private static int nextAccountNumber = 1000;
    private static decimal interestRate = 0.03m;
    
    // Static property - shared across all instances
    public static int TotalAccounts { get; private set; }
    public static decimal TotalDeposits { get; private set; }
    
    // Instance fields - each account has its own
    public string AccountNumber { get; private set; }
    public string AccountHolder { get; set; }
    private decimal balance;
    
    public decimal Balance 
    { 
        get { return balance; }
        private set { balance = value; }
    }
    
    // Static constructor - runs once when class is first used
    static BankAccount()
    {
        Console.WriteLine("BankAccount class initialized");
        TotalAccounts = 0;
        TotalDeposits = 0;
    }
    
    // Instance constructor
    public BankAccount(string accountHolder, decimal initialBalance)
    {
        AccountNumber = $"ACC{nextAccountNumber++}";  // Use static field
        AccountHolder = accountHolder;
        balance = initialBalance;
        
        TotalAccounts++;              // Update static property
        TotalDeposits += initialBalance;
    }
    
    // Instance method
    public void Deposit(decimal amount)
    {
        balance += amount;
        TotalDeposits += amount;  // Update static field
        Console.WriteLine($"Deposited ${amount}. Balance: ${balance}");
    }
    
    // Static method - operates on class level
    public static void SetInterestRate(decimal rate)
    {
        if (rate >= 0 && rate <= 0.1m)
        {
            interestRate = rate;
            Console.WriteLine($"Interest rate set to {rate * 100}%");
        }
    }
    
    // Static method
    public static void PrintBankSummary()
    {
        Console.WriteLine($"\n=== Bank Summary ===");
        Console.WriteLine($"Total Accounts: {TotalAccounts}");
        Console.WriteLine($"Total Deposits: ${TotalDeposits}");
        Console.WriteLine($"Interest Rate: {interestRate * 100}%");
        Console.WriteLine("===================\n");
    }
    
    // Instance method that uses static member
    public void ApplyInterest()
    {
        decimal interest = balance * interestRate;
        balance += interest;
        Console.WriteLine($"Interest applied: ${interest}. New balance: ${balance}");
    }
}

// Usage
// Access static members using class name
BankAccount.SetInterestRate(0.05m);

// Create instances
BankAccount account1 = new BankAccount("Alice", 1000);
BankAccount account2 = new BankAccount("Bob", 500);
BankAccount account3 = new BankAccount("Carol", 2000);

// Access instance members using object
account1.Deposit(200);
account2.Deposit(300);

// Access static members using class name
BankAccount.PrintBankSummary();
// Output:
// Total Accounts: 3
// Total Deposits: $4000

// Static data is shared across all instances
account1.ApplyInterest();
account2.ApplyInterest();
account3.ApplyInterest();</code></pre>
              </div>
              <div class="tab-pane fade" id="static-members-java" role="tabpanel">
                <pre class="syntax-highlighted" data-language="Java"><code class="language-java">public class BankAccount {
    // Static field - shared across all instances
    private static int nextAccountNumber = 1000;
    private static double interestRate = 0.03;
    
    // Static fields - shared across all instances
    private static int totalAccounts;
    private static double totalDeposits;
    
    public static int getTotalAccounts() {
        return totalAccounts;
    }
    
    public static double getTotalDeposits() {
        return totalDeposits;
    }
    
    // Instance fields - each account has its own
    private String accountNumber;
    private String accountHolder;
    private double balance;
    
    public String getAccountNumber() {
        return accountNumber;
    }
    
    public String getAccountHolder() {
        return accountHolder;
    }
    
    public void setAccountHolder(String accountHolder) {
        this.accountHolder = accountHolder;
    }
    
    public double getBalance() {
        return balance;
    }
    
    // Static initializer - runs once when class is first used
    static {
        System.out.println("BankAccount class initialized");
        totalAccounts = 0;
        totalDeposits = 0;
    }
    
    // Instance constructor
    public BankAccount(String accountHolder, double initialBalance) {
        this.accountNumber = "ACC" + nextAccountNumber++;  // Use static field
        this.accountHolder = accountHolder;
        this.balance = initialBalance;
        
        totalAccounts++;              // Update static field
        totalDeposits += initialBalance;
    }
    
    // Instance method
    public void deposit(double amount) {
        balance += amount;
        totalDeposits += amount;  // Update static field
        System.out.println("Deposited $" + amount + ". Balance: $" + balance);
    }
    
    // Static method - operates on class level
    public static void setInterestRate(double rate) {
        if (rate >= 0 && rate <= 0.1) {
            interestRate = rate;
            System.out.println("Interest rate set to " + (rate * 100) + "%");
        }
    }
    
    // Static method
    public static void printBankSummary() {
        System.out.println("\n=== Bank Summary ===");
        System.out.println("Total Accounts: " + totalAccounts);
        System.out.println("Total Deposits: $" + totalDeposits);
        System.out.println("Interest Rate: " + (interestRate * 100) + "%");
        System.out.println("===================\n");
    }
    
    // Instance method that uses static member
    public void applyInterest() {
        double interest = balance * interestRate;
        balance += interest;
        System.out.println("Interest applied: $" + interest + ". New balance: $" + balance);
    }
}

// Usage
// Access static methods using class name
BankAccount.setInterestRate(0.05);

// Create instances
BankAccount account1 = new BankAccount("Alice", 1000);
BankAccount account2 = new BankAccount("Bob", 500);
BankAccount account3 = new BankAccount("Carol", 2000);

// Access instance members using object
account1.deposit(200);
account2.deposit(300);

// Access static members using class name
BankAccount.printBankSummary();
// Output:
// Total Accounts: 3
// Total Deposits: $4000

// Static data is shared across all instances
account1.applyInterest();
account2.applyInterest();
account3.applyInterest();</code></pre>
              </div>
            </div>
          </div>

          <h2>Static Class</h2>
          <p>
            A <strong>static class</strong> can only contain static members and cannot be instantiated. Used for 
            utility/helper classes.
          </p>

          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" data-bs-toggle="tab" data-bs-target="#staticclass-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" data-bs-toggle="tab" data-bs-target="#staticclass-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="staticclass-csharp" role="tabpanel">
                <pre class="syntax-highlighted" data-language="C#"><code class="language-csharp">// Static class - cannot create instances
public static class MathHelper
{
    // Static fields
    public static readonly double Pi = 3.14159265359;
    
    // Static methods
    public static int Add(int a, int b)
    {
        return a + b;
    }
    
    public static double CalculateCircleArea(double radius)
    {
        return Pi * radius * radius;
    }
    
    public static int Factorial(int n)
    {
        if (n <= 1) return 1;
        return n * Factorial(n - 1);
    }
}

public static class StringHelper
{
    public static string Capitalize(string text)
    {
        if (string.IsNullOrEmpty(text))
            return text;
        return char.ToUpper(text[0]) + text.Substring(1);
    }
    
    public static string Truncate(string text, int maxLength)
    {
        if (string.IsNullOrEmpty(text) || text.Length <= maxLength)
            return text;
        return text.Substring(0, maxLength) + "...";
    }
}

// Usage - no instance creation needed
int sum = MathHelper.Add(5, 10);                    // 15
double area = MathHelper.CalculateCircleArea(5);    // 78.54
int fact = MathHelper.Factorial(5);                 // 120

string result = StringHelper.Capitalize("hello");   // "Hello"
string truncated = StringHelper.Truncate("Long text here", 8);  // "Long tex..."

// var helper = new MathHelper();  // ‚ùå Cannot create instance of static class</code></pre>
              </div>
              <div class="tab-pane fade" id="staticclass-java" role="tabpanel">
                <pre class="syntax-highlighted" data-language="Java"><code class="language-java">// Utility class with private constructor - prevents instantiation
public final class MathHelper {
    // Private constructor prevents instantiation
    private MathHelper() {
        throw new AssertionError("Utility class cannot be instantiated");
    }
    
    // Static fields
    public static final double PI = 3.14159265359;
    
    // Static methods
    public static int add(int a, int b) {
        return a + b;
    }
    
    public static double calculateCircleArea(double radius) {
        return PI * radius * radius;
    }
    
    public static int factorial(int n) {
        if (n <= 1) return 1;
        return n * factorial(n - 1);
    }
}

public final class StringHelper {
    // Private constructor prevents instantiation
    private StringHelper() {
        throw new AssertionError("Utility class cannot be instantiated");
    }
    
    public static String capitalize(String text) {
        if (text == null || text.isEmpty())
            return text;
        return Character.toUpperCase(text.charAt(0)) + text.substring(1);
    }
    
    public static String truncate(String text, int maxLength) {
        if (text == null || text.isEmpty() || text.length() <= maxLength)
            return text;
        return text.substring(0, maxLength) + "...";
    }
}

// Usage - no instance creation needed
int sum = MathHelper.add(5, 10);                      // 15
double area = MathHelper.calculateCircleArea(5);      // 78.54
int fact = MathHelper.factorial(5);                   // 120

String result = StringHelper.capitalize("hello");     // "Hello"
String truncated = StringHelper.truncate("Long text here", 8);  // "Long tex..."

// MathHelper helper = new MathHelper();  // ‚ùå Cannot create instance - private constructor</code></pre>
              </div>
            </div>
          </div>

          <h2>Static vs Instance Comparison</h2>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th>Aspect</th>
                <th>Instance Members</th>
                <th>Static Members</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Belongs To</strong></td>
                <td>Specific object instance</td>
                <td>Class itself</td>
              </tr>
              <tr>
                <td><strong>Memory</strong></td>
                <td>Each instance has own copy</td>
                <td>One copy shared by all instances</td>
              </tr>
              <tr>
                <td><strong>Access</strong></td>
                <td>Through object reference</td>
                <td>Through class name</td>
              </tr>
              <tr>
                <td><strong>Keyword</strong></td>
                <td>No keyword (default)</td>
                <td><code>static</code> keyword</td>
              </tr>
              <tr>
                <td><strong>Lifetime</strong></td>
                <td>Created/destroyed with object</td>
                <td>Exists for program's lifetime</td>
              </tr>
              <tr>
                <td><strong>Can Access</strong></td>
                <td>Both static and instance members</td>
                <td>Only static members</td>
              </tr>
              <tr>
                <td><strong>Example</strong></td>
                <td>account.Deposit(100)</td>
                <td>Math.Sqrt(16)</td>
              </tr>
            </tbody>
          </table>

          <h2>Real-World Example: Logger</h2>
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" data-bs-toggle="tab" data-bs-target="#logger-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" data-bs-toggle="tab" data-bs-target="#logger-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="logger-csharp" role="tabpanel">
                <pre class="syntax-highlighted" data-language="C#"><code class="language-csharp">public class Logger
{
    // Static members - shared logging configuration
    private static string logFilePath = "app.log";
    private static LogLevel minimumLevel = LogLevel.Info;
    
    // Static method to configure logging
    public static void Configure(string filePath, LogLevel level)
    {
        logFilePath = filePath;
        minimumLevel = level;
        Console.WriteLine($"Logger configured: {filePath}, Level: {level}");
    }
    
    // Instance members - per-logger context
    private string category;
    private List&lt;string&gt; messages;
    
    public Logger(string category)
    {
        this.category = category;
        this.messages = new List&lt;string&gt;();
    }
    
    // Instance method using both instance and static data
    public void Log(LogLevel level, string message)
    {
        if (level < minimumLevel)  // Check static field
            return;
        
        string logMessage = $"[{DateTime.Now:yyyy-MM-dd HH:mm:ss}] [{category}] [{level}] {message}";
        messages.Add(logMessage);  // Store in instance field
        
        // Write to static log file
        File.AppendAllText(logFilePath, logMessage + Environment.NewLine);
        Console.WriteLine(logMessage);
    }
    
    public void Info(string message) =&gt; Log(LogLevel.Info, message);
    public void Warning(string message) =&gt; Log(LogLevel.Warning, message);
    public void Error(string message) =&gt; Log(LogLevel.Error, message);
}

public enum LogLevel
{
    Debug,
    Info,
    Warning,
    Error
}

// Usage
// Configure once for entire application (static)
Logger.Configure("application.log", LogLevel.Info);

// Create separate loggers for different components (instance)
Logger dbLogger = new Logger("Database");
Logger apiLogger = new Logger("API");

dbLogger.Info("Database connection established");
apiLogger.Warning("API rate limit approaching");
dbLogger.Error("Query failed");

// Each logger has its own category, but all write to same file</code></pre>
              </div>
              <div class="tab-pane fade" id="logger-java" role="tabpanel">
                <pre class="syntax-highlighted" data-language="Java"><code class="language-java">import java.io.FileWriter;
import java.io.IOException;
import java.io.PrintWriter;
import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;
import java.util.ArrayList;
import java.util.List;

public class Logger {
    // Static members - shared logging configuration
    private static String logFilePath = "app.log";
    private static LogLevel minimumLevel = LogLevel.INFO;
    
    // Static method to configure logging
    public static void configure(String filePath, LogLevel level) {
        logFilePath = filePath;
        minimumLevel = level;
        System.out.println("Logger configured: " + filePath + ", Level: " + level);
    }
    
    // Instance members - per-logger context
    private String category;
    private List&lt;String&gt; messages;
    
    public Logger(String category) {
        this.category = category;
        this.messages = new ArrayList&lt;&gt;();
    }
    
    // Instance method using both instance and static data
    public void log(LogLevel level, String message) {
        if (level.ordinal() < minimumLevel.ordinal())  // Check static field
            return;
        
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        String logMessage = "[" + LocalDateTime.now().format(formatter) + "] [" + 
                           category + "] [" + level + "] " + message;
        messages.add(logMessage);  // Store in instance field
        
        // Write to static log file
        try (PrintWriter writer = new PrintWriter(new FileWriter(logFilePath, true))) {
            writer.println(logMessage);
        } catch (IOException e) {
            e.printStackTrace();
        }
        System.out.println(logMessage);
    }
    
    public void info(String message) {
        log(LogLevel.INFO, message);
    }
    
    public void warning(String message) {
        log(LogLevel.WARNING, message);
    }
    
    public void error(String message) {
        log(LogLevel.ERROR, message);
    }
}

enum LogLevel {
    DEBUG,
    INFO,
    WARNING,
    ERROR
}

// Usage
// Configure once for entire application (static)
Logger.configure("application.log", LogLevel.INFO);

// Create separate loggers for different components (instance)
Logger dbLogger = new Logger("Database");
Logger apiLogger = new Logger("API");

dbLogger.info("Database connection established");
apiLogger.warning("API rate limit approaching");
dbLogger.error("Query failed");

// Each logger has its own category, but all write to same file</code></pre>
              </div>
            </div>
          </div>

          <h2>Visualization</h2>
          <div class="mermaid">
classDiagram
    class BankAccount {
        -static int nextAccountNumber$
        -static decimal interestRate$
        +static int TotalAccounts$
        -string accountNumber
        -decimal balance
        +string AccountHolder
        +BankAccount(string, decimal)
        +Deposit(decimal) void
        +static SetInterestRate(decimal)$ void
        +static PrintBankSummary()$ void
    }
    
    class Account1 {
        accountNumber: "ACC1000"
        balance: 1000
        AccountHolder: "Alice"
    }
    
    class Account2 {
        accountNumber: "ACC1001"
        balance: 500
        AccountHolder: "Bob"
    }
    
    BankAccount <|.. Account1 : instance
    BankAccount <|.. Account2 : instance
    
    note for BankAccount "Static members (marked with $)
    are shared across all instances
    
    Instance members
    are unique to each object"
          </div>

          <h2>When to Use Static Members</h2>
          <ul>
            <li><strong>Utility Methods:</strong> Math.Sqrt(), String.IsNullOrEmpty(), Path.Combine()</li>
            <li><strong>Constants:</strong> Math.PI, int.MaxValue</li>
            <li><strong>Factory Methods:</strong> DateTime.Now, Guid.NewGuid()</li>
            <li><strong>Shared Configuration:</strong> Application settings, database connections</li>
            <li><strong>Counters/Tracking:</strong> Total instances created, unique ID generation</li>
            <li><strong>Extension Methods:</strong> LINQ methods (Where, Select, etc.)</li>
          </ul>

          <h2>Best Practices</h2>
          <ul>
            <li><strong>Avoid Overusing Static:</strong> Makes testing difficult, creates global state</li>
            <li><strong>Thread Safety:</strong> Static members shared across threads need synchronization</li>
            <li><strong>Static Constructors:</strong> Used for one-time initialization of static data</li>
            <li><strong>Don't Mix:</strong> Static methods cannot access instance members directly</li>
            <li><strong>Memory Consideration:</strong> Static members remain in memory for application lifetime</li>
          </ul>

          <div class="callout">
            <strong>üí° Guideline:</strong> Use instance members when data or behavior is specific to each object. 
            Use static members for functionality that doesn't depend on object state (utilities, helpers, constants) 
            or when you need to share data across all instances. Remember: static = class-level, instance = object-level.
          </div>
        </section>

        <!-- Constructors & Destructors Section -->
        <section id="constructors" role="article">
          <h1>üèóÔ∏è Constructors & Destructors</h1>
          <span class="badge">initialization</span>
          <span class="badge">cleanup</span>
          <span class="badge">lifecycle</span>
          
          <h2>Understanding Object Lifecycle</h2>
          <p>
            <strong>Constructors</strong> and <strong>Destructors</strong> (Finalizers in C#) manage the lifecycle of objects‚Äîfrom 
            creation to destruction. Constructors initialize objects with valid state, while destructors clean up resources 
            before the object is garbage collected.
          </p>

          <h2>Constructors</h2>
          <p>
            A <strong>constructor</strong> is a special method that is automatically called when an object is created. It has 
            the same name as the class and no return type. Constructors ensure objects start with a valid initial state.
          </p>

          <h3>1. Default Constructor</h3>
          <p>A constructor with no parameters. If you don't define any constructor, C# provides a default one.</p>
          
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" data-bs-toggle="tab" data-bs-target="#defaultctor-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" data-bs-toggle="tab" data-bs-target="#defaultctor-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="defaultctor-csharp" role="tabpanel">
                <pre class="syntax-highlighted" data-language="C#"><code class="language-csharp">public class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
    
    // Default constructor - explicitly defined
    public Person()
    {
        Name = "Unknown";
        Age = 0;
        Console.WriteLine("Default constructor called");
    }
}

// Usage
Person person = new Person();
Console.WriteLine($"{person.Name}, {person.Age}");  // Output: Unknown, 0</code></pre>
              </div>
              <div class="tab-pane fade" id="defaultctor-java" role="tabpanel">
                <pre class="syntax-highlighted" data-language="Java"><code class="language-java">public class Person {
    private String name;
    private int age;
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public int getAge() {
        return age;
    }
    
    public void setAge(int age) {
        this.age = age;
    }
    
    // Default constructor - explicitly defined
    public Person() {
        name = "Unknown";
        age = 0;
        System.out.println("Default constructor called");
    }
}

// Usage
Person person = new Person();
System.out.println(person.getName() + ", " + person.getAge());  // Output: Unknown, 0</code></pre>
              </div>
            </div>
          </div>

          <h3>2. Parameterized Constructor</h3>
          <p>A constructor that accepts parameters to initialize object with specific values.</p>
          
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" data-bs-toggle="tab" data-bs-target="#paramctor-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" data-bs-toggle="tab" data-bs-target="#paramctor-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="paramctor-csharp" role="tabpanel">
                <pre class="syntax-highlighted" data-language="C#"><code class="language-csharp">public class Person
{
    public string Name { get; set; }
    public int Age { get; set; }
    public string Email { get; set; }
    
    // Parameterized constructor
    public Person(string name, int age)
    {
        Name = name;
        Age = age;
        Console.WriteLine($"Constructor called for {Name}");
    }
    
    // Another parameterized constructor
    public Person(string name, int age, string email)
    {
        Name = name;
        Age = age;
        Email = email;
        Console.WriteLine($"Constructor called for {Name} with email");
    }
}

// Usage
Person person1 = new Person("Alice", 30);
Person person2 = new Person("Bob", 25, "bob@example.com");</code></pre>
              </div>
              <div class="tab-pane fade" id="paramctor-java" role="tabpanel">
                <pre class="syntax-highlighted" data-language="Java"><code class="language-java">public class Person {
    private String name;
    private int age;
    private String email;
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public int getAge() {
        return age;
    }
    
    public void setAge(int age) {
        this.age = age;
    }
    
    public String getEmail() {
        return email;
    }
    
    public void setEmail(String email) {
        this.email = email;
    }
    
    // Parameterized constructor
    public Person(String name, int age) {
        this.name = name;
        this.age = age;
        System.out.println("Constructor called for " + name);
    }
    
    // Another parameterized constructor
    public Person(String name, int age, String email) {
        this.name = name;
        this.age = age;
        this.email = email;
        System.out.println("Constructor called for " + name + " with email");
    }
}

// Usage
Person person1 = new Person("Alice", 30);
Person person2 = new Person("Bob", 25, "bob@example.com");</code></pre>
              </div>
            </div>
          </div>

          <h3>3. Constructor Overloading</h3>
          <p>Multiple constructors with different parameter lists.</p>
          
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" data-bs-toggle="tab" data-bs-target="#ctoroverload-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" data-bs-toggle="tab" data-bs-target="#ctoroverload-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="ctoroverload-csharp" role="tabpanel">
                <pre class="syntax-highlighted" data-language="C#"><code class="language-csharp">public class Rectangle
{
    public double Width { get; set; }
    public double Height { get; set; }
    
    // Default constructor - creates a square with default size
    public Rectangle()
    {
        Width = 1.0;
        Height = 1.0;
    }
    
    // Constructor for square
    public Rectangle(double size)
    {
        Width = size;
        Height = size;
    }
    
    // Constructor for rectangle
    public Rectangle(double width, double height)
    {
        Width = width;
        Height = height;
    }
    
    public double CalculateArea()
    {
        return Width * Height;
    }
}

// Usage - different ways to create rectangles
Rectangle rect1 = new Rectangle();           // 1x1 square
Rectangle rect2 = new Rectangle(5);          // 5x5 square
Rectangle rect3 = new Rectangle(4, 6);       // 4x6 rectangle

Console.WriteLine($"Area 1: {rect1.CalculateArea()}");  // 1
Console.WriteLine($"Area 2: {rect2.CalculateArea()}");  // 25
Console.WriteLine($"Area 3: {rect3.CalculateArea()}");  // 24</code></pre>
              </div>
              <div class="tab-pane fade" id="ctoroverload-java" role="tabpanel">
                <pre class="syntax-highlighted" data-language="Java"><code class="language-java">public class Rectangle {
    private double width;
    private double height;
    
    public double getWidth() {
        return width;
    }
    
    public void setWidth(double width) {
        this.width = width;
    }
    
    public double getHeight() {
        return height;
    }
    
    public void setHeight(double height) {
        this.height = height;
    }
    
    // Default constructor - creates a square with default size
    public Rectangle() {
        this.width = 1.0;
        this.height = 1.0;
    }
    
    // Constructor for square
    public Rectangle(double size) {
        this.width = size;
        this.height = size;
    }
    
    // Constructor for rectangle
    public Rectangle(double width, double height) {
        this.width = width;
        this.height = height;
    }
    
    public double calculateArea() {
        return width * height;
    }
}

// Usage - different ways to create rectangles
Rectangle rect1 = new Rectangle();           // 1x1 square
Rectangle rect2 = new Rectangle(5);          // 5x5 square
Rectangle rect3 = new Rectangle(4, 6);       // 4x6 rectangle

System.out.println("Area 1: " + rect1.calculateArea());  // 1
System.out.println("Area 2: " + rect2.calculateArea());  // 25
System.out.println("Area 3: " + rect3.calculateArea());  // 24</code></pre>
              </div>
            </div>
          </div>

          <h3>4. Constructor Chaining (this keyword)</h3>
          <p>One constructor calling another constructor in the same class to avoid code duplication.</p>
          
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" data-bs-toggle="tab" data-bs-target="#ctorchain-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" data-bs-toggle="tab" data-bs-target="#ctorchain-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="ctorchain-csharp" role="tabpanel">
                <pre class="syntax-highlighted" data-language="C#"><code class="language-csharp">public class Employee
{
    public string Name { get; set; }
    public string Department { get; set; }
    public decimal Salary { get; set; }
    public DateTime HireDate { get; set; }
    
    // Primary constructor with all parameters
    public Employee(string name, string department, decimal salary, DateTime hireDate)
    {
        Name = name;
        Department = department;
        Salary = salary;
        HireDate = hireDate;
        Console.WriteLine($"Full constructor: {Name} hired in {Department}");
    }
    
    // Constructor chaining - calls the primary constructor
    public Employee(string name, string department, decimal salary)
        : this(name, department, salary, DateTime.Now)
    {
        Console.WriteLine("Using default hire date (today)");
    }
    
    // Another chaining constructor
    public Employee(string name, string department)
        : this(name, department, 50000m, DateTime.Now)
    {
        Console.WriteLine("Using default salary and hire date");
    }
    
    // Minimal constructor
    public Employee(string name)
        : this(name, "General", 50000m, DateTime.Now)
    {
        Console.WriteLine("Using all defaults except name");
    }
}

// Usage - all constructors reuse the primary constructor logic
Employee emp1 = new Employee("Alice", "IT", 75000m, new DateTime(2024, 1, 15));
Employee emp2 = new Employee("Bob", "HR", 60000m);
Employee emp3 = new Employee("Carol", "Sales");
Employee emp4 = new Employee("David");</code></pre>
              </div>
              <div class="tab-pane fade" id="ctorchain-java" role="tabpanel">
                <pre class="syntax-highlighted" data-language="Java"><code class="language-java">import java.time.LocalDate;

public class Employee {
    private String name;
    private String department;
    private double salary;
    private LocalDate hireDate;
    
    public String getName() {
        return name;
    }
    
    public void setName(String name) {
        this.name = name;
    }
    
    public String getDepartment() {
        return department;
    }
    
    public void setDepartment(String department) {
        this.department = department;
    }
    
    public double getSalary() {
        return salary;
    }
    
    public void setSalary(double salary) {
        this.salary = salary;
    }
    
    public LocalDate getHireDate() {
        return hireDate;
    }
    
    public void setHireDate(LocalDate hireDate) {
        this.hireDate = hireDate;
    }
    
    // Primary constructor with all parameters
    public Employee(String name, String department, double salary, LocalDate hireDate) {
        this.name = name;
        this.department = department;
        this.salary = salary;
        this.hireDate = hireDate;
        System.out.println("Full constructor: " + name + " hired in " + department);
    }
    
    // Constructor chaining - calls the primary constructor
    public Employee(String name, String department, double salary) {
        this(name, department, salary, LocalDate.now());
        System.out.println("Using default hire date (today)");
    }
    
    // Another chaining constructor
    public Employee(String name, String department) {
        this(name, department, 50000.0, LocalDate.now());
        System.out.println("Using default salary and hire date");
    }
    
    // Minimal constructor
    public Employee(String name) {
        this(name, "General", 50000.0, LocalDate.now());
        System.out.println("Using all defaults except name");
    }
}

// Usage - all constructors reuse the primary constructor logic
Employee emp1 = new Employee("Alice", "IT", 75000.0, LocalDate.of(2024, 1, 15));
Employee emp2 = new Employee("Bob", "HR", 60000.0);
Employee emp3 = new Employee("Carol", "Sales");
Employee emp4 = new Employee("David");</code></pre>
              </div>
            </div>
          </div>

          <h3>5. Constructor with Inheritance (base keyword)</h3>
          <p>Calling the base class constructor from a derived class constructor.</p>
          
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" data-bs-toggle="tab" data-bs-target="#ctorinherit-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" data-bs-toggle="tab" data-bs-target="#ctorinherit-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="ctorinherit-csharp" role="tabpanel">
                <pre class="syntax-highlighted" data-language="C#"><code class="language-csharp">public class Vehicle
{
    public string Brand { get; set; }
    public string Model { get; set; }
    public int Year { get; set; }
    
    public Vehicle(string brand, string model, int year)
    {
        Brand = brand;
        Model = model;
        Year = year;
        Console.WriteLine($"Vehicle constructor: {Brand} {Model}");
    }
}

public class Car : Vehicle
{
    public int NumberOfDoors { get; set; }
    public string FuelType { get; set; }
    
    // Call base class constructor, then initialize derived class members
    public Car(string brand, string model, int year, int doors, string fuelType)
        : base(brand, model, year)  // Call base constructor first
    {
        NumberOfDoors = doors;
        FuelType = fuelType;
        Console.WriteLine($"Car constructor: {doors} doors, {fuelType}");
    }
    
    public void DisplayInfo()
    {
        Console.WriteLine($"{Year} {Brand} {Model}");
        Console.WriteLine($"{NumberOfDoors} doors, {FuelType}");
    }
}

// Usage
Car myCar = new Car("Toyota", "Camry", 2024, 4, "Hybrid");
// Output:
// Vehicle constructor: Toyota Camry
// Car constructor: 4 doors, Hybrid
myCar.DisplayInfo();</code></pre>
              </div>
              <div class="tab-pane fade" id="ctorinherit-java" role="tabpanel">
                <pre class="syntax-highlighted" data-language="Java"><code class="language-java">public class Vehicle {
    private String brand;
    private String model;
    private int year;
    
    public String getBrand() {
        return brand;
    }
    
    public void setBrand(String brand) {
        this.brand = brand;
    }
    
    public String getModel() {
        return model;
    }
    
    public void setModel(String model) {
        this.model = model;
    }
    
    public int getYear() {
        return year;
    }
    
    public void setYear(int year) {
        this.year = year;
    }
    
    public Vehicle(String brand, String model, int year) {
        this.brand = brand;
        this.model = model;
        this.year = year;
        System.out.println("Vehicle constructor: " + brand + " " + model);
    }
}

class Car extends Vehicle {
    private int numberOfDoors;
    private String fuelType;
    
    public int getNumberOfDoors() {
        return numberOfDoors;
    }
    
    public void setNumberOfDoors(int numberOfDoors) {
        this.numberOfDoors = numberOfDoors;
    }
    
    public String getFuelType() {
        return fuelType;
    }
    
    public void setFuelType(String fuelType) {
        this.fuelType = fuelType;
    }
    
    // Call base class constructor, then initialize derived class members
    public Car(String brand, String model, int year, int doors, String fuelType) {
        super(brand, model, year);  // Call base constructor first
        this.numberOfDoors = doors;
        this.fuelType = fuelType;
        System.out.println("Car constructor: " + doors + " doors, " + fuelType);
    }
    
    public void displayInfo() {
        System.out.println(getYear() + " " + getBrand() + " " + getModel());
        System.out.println(numberOfDoors + " doors, " + fuelType);
    }
}

// Usage
Car myCar = new Car("Toyota", "Camry", 2024, 4, "Hybrid");
// Output:
// Vehicle constructor: Toyota Camry
// Car constructor: 4 doors, Hybrid
myCar.displayInfo();</code></pre>
              </div>
            </div>
          </div>

          <h3>6. Static Constructor</h3>
          <p>Initializes static members. Called once before any static member is accessed or instance is created.</p>
          
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" data-bs-toggle="tab" data-bs-target="#staticctor-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" data-bs-toggle="tab" data-bs-target="#staticctor-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="staticctor-csharp" role="tabpanel">
                <pre class="syntax-highlighted" data-language="C#"><code class="language-csharp">public class Configuration
{
    public static string AppName { get; private set; }
    public static string Version { get; private set; }
    public static DateTime StartTime { get; private set; }
    
    // Static constructor - runs once
    static Configuration()
    {
        Console.WriteLine("Static constructor called - initializing configuration");
        AppName = "MyApplication";
        Version = "1.0.0";
        StartTime = DateTime.Now;
    }
    
    // Instance constructor
    public Configuration()
    {
        Console.WriteLine("Instance constructor called");
    }
}

// Usage
Console.WriteLine("Before accessing Configuration");
Console.WriteLine(Configuration.AppName);  // Static constructor runs here
// Output: Static constructor called - initializing configuration
//         MyApplication

Configuration config = new Configuration();  // Instance constructor runs
// Output: Instance constructor called</code></pre>
              </div>
              <div class="tab-pane fade" id="staticctor-java" role="tabpanel">
                <pre class="syntax-highlighted" data-language="Java"><code class="language-java">import java.time.LocalDateTime;

public class Configuration {
    private static String appName;
    private static String version;
    private static LocalDateTime startTime;
    
    public static String getAppName() {
        return appName;
    }
    
    public static String getVersion() {
        return version;
    }
    
    public static LocalDateTime getStartTime() {
        return startTime;
    }
    
    // Static initializer block - runs once
    static {
        System.out.println("Static initializer called - initializing configuration");
        appName = "MyApplication";
        version = "1.0.0";
        startTime = LocalDateTime.now();
    }
    
    // Instance constructor
    public Configuration() {
        System.out.println("Instance constructor called");
    }
}

// Usage
System.out.println("Before accessing Configuration");
System.out.println(Configuration.getAppName());  // Static initializer runs here
// Output: Static initializer called - initializing configuration
//         MyApplication

Configuration config = new Configuration();  // Instance constructor runs
// Output: Instance constructor called</code></pre>
              </div>
            </div>
          </div>

          <h2>Destructors (Finalizers)</h2>
          <p>
            A <strong>destructor</strong> (finalizer in C#) is called by the garbage collector before an object is destroyed. 
            Used to release unmanaged resources. Syntax: <code>~ClassName()</code>
          </p>

          <h3>Destructor Example</h3>
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" data-bs-toggle="tab" data-bs-target="#destructor-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" data-bs-toggle="tab" data-bs-target="#destructor-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="destructor-csharp" role="tabpanel">
                <pre class="syntax-highlighted" data-language="C#"><code class="language-csharp">public class FileHandler
{
    private string filePath;
    private bool isDisposed;
    
    public FileHandler(string filePath)
    {
        this.filePath = filePath;
        Console.WriteLine($"Constructor: FileHandler created for {filePath}");
    }
    
    public void WriteData(string data)
    {
        Console.WriteLine($"Writing data to {filePath}: {data}");
        // File writing logic here
    }
    
    // Destructor (Finalizer)
    ~FileHandler()
    {
        Console.WriteLine($"Destructor: Cleaning up FileHandler for {filePath}");
        // Release unmanaged resources
        Cleanup();
    }
    
    private void Cleanup()
    {
        if (!isDisposed)
        {
            Console.WriteLine("Performing cleanup operations");
            // Close file handles, release memory, etc.
            isDisposed = true;
        }
    }
}

// Usage
void TestFileHandler()
{
    FileHandler handler = new FileHandler("data.txt");
    handler.WriteData("Test data");
    // handler goes out of scope here
}

TestFileHandler();
GC.Collect();  // Force garbage collection to demonstrate
GC.WaitForPendingFinalizers();
// Output: Destructor: Cleaning up FileHandler for data.txt</code></pre>
              </div>
              <div class="tab-pane fade" id="destructor-java" role="tabpanel">
                <pre class="syntax-highlighted" data-language="Java"><code class="language-java">public class FileHandler {
    private String filePath;
    private boolean isDisposed;
    
    public FileHandler(String filePath) {
        this.filePath = filePath;
        System.out.println("Constructor: FileHandler created for " + filePath);
    }
    
    public void writeData(String data) {
        System.out.println("Writing data to " + filePath + ": " + data);
        // File writing logic here
    }
    
    // Finalizer (deprecated since Java 9, use Cleaner API instead)
    @Override
    protected void finalize() throws Throwable {
        try {
            System.out.println("Finalizer: Cleaning up FileHandler for " + filePath);
            // Release unmanaged resources
            cleanup();
        } finally {
            super.finalize();
        }
    }
    
    private void cleanup() {
        if (!isDisposed) {
            System.out.println("Performing cleanup operations");
            // Close file handles, release memory, etc.
            isDisposed = true;
        }
    }
}

// Usage
public static void testFileHandler() {
    FileHandler handler = new FileHandler("data.txt");
    handler.writeData("Test data");
    // handler goes out of scope here
}

testFileHandler();
System.gc();  // Suggest garbage collection (not guaranteed)
System.runFinalization();
// Output: Finalizer: Cleaning up FileHandler for data.txt
// Note: finalize() is deprecated; use try-with-resources or Cleaner API</code></pre>
              </div>
            </div>
          </div>

          <h3>IDisposable Pattern (Preferred over Destructor)</h3>
          <p>For deterministic cleanup, implement IDisposable instead of relying on destructor.</p>
          
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" data-bs-toggle="tab" data-bs-target="#idisposable-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" data-bs-toggle="tab" data-bs-target="#idisposable-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="idisposable-csharp" role="tabpanel">
                <pre class="syntax-highlighted" data-language="C#"><code class="language-csharp">public class DatabaseConnection : IDisposable
{
    private string connectionString;
    private bool isConnected;
    private bool disposed;
    
    public DatabaseConnection(string connectionString)
    {
        this.connectionString = connectionString;
        Connect();
    }
    
    private void Connect()
    {
        Console.WriteLine($"Connecting to database: {connectionString}");
        isConnected = true;
    }
    
    public void ExecuteQuery(string query)
    {
        if (!isConnected)
            throw new InvalidOperationException("Not connected");
        Console.WriteLine($"Executing query: {query}");
    }
    
    // Implement IDisposable
    public void Dispose()
    {
        Dispose(true);
        GC.SuppressFinalize(this);  // Prevent finalizer from running
    }
    
    // Protected dispose method
    protected virtual void Dispose(bool disposing)
    {
        if (disposed) return;
        
        if (disposing)
        {
            // Dispose managed resources
            Console.WriteLine("Disposing managed resources");
        }
        
        // Dispose unmanaged resources
        if (isConnected)
        {
            Console.WriteLine("Closing database connection");
            isConnected = false;
        }
        
        disposed = true;
    }
    
    // Destructor as backup
    ~DatabaseConnection()
    {
        Console.WriteLine("Finalizer called");
        Dispose(false);
    }
}

// Usage with using statement
using (DatabaseConnection conn = new DatabaseConnection("Server=localhost"))
{
    conn.ExecuteQuery("SELECT * FROM Users");
}  // Dispose automatically called here

// Or manual disposal
DatabaseConnection conn2 = new DatabaseConnection("Server=localhost");
try
{
    conn2.ExecuteQuery("SELECT * FROM Products");
}
finally
{
    conn2.Dispose();  // Explicitly call Dispose
}</code></pre>
              </div>
              <div class="tab-pane fade" id="idisposable-java" role="tabpanel">
                <pre class="syntax-highlighted" data-language="Java"><code class="language-java">public class DatabaseConnection implements AutoCloseable {
    private String connectionString;
    private boolean isConnected;
    private boolean disposed;
    
    public DatabaseConnection(String connectionString) {
        this.connectionString = connectionString;
        connect();
    }
    
    private void connect() {
        System.out.println("Connecting to database: " + connectionString);
        isConnected = true;
    }
    
    public void executeQuery(String query) {
        if (!isConnected)
            throw new IllegalStateException("Not connected");
        System.out.println("Executing query: " + query);
    }
    
    // Implement AutoCloseable
    @Override
    public void close() {
        dispose(true);
    }
    
    // Protected dispose method
    protected void dispose(boolean disposing) {
        if (disposed) return;
        
        if (disposing) {
            // Dispose managed resources
            System.out.println("Disposing managed resources");
        }
        
        // Dispose unmanaged resources
        if (isConnected) {
            System.out.println("Closing database connection");
            isConnected = false;
        }
        
        disposed = true;
    }
    
    // Finalizer as backup (deprecated, but shown for comparison)
    @Override
    protected void finalize() throws Throwable {
        try {
            System.out.println("Finalizer called");
            dispose(false);
        } finally {
            super.finalize();
        }
    }
}

// Usage with try-with-resources statement
try (DatabaseConnection conn = new DatabaseConnection("Server=localhost")) {
    conn.executeQuery("SELECT * FROM Users");
}  // close() automatically called here

// Or manual disposal
DatabaseConnection conn2 = new DatabaseConnection("Server=localhost");
try {
    conn2.executeQuery("SELECT * FROM Products");
} finally {
    conn2.close();  // Explicitly call close
}</code></pre>
              </div>
            </div>
          </div>

          <h2>Constructor Execution Order</h2>
          <div class="mermaid">
sequenceDiagram
    participant Client
    participant Derived
    participant Base
    participant GC as Garbage Collector
    
    Client->>Derived: new DerivedClass()
    Derived->>Base: Call base constructor
    Base->>Base: Initialize base fields
    Base->>Base: Execute base constructor body
    Base-->>Derived: Base initialized
    Derived->>Derived: Initialize derived fields
    Derived->>Derived: Execute derived constructor body
    Derived-->>Client: Object created
    
    Note over Client,Derived: Object usage
    
    Client->>Derived: object = null
    GC->>Derived: Mark for collection
    GC->>Derived: Call finalizer
    Derived->>GC: Cleanup complete
          </div>

          <h2>Best Practices</h2>
          <div class="row g-3">
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-green">
                <div class="card-body">
                  <h3>‚úÖ Do</h3>
                  <ul class="list-style-none">
                    <li>‚úì Initialize all fields in constructor</li>
                    <li>‚úì Use constructor chaining to avoid duplication</li>
                    <li>‚úì Validate parameters in constructor</li>
                    <li>‚úì Use IDisposable for deterministic cleanup</li>
                    <li>‚úì Keep constructors simple and fast</li>
                    <li>‚úì Document required constructor parameters</li>
                  </ul>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-red">
                <div class="card-body">
                  <h3>‚ùå Don't</h3>
                  <ul class="list-style-none">
                    <li>‚úó Call virtual methods in constructor</li>
                    <li>‚úó Perform heavy operations in constructor</li>
                    <li>‚úó Throw exceptions unless critical</li>
                    <li>‚úó Rely on destructor for cleanup</li>
                    <li>‚úó Create circular dependencies</li>
                    <li>‚úó Access incomplete state</li>
                  </ul>
                </div>
              </div>
            </div>
          </div>

          <h2>Constructor vs Destructor</h2>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th>Aspect</th>
                <th>Constructor</th>
                <th>Destructor</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Purpose</strong></td>
                <td>Initialize object</td>
                <td>Cleanup resources</td>
              </tr>
              <tr>
                <td><strong>Syntax</strong></td>
                <td><code>public ClassName()</code></td>
                <td><code>~ClassName()</code></td>
              </tr>
              <tr>
                <td><strong>When Called</strong></td>
                <td>Object creation</td>
                <td>Before garbage collection</td>
              </tr>
              <tr>
                <td><strong>Parameters</strong></td>
                <td>Can have parameters</td>
                <td>No parameters allowed</td>
              </tr>
              <tr>
                <td><strong>Overloading</strong></td>
                <td>‚úÖ Yes</td>
                <td>‚ùå No</td>
              </tr>
              <tr>
                <td><strong>Access Modifier</strong></td>
                <td>public, private, protected</td>
                <td>No access modifier</td>
              </tr>
              <tr>
                <td><strong>Timing</strong></td>
                <td>Deterministic (immediate)</td>
                <td>Non-deterministic (GC decides)</td>
              </tr>
            </tbody>
          </table>

          <div class="callout">
            <strong>üí° Key Insight:</strong> Constructors are essential for object initialization‚Äîthey ensure objects 
            start in a valid state. Destructors are rarely needed in C#; prefer <code>IDisposable</code> pattern for 
            resource cleanup. The <code>using</code> statement provides deterministic disposal, making cleanup predictable 
            and reliable.
          </div>
        </section>

        <!-- Method Overloading Section -->
        <section id="method-overloading" role="article">
          <h1>üîÑ Method Overloading</h1>
          <span class="badge">polymorphism</span>
          <span class="badge">compile-time</span>
          <span class="badge">signature</span>
          
          <h2>What is Method Overloading?</h2>
          <p>
            <strong>Method Overloading</strong> (also called compile-time polymorphism or static polymorphism) is the ability 
            to define multiple methods with the same name but different parameters in the same class. The compiler determines 
            which method to call based on the method signature.
          </p>

          <h2>Method Signature</h2>
          <p>
            A method signature consists of:
          </p>
          <ul>
            <li>Method name</li>
            <li>Number of parameters</li>
            <li>Type of parameters</li>
            <li>Order of parameters</li>
          </ul>
          <p>
            <strong>Note:</strong> Return type is NOT part of the method signature and cannot be used for overloading.
          </p>

          <h2>Basic Method Overloading</h2>
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" data-bs-toggle="tab" data-bs-target="#overloading-basic-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" data-bs-toggle="tab" data-bs-target="#overloading-basic-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="overloading-basic-csharp" role="tabpanel">
                <pre class="syntax-highlighted" data-language="C#"><code class="language-csharp">public class Calculator
{
    // Overloaded methods - same name, different parameters
    
    // Method 1: Two integers
    public int Add(int a, int b)
    {
        Console.WriteLine("Adding two integers");
        return a + b;
    }
    
    // Method 2: Three integers (different number of parameters)
    public int Add(int a, int b, int c)
    {
        Console.WriteLine("Adding three integers");
        return a + b + c;
    }
    
    // Method 3: Two doubles (different parameter types)
    public double Add(double a, double b)
    {
        Console.WriteLine("Adding two doubles");
        return a + b;
    }
    
    // Method 4: String concatenation (different parameter types)
    public string Add(string a, string b)
    {
        Console.WriteLine("Concatenating two strings");
        return a + b;
    }
}

// Usage - compiler selects the appropriate method
Calculator calc = new Calculator();

int result1 = calc.Add(5, 10);              // Calls Add(int, int) ‚Üí 15
int result2 = calc.Add(5, 10, 15);          // Calls Add(int, int, int) ‚Üí 30
double result3 = calc.Add(5.5, 10.5);       // Calls Add(double, double) ‚Üí 16.0
string result4 = calc.Add("Hello", "World"); // Calls Add(string, string) ‚Üí "HelloWorld"</code></pre>
              </div>
              <div class="tab-pane fade" id="overloading-basic-java" role="tabpanel">
                <pre class="syntax-highlighted" data-language="Java"><code class="language-java">public class Calculator {
    // Overloaded methods - same name, different parameters
    
    // Method 1: Two integers
    public int add(int a, int b) {
        System.out.println("Adding two integers");
        return a + b;
    }
    
    // Method 2: Three integers (different number of parameters)
    public int add(int a, int b, int c) {
        System.out.println("Adding three integers");
        return a + b + c;
    }
    
    // Method 3: Two doubles (different parameter types)
    public double add(double a, double b) {
        System.out.println("Adding two doubles");
        return a + b;
    }
    
    // Method 4: String concatenation (different parameter types)
    public String add(String a, String b) {
        System.out.println("Concatenating two strings");
        return a + b;
    }
}

// Usage - compiler selects the appropriate method
Calculator calc = new Calculator();

int result1 = calc.add(5, 10);              // Calls add(int, int) ‚Üí 15
int result2 = calc.add(5, 10, 15);          // Calls add(int, int, int) ‚Üí 30
double result3 = calc.add(5.5, 10.5);       // Calls add(double, double) ‚Üí 16.0
String result4 = calc.add("Hello", "World"); // Calls add(String, String) ‚Üí "HelloWorld"</code></pre>
              </div>
            </div>
          </div>

          <h2>Overloading with Different Parameter Order</h2>
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" data-bs-toggle="tab" data-bs-target="#overloading-order-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" data-bs-toggle="tab" data-bs-target="#overloading-order-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="overloading-order-csharp" role="tabpanel">
                <pre class="syntax-highlighted" data-language="C#"><code class="language-csharp">public class OrderProcessor
{
    // Different parameter order creates different signatures
    
    public void ProcessOrder(string customerName, int orderId)
    {
        Console.WriteLine($"Processing order {orderId} for customer {customerName}");
    }
    
    public void ProcessOrder(int orderId, string customerName)
    {
        Console.WriteLine($"Processing order {orderId} for customer {customerName}");
    }
}

// Usage
OrderProcessor processor = new OrderProcessor();
processor.ProcessOrder("John Doe", 12345);  // Calls first method
processor.ProcessOrder(12345, "John Doe");  // Calls second method</code></pre>
              </div>
              <div class="tab-pane fade" id="overloading-order-java" role="tabpanel">
                <pre class="syntax-highlighted" data-language="Java"><code class="language-java">public class OrderProcessor {
    // Different parameter order creates different signatures
    
    public void processOrder(String customerName, int orderId) {
        System.out.println("Processing order " + orderId + " for customer " + customerName);
    }
    
    public void processOrder(int orderId, String customerName) {
        System.out.println("Processing order " + orderId + " for customer " + customerName);
    }
}

// Usage
OrderProcessor processor = new OrderProcessor();
processor.processOrder("John Doe", 12345);  // Calls first method
processor.processOrder(12345, "John Doe");  // Calls second method</code></pre>
              </div>
            </div>
          </div>

          <h2>Overloading with Optional Parameters</h2>
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" data-bs-toggle="tab" data-bs-target="#overloading-optional-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" data-bs-toggle="tab" data-bs-target="#overloading-optional-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="overloading-optional-csharp" role="tabpanel">
                <pre class="syntax-highlighted" data-language="C#"><code class="language-csharp">public class Logger
{
    // Overloading with optional parameters
    
    public void Log(string message)
    {
        Log(message, LogLevel.Info);
    }
    
    public void Log(string message, LogLevel level)
    {
        Log(message, level, null);
    }
    
    public void Log(string message, LogLevel level, Exception exception)
    {
        string timestamp = DateTime.Now.ToString("yyyy-MM-dd HH:mm:ss");
        Console.WriteLine($"[{timestamp}] [{level}] {message}");
        
        if (exception != null)
        {
            Console.WriteLine($"Exception: {exception.Message}");
        }
    }
}

public enum LogLevel
{
    Info,
    Warning,
    Error
}

// Usage - call with different number of arguments
Logger logger = new Logger();
logger.Log("Application started");                      // Calls Log(string)
logger.Log("Low disk space", LogLevel.Warning);         // Calls Log(string, LogLevel)
logger.Log("Critical error", LogLevel.Error, new Exception("Failed")); // Calls Log(string, LogLevel, Exception)</code></pre>
              </div>
              <div class="tab-pane fade" id="overloading-optional-java" role="tabpanel">
                <pre class="syntax-highlighted" data-language="Java"><code class="language-java">import java.time.LocalDateTime;
import java.time.format.DateTimeFormatter;

public class Logger {
    // Overloading with optional parameters
    
    public void log(String message) {
        log(message, LogLevel.INFO);
    }
    
    public void log(String message, LogLevel level) {
        log(message, level, null);
    }
    
    public void log(String message, LogLevel level, Exception exception) {
        DateTimeFormatter formatter = DateTimeFormatter.ofPattern("yyyy-MM-dd HH:mm:ss");
        String timestamp = LocalDateTime.now().format(formatter);
        System.out.println("[" + timestamp + "] [" + level + "] " + message);
        
        if (exception != null) {
            System.out.println("Exception: " + exception.getMessage());
        }
    }
}

enum LogLevel {
    INFO,
    WARNING,
    ERROR
}

// Usage - call with different number of arguments
Logger logger = new Logger();
logger.log("Application started");                      // Calls log(String)
logger.log("Low disk space", LogLevel.WARNING);         // Calls log(String, LogLevel)
logger.log("Critical error", LogLevel.ERROR, new Exception("Failed")); // Calls log(String, LogLevel, Exception)</code></pre>
              </div>
            </div>
          </div>

          <h2>Real-World Example: Print Method</h2>
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" data-bs-toggle="tab" data-bs-target="#overloading-print-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" data-bs-toggle="tab" data-bs-target="#overloading-print-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="overloading-print-csharp" role="tabpanel">
                <pre class="syntax-highlighted" data-language="C#"><code class="language-csharp">public class Printer
{
    // Overloaded Print methods for different types
    
    public void Print(int value)
    {
        Console.WriteLine($"Integer: {value}");
    }
    
    public void Print(double value)
    {
        Console.WriteLine($"Double: {value:F2}");
    }
    
    public void Print(string value)
    {
        Console.WriteLine($"String: {value}");
    }
    
    public void Print(bool value)
    {
        Console.WriteLine($"Boolean: {value}");
    }
    
    public void Print(int[] values)
    {
        Console.WriteLine($"Array: [{string.Join(", ", values)}]");
    }
    
    public void Print(string value, ConsoleColor color)
    {
        ConsoleColor originalColor = Console.ForegroundColor;
        Console.ForegroundColor = color;
        Console.WriteLine(value);
        Console.ForegroundColor = originalColor;
    }
}

// Usage
Printer printer = new Printer();
printer.Print(42);                              // Integer: 42
printer.Print(3.14159);                         // Double: 3.14
printer.Print("Hello World");                   // String: Hello World
printer.Print(true);                            // Boolean: True
printer.Print(new int[] { 1, 2, 3, 4, 5 });    // Array: [1, 2, 3, 4, 5]
printer.Print("Important!", ConsoleColor.Red);  // Colored text</code></pre>
              </div>
              <div class="tab-pane fade" id="overloading-print-java" role="tabpanel">
                <pre class="syntax-highlighted" data-language="Java"><code class="language-java">public class Printer {
    // ANSI color codes for terminal
    public static final String ANSI_RESET = "\u001B[0m";
    public static final String ANSI_RED = "\u001B[31m";
    
    // Overloaded print methods for different types
    
    public void print(int value) {
        System.out.println("Integer: " + value);
    }
    
    public void print(double value) {
        System.out.printf("Double: %.2f%n", value);
    }
    
    public void print(String value) {
        System.out.println("String: " + value);
    }
    
    public void print(boolean value) {
        System.out.println("Boolean: " + value);
    }
    
    public void print(int[] values) {
        System.out.print("Array: [");
        for (int i = 0; i < values.length; i++) {
            System.out.print(values[i]);
            if (i < values.length - 1) System.out.print(", ");
        }
        System.out.println("]");
    }
    
    public void print(String value, String color) {
        System.out.println(color + value + ANSI_RESET);
    }
}

// Usage
Printer printer = new Printer();
printer.print(42);                              // Integer: 42
printer.print(3.14159);                         // Double: 3.14
printer.print("Hello World");                   // String: Hello World
printer.print(true);                            // Boolean: true
printer.print(new int[] { 1, 2, 3, 4, 5 });    // Array: [1, 2, 3, 4, 5]
printer.print("Important!", Printer.ANSI_RED);  // Colored text</code></pre>
              </div>
            </div>
          </div>

          <h2>Real-World Example: Search Functionality</h2>
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" data-bs-toggle="tab" data-bs-target="#overloading-search-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" data-bs-toggle="tab" data-bs-target="#overloading-search-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="overloading-search-csharp" role="tabpanel">
                <pre class="syntax-highlighted" data-language="C#"><code class="language-csharp">public class ProductRepository
{
    private List&lt;Product&gt; products;
    
    public ProductRepository()
    {
        products = new List&lt;Product&gt;
        {
            new Product { Id = 1, Name = "Laptop", Category = "Electronics", Price = 999.99m },
            new Product { Id = 2, Name = "Desk", Category = "Furniture", Price = 299.99m },
            new Product { Id = 3, Name = "Mouse", Category = "Electronics", Price = 29.99m }
        };
    }
    
    // Overloaded Search methods
    
    // Search by ID
    public Product Search(int id)
    {
        Console.WriteLine($"Searching by ID: {id}");
        return products.FirstOrDefault(p =&gt; p.Id == id);
    }
    
    // Search by name
    public Product Search(string name)
    {
        Console.WriteLine($"Searching by name: {name}");
        return products.FirstOrDefault(p =&gt; 
            p.Name.Equals(name, StringComparison.OrdinalIgnoreCase));
    }
    
    // Search by category and price range
    public List&lt;Product&gt; Search(string category, decimal minPrice, decimal maxPrice)
    {
        Console.WriteLine($"Searching by category: {category}, price range: ${minPrice}-${maxPrice}");
        return products.Where(p =&gt; 
            p.Category.Equals(category, StringComparison.OrdinalIgnoreCase) &&
            p.Price &gt;= minPrice && 
            p.Price &lt;= maxPrice).ToList();
    }
    
    // Search with predicate
    public List&lt;Product&gt; Search(Func&lt;Product, bool&gt; predicate)
    {
        Console.WriteLine("Searching with custom predicate");
        return products.Where(predicate).ToList();
    }
}

public class Product
{
    public int Id { get; set; }
    public string Name { get; set; }
    public string Category { get; set; }
    public decimal Price { get; set; }
}

// Usage - flexible search with different criteria
ProductRepository repo = new ProductRepository();

Product p1 = repo.Search(1);                           // Search by ID
Product p2 = repo.Search("Laptop");                    // Search by name
List&lt;Product&gt; p3 = repo.Search("Electronics", 0, 500); // Category + price range
List&lt;Product&gt; p4 = repo.Search(p =&gt; p.Price &lt; 100);   // Custom criteria</code></pre>
              </div>
              <div class="tab-pane fade" id="overloading-search-java" role="tabpanel">
                <pre class="syntax-highlighted" data-language="Java"><code class="language-java">import java.util.ArrayList;
import java.util.List;
import java.util.function.Predicate;
import java.util.stream.Collectors;

public class ProductRepository {
    private List&lt;Product&gt; products;
    
    public ProductRepository() {
        products = new ArrayList&lt;&gt;();
        products.add(new Product(1, \"Laptop\", \"Electronics\", 999.99));
        products.add(new Product(2, \"Desk\", \"Furniture\", 299.99));
        products.add(new Product(3, \"Mouse\", \"Electronics\", 29.99));
    }
    
    // Overloaded search methods
    
    // Search by ID
    public Product search(int id) {
        System.out.println(\"Searching by ID: \" + id);
        return products.stream()
                .filter(p -&gt; p.getId() == id)
                .findFirst()
                .orElse(null);
    }
    
    // Search by name
    public Product search(String name) {
        System.out.println(\"Searching by name: \" + name);
        return products.stream()
                .filter(p -&gt; p.getName().equalsIgnoreCase(name))
                .findFirst()
                .orElse(null);
    }
    
    // Search by category and price range
    public List&lt;Product&gt; search(String category, double minPrice, double maxPrice) {
        System.out.println(\"Searching by category: \" + category + \", price range: $\" + minPrice + \"-$\" + maxPrice);
        return products.stream()
                .filter(p -&gt; p.getCategory().equalsIgnoreCase(category) &&
                           p.getPrice() &gt;= minPrice && 
                           p.getPrice() &lt;= maxPrice)
                .collect(Collectors.toList());
    }
    
    // Search with predicate
    public List&lt;Product&gt; search(Predicate&lt;Product&gt; predicate) {
        System.out.println(\"Searching with custom predicate\");
        return products.stream()
                .filter(predicate)
                .collect(Collectors.toList());
    }
}

class Product {
    private int id;
    private String name;
    private String category;
    private double price;
    
    public Product(int id, String name, String category, double price) {
        this.id = id;
        this.name = name;
        this.category = category;
        this.price = price;
    }
    
    public int getId() { return id; }
    public String getName() { return name; }
    public String getCategory() { return category; }
    public double getPrice() { return price; }
}

// Usage - flexible search with different criteria
ProductRepository repo = new ProductRepository();

Product p1 = repo.search(1);                             // Search by ID
Product p2 = repo.search(\"Laptop\");                      // Search by name
List&lt;Product&gt; p3 = repo.search(\"Electronics\", 0, 500);  // Category + price range
List&lt;Product&gt; p4 = repo.search(p -&gt; p.getPrice() &lt; 100); // Custom criteria</code></pre>
              </div>
            </div>
          </div>

          <h2>Method Overloading Visualization</h2>
          <div class="mermaid">
graph TD
    A[Calculator.Add] --> B[Add int, int]
    A --> C[Add int, int, int]
    A --> D[Add double, double]
    A --> E[Add string, string]
    
    F[Client Code] --> G{Compiler analyzes\\nargument types}
    G -->|"5, 10"| B
    G -->|"5, 10, 15"| C
    G -->|"5.5, 10.5"| D
    G -->|"'Hello', 'World'"| E
    
    style A fill:#3b82f6,stroke:#2563eb,stroke-width:2px,color:#fff
    style G fill:#f59e0b,stroke:#d97706,stroke-width:2px,color:#fff
          </div>

          <h2>Valid vs Invalid Overloading</h2>
          <div class="row g-3">
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-green">
                <div class="card-body">
                  <h3>‚úÖ Valid Overloading</h3>
                  <pre class="mb-0"><code>// Different number of parameters
void Print(int a)
void Print(int a, int b)

// Different parameter types
void Print(int a)
void Print(string a)

// Different parameter order
void Process(int a, string b)
void Process(string b, int a)</code></pre>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-red">
                <div class="card-body">
                  <h3>‚ùå Invalid Overloading</h3>
                  <pre class="mb-0"><code>// Only return type differs
int GetValue()
string GetValue()  // ‚ùå Error!

// Only access modifier differs
public void Print(int a)
private void Print(int a)  // ‚ùå Error!

// Parameter names don't matter
void Print(int a)
void Print(int b)  // ‚ùå Error!</code></pre>
                </div>
              </div>
            </div>
          </div>

          <h2>Benefits of Method Overloading</h2>
          <ul>
            <li><strong>Improved Readability:</strong> Same operation uses the same method name</li>
            <li><strong>Code Convenience:</strong> Users don't need to remember multiple method names</li>
            <li><strong>Type Safety:</strong> Compile-time checking ensures correct method is called</li>
            <li><strong>Flexibility:</strong> Support different parameter combinations</li>
            <li><strong>Consistency:</strong> Uniform interface for similar operations</li>
          </ul>

          <h2>Best Practices</h2>
          <ul>
            <li><strong>Consistent Behavior:</strong> All overloaded methods should perform the same general operation</li>
            <li><strong>Avoid Ambiguity:</strong> Ensure method signatures are clearly distinct</li>
            <li><strong>Use Meaningful Names:</strong> Method name should describe what it does</li>
            <li><strong>Consider Default Parameters:</strong> Sometimes default parameters are clearer than overloading</li>
            <li><strong>Document Differences:</strong> Explain when to use each overload</li>
          </ul>

          <div class="callout">
            <strong>üí° Remember:</strong> Method overloading is resolved at <strong>compile time</strong> based on the 
            method signature (name, number, type, and order of parameters). The compiler selects the most specific 
            matching method. This is also called <strong>static polymorphism</strong> or <strong>early binding</strong>.
          </div>
        </section>

        <!-- Method Overriding Section -->
        <section id="method-overriding" role="article">
          <h1>üéØ Method Overriding</h1>
          <span class="badge">polymorphism</span>
          <span class="badge">runtime</span>
          <span class="badge">inheritance</span>
          
          <h2>What is Method Overriding?</h2>
          <p>
            <strong>Method Overriding</strong> (also called runtime polymorphism or dynamic polymorphism) is the ability of a 
            derived class to provide a specific implementation of a method that is already defined in its base class. The method 
            to be executed is determined at runtime based on the actual object type.
          </p>

          <h2>Requirements for Method Overriding</h2>
          <ul>
            <li>Base class method must be marked as <code>virtual</code> or <code>abstract</code></li>
            <li>Derived class method must use <code>override</code> keyword</li>
            <li>Method signature must be identical (name, parameters, return type)</li>
            <li>Access modifier must be same or less restrictive</li>
          </ul>

          <h2>Basic Method Overriding</h2>
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" data-bs-toggle="tab" data-bs-target="#overriding-animal-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" data-bs-toggle="tab" data-bs-target="#overriding-animal-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="overriding-animal-csharp" role="tabpanel">
                <pre class="syntax-highlighted" data-language="C#"><code class="language-csharp">public class Animal
{
    // Virtual method - can be overridden
    public virtual void MakeSound()
    {
        Console.WriteLine("Some generic animal sound");
    }
    
    public virtual void Sleep()
    {
        Console.WriteLine("Animal is sleeping...");
    }
}

public class Dog : Animal
{
    // Override base class method
    public override void MakeSound()
    {
        Console.WriteLine("Woof! Woof!");
    }
}

public class Cat : Animal
{
    // Override base class method
    public override void MakeSound()
    {
        Console.WriteLine("Meow! Meow!");
    }
    
    public override void Sleep()
    {
        Console.WriteLine("Cat is sleeping on the couch...");
    }
}

// Usage - runtime polymorphism
Animal myDog = new Dog();
Animal myCat = new Cat();

myDog.MakeSound();  // Output: Woof! Woof! (Dog's implementation)
myCat.MakeSound();  // Output: Meow! Meow! (Cat's implementation)
myCat.Sleep();      // Output: Cat is sleeping on the couch... (Cat's implementation)</code></pre>
              </div>
              <div class="tab-pane fade" id="overriding-animal-java" role="tabpanel">
                <pre class="syntax-highlighted" data-language="Java"><code class="language-java">public class Animal {
    // Methods can be overridden by default in Java
    public void makeSound() {
        System.out.println("Some generic animal sound");
    }
    
    public void sleep() {
        System.out.println("Animal is sleeping...");
    }
}

public class Dog extends Animal {
    // Override base class method
    @Override
    public void makeSound() {
        System.out.println("Woof! Woof!");
    }
}

public class Cat extends Animal {
    // Override base class method
    @Override
    public void makeSound() {
        System.out.println("Meow! Meow!");
    }
    
    @Override
    public void sleep() {
        System.out.println("Cat is sleeping on the couch...");
    }
}

// Usage - runtime polymorphism
Animal myDog = new Dog();
Animal myCat = new Cat();

myDog.makeSound();  // Output: Woof! Woof! (Dog's implementation)
myCat.makeSound();  // Output: Meow! Meow! (Cat's implementation)
myCat.sleep();      // Output: Cat is sleeping on the couch... (Cat's implementation)</code></pre>
              </div>
            </div>
          </div>

          <h2>Using base Keyword</h2>
          <p>Call the base class implementation from the overriding method.</p>
          
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" data-bs-toggle="tab" data-bs-target="#overriding-base-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" data-bs-toggle="tab" data-bs-target="#overriding-base-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="overriding-base-csharp" role="tabpanel">
                <pre class="syntax-highlighted" data-language="C#"><code class="language-csharp">public class Employee
{
    public string Name { get; set; }
    public decimal BaseSalary { get; set; }
    
    public Employee(string name, decimal baseSalary)
    {
        Name = name;
        BaseSalary = baseSalary;
    }
    
    // Virtual method
    public virtual decimal CalculateSalary()
    {
        Console.WriteLine("Calculating base salary");
        return BaseSalary;
    }
    
    public virtual void DisplayInfo()
    {
        Console.WriteLine($"Employee: {Name}");
        Console.WriteLine($"Salary: ${CalculateSalary():F2}");
    }
}

public class Manager : Employee
{
    public decimal Bonus { get; set; }
    
    public Manager(string name, decimal baseSalary, decimal bonus)
        : base(name, baseSalary)
    {
        Bonus = bonus;
    }
    
    // Override and extend base method
    public override decimal CalculateSalary()
    {
        Console.WriteLine("Calculating manager salary with bonus");
        decimal baseSalary = base.CalculateSalary();  // Call base implementation
        return baseSalary + Bonus;
    }
    
    public override void DisplayInfo()
    {
        base.DisplayInfo();  // Call base implementation
        Console.WriteLine($"Bonus: ${Bonus:F2}");
    }
}

// Usage
Employee employee = new Employee("John Doe", 50000);
employee.DisplayInfo();
Console.WriteLine();

Employee manager = new Manager("Jane Smith", 80000, 20000);
manager.DisplayInfo();
// Output:
// Calculating base salary
// Calculating manager salary with bonus
// Employee: Jane Smith
// Salary: $100000.00
// Bonus: $20000.00</code></pre>
              </div>
              <div class="tab-pane fade" id="overriding-base-java" role="tabpanel">
                <pre class="syntax-highlighted" data-language="Java"><code class="language-java">public class Employee {
    private String name;
    private double baseSalary;
    
    public Employee(String name, double baseSalary) {
        this.name = name;
        this.baseSalary = baseSalary;
    }
    
    // Method can be overridden
    public double calculateSalary() {
        System.out.println("Calculating base salary");
        return baseSalary;
    }
    
    public void displayInfo() {
        System.out.printf("Employee: %s%n", name);
        System.out.printf("Salary: $%.2f%n", calculateSalary());
    }
    
    public String getName() { return name; }
    public double getBaseSalary() { return baseSalary; }
}

public class Manager extends Employee {
    private double bonus;
    
    public Manager(String name, double baseSalary, double bonus) {
        super(name, baseSalary);  // Call parent constructor
        this.bonus = bonus;
    }
    
    // Override and extend base method
    @Override
    public double calculateSalary() {
        System.out.println("Calculating manager salary with bonus");
        double baseSalary = super.calculateSalary();  // Call base implementation
        return baseSalary + bonus;
    }
    
    @Override
    public void displayInfo() {
        super.displayInfo();  // Call base implementation
        System.out.printf("Bonus: $%.2f%n", bonus);
    }
    
    public double getBonus() { return bonus; }
}

// Usage
Employee employee = new Employee("John Doe", 50000);
employee.displayInfo();
System.out.println();

Employee manager = new Manager("Jane Smith", 80000, 20000);
manager.displayInfo();
// Output:
// Calculating base salary
// Calculating manager salary with bonus
// Employee: Jane Smith
// Salary: $100000.00
// Bonus: $20000.00</code></pre>
              </div>
            </div>
          </div>

          <h2>Abstract Methods</h2>
          <p>Abstract methods must be overridden in derived classes.</p>
          
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" data-bs-toggle="tab" data-bs-target="#overriding-abstract-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" data-bs-toggle="tab" data-bs-target="#overriding-abstract-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="overriding-abstract-csharp" role="tabpanel">
                <pre class="syntax-highlighted" data-language="C#"><code class="language-csharp">public abstract class Shape
{
    public string Name { get; set; }
    
    // Abstract methods - no implementation, must be overridden
    public abstract double CalculateArea();
    public abstract double CalculatePerimeter();
    
    // Concrete method - can be used as-is or overridden
    public virtual void Display()
    {
        Console.WriteLine($"Shape: {Name}");
        Console.WriteLine($"Area: {CalculateArea():F2}");
        Console.WriteLine($"Perimeter: {CalculatePerimeter():F2}");
    }
}

public class Circle : Shape
{
    public double Radius { get; set; }
    
    public Circle(double radius)
    {
        Radius = radius;
        Name = "Circle";
    }
    
    // Must override abstract methods
    public override double CalculateArea()
    {
        return Math.PI * Radius * Radius;
    }
    
    public override double CalculatePerimeter()
    {
        return 2 * Math.PI * Radius;
    }
}

public class Rectangle : Shape
{
    public double Width { get; set; }
    public double Height { get; set; }
    
    public Rectangle(double width, double height)
    {
        Width = width;
        Height = height;
        Name = "Rectangle";
    }
    
    // Must override abstract methods
    public override double CalculateArea()
    {
        return Width * Height;
    }
    
    public override double CalculatePerimeter()
    {
        return 2 * (Width + Height);
    }
    
    // Optionally override virtual method
    public override void Display()
    {
        base.Display();
        Console.WriteLine($"Dimensions: {Width} x {Height}");
    }
}

// Usage - polymorphic behavior
List<Shape> shapes = new List<Shape>
{
    new Circle(5),
    new Rectangle(4, 6),
    new Circle(3)
};

foreach (Shape shape in shapes)
{
    shape.Display();  // Calls appropriate implementation
    Console.WriteLine();
}</code></pre>
              </div>
              <div class="tab-pane fade" id="overriding-abstract-java" role="tabpanel">
                <pre class="syntax-highlighted" data-language="Java"><code class="language-java">import java.util.ArrayList;
import java.util.List;

public abstract class Shape {
    private String name;
    
    public String getName() { return name; }
    public void setName(String name) { this.name = name; }
    
    // Abstract methods - no implementation, must be overridden
    public abstract double calculateArea();
    public abstract double calculatePerimeter();
    
    // Concrete method - can be used as-is or overridden
    public void display() {
        System.out.printf("Shape: %s%n", name);
        System.out.printf("Area: %.2f%n", calculateArea());
        System.out.printf("Perimeter: %.2f%n", calculatePerimeter());
    }
}

public class Circle extends Shape {
    private double radius;
    
    public Circle(double radius) {
        this.radius = radius;
        setName("Circle");
    }
    
    // Must override abstract methods
    @Override
    public double calculateArea() {
        return Math.PI * radius * radius;
    }
    
    @Override
    public double calculatePerimeter() {
        return 2 * Math.PI * radius;
    }
    
    public double getRadius() { return radius; }
}

public class Rectangle extends Shape {
    private double width;
    private double height;
    
    public Rectangle(double width, double height) {
        this.width = width;
        this.height = height;
        setName("Rectangle");
    }
    
    // Must override abstract methods
    @Override
    public double calculateArea() {
        return width * height;
    }
    
    @Override
    public double calculatePerimeter() {
        return 2 * (width + height);
    }
    
    // Optionally override concrete method
    @Override
    public void display() {
        super.display();
        System.out.printf("Dimensions: %.1f x %.1f%n", width, height);
    }
    
    public double getWidth() { return width; }
    public double getHeight() { return height; }
}

// Usage - polymorphic behavior
List<Shape> shapes = new ArrayList<>();
shapes.add(new Circle(5));
shapes.add(new Rectangle(4, 6));
shapes.add(new Circle(3));

for (Shape shape : shapes) {
    shape.display();  // Calls appropriate implementation
    System.out.println();
}</code></pre>
              </div>
            </div>
          </div>

          <h2>Real-World Example: Payment Processing</h2>
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" data-bs-toggle="tab" data-bs-target="#overriding-payment-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" data-bs-toggle="tab" data-bs-target="#overriding-payment-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="overriding-payment-csharp" role="tabpanel">
                <pre class="syntax-highlighted" data-language="C#"><code class="language-csharp">public abstract class PaymentProcessor
{
    public string TransactionId { get; protected set; }
    public decimal Amount { get; protected set; }
    
    protected PaymentProcessor(decimal amount)
    {
        Amount = amount;
        TransactionId = Guid.NewGuid().ToString("N").Substring(0, 8);
    }
    
    // Template method pattern
    public bool ProcessPayment()
    {
        Console.WriteLine($"\\n--- Processing payment of ${Amount} ---");
        
        if (!ValidatePayment())
        {
            Console.WriteLine("Payment validation failed");
            return false;
        }
        
        if (!AuthorizePayment())
        {
            Console.WriteLine("Payment authorization failed");
            return false;
        }
        
        bool success = ExecutePayment();
        
        if (success)
        {
            CompletePayment();
        }
        
        return success;
    }
    
    // Virtual methods with default implementation
    protected virtual bool ValidatePayment()
    {
        Console.WriteLine("Validating payment amount");
        return Amount > 0;
    }
    
    // Abstract methods - must be implemented
    protected abstract bool AuthorizePayment();
    protected abstract bool ExecutePayment();
    
    // Virtual method that can be overridden
    protected virtual void CompletePayment()
    {
        Console.WriteLine($"Payment completed. Transaction ID: {TransactionId}");
    }
}

public class CreditCardProcessor : PaymentProcessor
{
    public string CardNumber { get; set; }
    public string CVV { get; set; }
    
    public CreditCardProcessor(decimal amount, string cardNumber, string cvv)
        : base(amount)
    {
        CardNumber = cardNumber;
        CVV = cvv;
    }
    
    protected override bool ValidatePayment()
    {
        bool baseValid = base.ValidatePayment();
        Console.WriteLine("Validating credit card details");
        return baseValid && !string.IsNullOrEmpty(CardNumber) && CVV.Length == 3;
    }
    
    protected override bool AuthorizePayment()
    {
        Console.WriteLine("Authorizing with credit card network");
        // Simulate authorization
        return true;
    }
    
    protected override bool ExecutePayment()
    {
        Console.WriteLine($"Charging credit card ending in {CardNumber.Substring(CardNumber.Length - 4)}");
        // Execute actual charge
        return true;
    }
    
    protected override void CompletePayment()
    {
        base.CompletePayment();
        Console.WriteLine("Credit card receipt sent via email");
    }
}

public class PayPalProcessor : PaymentProcessor
{
    public string Email { get; set; }
    
    public PayPalProcessor(decimal amount, string email)
        : base(amount)
    {
        Email = email;
    }
    
    protected override bool ValidatePayment()
    {
        bool baseValid = base.ValidatePayment();
        Console.WriteLine("Validating PayPal account");
        return baseValid && !string.IsNullOrEmpty(Email);
    }
    
    protected override bool AuthorizePayment()
    {
        Console.WriteLine("Redirecting to PayPal for authorization");
        // Simulate PayPal authorization
        return true;
    }
    
    protected override bool ExecutePayment()
    {
        Console.WriteLine($"Processing PayPal payment for {Email}");
        // Execute PayPal payment
        return true;
    }
}

// Usage - polymorphic behavior
List<PaymentProcessor> payments = new List<PaymentProcessor>
{
    new CreditCardProcessor(150.00m, "1234567812345678", "123"),
    new PayPalProcessor(75.50m, "user@example.com")
};

foreach (var payment in payments)
{
    payment.ProcessPayment();  // Calls appropriate implementation
}</code></pre>
              </div>
              <div class="tab-pane fade" id="overriding-payment-java" role="tabpanel">
                <pre class="syntax-highlighted" data-language="Java"><code class="language-java">import java.util.ArrayList;
import java.util.List;
import java.util.UUID;

public abstract class PaymentProcessor {
    private String transactionId;
    private double amount;
    
    protected PaymentProcessor(double amount) {
        this.amount = amount;
        this.transactionId = UUID.randomUUID().toString().replace("-", "").substring(0, 8);
    }
    
    // Template method pattern
    public boolean processPayment() {
        System.out.printf("%n--- Processing payment of $%.2f ---%n", amount);
        
        if (!validatePayment()) {
            System.out.println("Payment validation failed");
            return false;
        }
        
        if (!authorizePayment()) {
            System.out.println("Payment authorization failed");
            return false;
        }
        
        boolean success = executePayment();
        
        if (success) {
            completePayment();
        }
        
        return success;
    }
    
    // Method with default implementation
    protected boolean validatePayment() {
        System.out.println("Validating payment amount");
        return amount > 0;
    }
    
    // Abstract methods - must be implemented
    protected abstract boolean authorizePayment();
    protected abstract boolean executePayment();
    
    // Method that can be overridden
    protected void completePayment() {
        System.out.printf("Payment completed. Transaction ID: %s%n", transactionId);
    }
    
    public String getTransactionId() { return transactionId; }
    public double getAmount() { return amount; }
}

public class CreditCardProcessor extends PaymentProcessor {
    private String cardNumber;
    private String cvv;
    
    public CreditCardProcessor(double amount, String cardNumber, String cvv) {
        super(amount);
        this.cardNumber = cardNumber;
        this.cvv = cvv;
    }
    
    @Override
    protected boolean validatePayment() {
        boolean baseValid = super.validatePayment();
        System.out.println("Validating credit card details");
        return baseValid && cardNumber != null && !cardNumber.isEmpty() && cvv.length() == 3;
    }
    
    @Override
    protected boolean authorizePayment() {
        System.out.println("Authorizing with credit card network");
        // Simulate authorization
        return true;
    }
    
    @Override
    protected boolean executePayment() {
        System.out.printf("Charging credit card ending in %s%n", 
            cardNumber.substring(cardNumber.length() - 4));
        // Execute actual charge
        return true;
    }
    
    @Override
    protected void completePayment() {
        super.completePayment();
        System.out.println("Credit card receipt sent via email");
    }
}

public class PayPalProcessor extends PaymentProcessor {
    private String email;
    
    public PayPalProcessor(double amount, String email) {
        super(amount);
        this.email = email;
    }
    
    @Override
    protected boolean validatePayment() {
        boolean baseValid = super.validatePayment();
        System.out.println("Validating PayPal account");
        return baseValid && email != null && !email.isEmpty();
    }
    
    @Override
    protected boolean authorizePayment() {
        System.out.println("Redirecting to PayPal for authorization");
        // Simulate PayPal authorization
        return true;
    }
    
    @Override
    protected boolean executePayment() {
        System.out.printf("Processing PayPal payment for %s%n", email);
        // Execute PayPal payment
        return true;
    }
}

// Usage - polymorphic behavior
List<PaymentProcessor> payments = new ArrayList<>();
payments.add(new CreditCardProcessor(150.00, "1234567812345678", "123"));
payments.add(new PayPalProcessor(75.50, "user@example.com"));

for (PaymentProcessor payment : payments) {
    payment.processPayment();  // Calls appropriate implementation
}</code></pre>
              </div>
            </div>
          </div>

          <h2>Method Hiding with new Keyword</h2>
          <p>Using <code>new</code> keyword hides base class method instead of overriding it.</p>
          
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" data-bs-toggle="tab" data-bs-target="#overriding-hiding-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" data-bs-toggle="tab" data-bs-target="#overriding-hiding-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="overriding-hiding-csharp" role="tabpanel">
                <pre class="syntax-highlighted" data-language="C#"><code class="language-csharp">public class BaseClass
{
    public virtual void Display()
    {
        Console.WriteLine("BaseClass Display");
    }
}

public class DerivedWithOverride : BaseClass
{
    // Override - polymorphic behavior
    public override void Display()
    {
        Console.WriteLine("DerivedWithOverride Display");
    }
}

public class DerivedWithNew : BaseClass
{
    // New - hides base method (not polymorphic)
    public new void Display()
    {
        Console.WriteLine("DerivedWithNew Display");
    }
}

// Usage - demonstrates the difference
BaseClass obj1 = new DerivedWithOverride();
obj1.Display();  // Output: DerivedWithOverride Display (override)

BaseClass obj2 = new DerivedWithNew();
obj2.Display();  // Output: BaseClass Display (hidden, not overridden)

DerivedWithNew obj3 = new DerivedWithNew();
obj3.Display();  // Output: DerivedWithNew Display (direct call)</code></pre>
              </div>
              <div class="tab-pane fade" id="overriding-hiding-java" role="tabpanel">
                <pre class="syntax-highlighted" data-language="Java"><code class="language-java">// Java doesn't support method hiding like C#
// All non-final, non-static, non-private methods are virtual by default
// You can prevent overriding by using 'final' keyword

public class BaseClass {
    public void display() {
        System.out.println("BaseClass Display");
    }
}

public class DerivedWithOverride extends BaseClass {
    // Always overrides in Java (polymorphic)
    @Override
    public void display() {
        System.out.println("DerivedWithOverride Display");
    }
}

public class BaseWithFinal {
    // Final prevents overriding
    public final void display() {
        System.out.println("BaseWithFinal Display");
    }
}

// This would cause compile error:
// public class DerivedFromFinal extends BaseWithFinal {
//     @Override
//     public void display() { }  // ERROR: Cannot override final method
// }

// Usage - demonstrates polymorphic behavior
BaseClass obj1 = new DerivedWithOverride();
obj1.display();  // Output: DerivedWithOverride Display (always polymorphic)

// In Java, you cannot hide instance methods like C#'s 'new' keyword
// All instance method calls are resolved at runtime (late binding)</code></pre>
              </div>
            </div>
          </div>

          <h2>Overloading vs Overriding</h2>
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th>Aspect</th>
                <th>Method Overloading</th>
                <th>Method Overriding</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Polymorphism Type</strong></td>
                <td>Compile-time (Static)</td>
                <td>Runtime (Dynamic)</td>
              </tr>
              <tr>
                <td><strong>Class Relationship</strong></td>
                <td>Same class</td>
                <td>Base and derived class</td>
              </tr>
              <tr>
                <td><strong>Method Signature</strong></td>
                <td>Different signatures</td>
                <td>Same signature</td>
              </tr>
              <tr>
                <td><strong>Keywords</strong></td>
                <td>None required</td>
                <td>virtual, override, abstract</td>
              </tr>
              <tr>
                <td><strong>Return Type</strong></td>
                <td>Can be different</td>
                <td>Must be same</td>
              </tr>
              <tr>
                <td><strong>Binding</strong></td>
                <td>Early binding</td>
                <td>Late binding</td>
              </tr>
              <tr>
                <td><strong>Purpose</strong></td>
                <td>Multiple ways to call same operation</td>
                <td>Change behavior in derived class</td>
              </tr>
            </tbody>
          </table>

          <h2>Polymorphism Visualization</h2>
          <div class="mermaid">
sequenceDiagram
    participant Client
    participant BaseRef as Animal (reference)
    participant Dog as Dog (object)
    participant Cat as Cat (object)
    
    Client->>BaseRef: Animal dog = new Dog()
    Client->>BaseRef: Animal cat = new Cat()
    
    Client->>Dog: dog.MakeSound()
    Note over Dog: Runtime determines\\nactual object type
    Dog-->>Client: "Woof! Woof!"
    
    Client->>Cat: cat.MakeSound()
    Note over Cat: Runtime determines\\nactual object type
    Cat-->>Client: "Meow! Meow!"
    
    Note over Client,Cat: Same method call,\\ndifferent behavior\\n(Runtime Polymorphism)
          </div>

          <h2>Best Practices</h2>
          <ul>
            <li><strong>Mark as Virtual:</strong> Methods intended for overriding should be marked virtual</li>
            <li><strong>Use override:</strong> Always use override keyword explicitly in derived class</li>
            <li><strong>Consistent Behavior:</strong> Overridden method should preserve base class contract</li>
            <li><strong>Call base When Needed:</strong> Use base.Method() to extend rather than replace</li>
            <li><strong>Abstract for Required:</strong> Use abstract when derived classes must implement</li>
            <li><strong>Avoid Breaking LSP:</strong> Follow Liskov Substitution Principle</li>
          </ul>

          <div class="callout">
            <strong>üí° Key Concept:</strong> Method overriding enables <strong>runtime polymorphism</strong>‚Äîthe actual 
            method to execute is determined at runtime based on the object's actual type, not the reference type. This 
            allows you to write flexible code that works with base class references but exhibits specialized behavior 
            based on the concrete object type. This is the essence of the "Open/Closed Principle"‚Äîopen for extension, 
            closed for modification.
          </div>
        </section>

        <!-- Best Practices Section -->
        <section id="best-practices" role="article">
          <h1>‚ú® OOP Best Practices</h1>
          <span class="badge">guidelines</span>
          <span class="badge">tips</span>
          <span class="badge">patterns</span>
          
          <h2>Introduction</h2>
          <p>
            Following OOP best practices leads to code that is maintainable, scalable, extensible, and testable. 
            These guidelines represent industry-proven approaches to writing object-oriented code that stands the test of time.
          </p>

          <h2>SOLID Principles</h2>
          <p>
            The SOLID principles are five design principles that make software designs more understandable, flexible, and maintainable.
          </p>

          <h3>1. Single Responsibility Principle (SRP)</h3>
          <div class="callout">
            <strong>Principle:</strong> A class should have only one reason to change‚Äîit should have only one job or responsibility.
          </div>
          
          <div class="row g-3 mt-3">
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-red">
                <div class="card-body">
                  <h4>‚ùå Bad: Multiple Responsibilities</h4>
                  <pre class="mb-0"><code class="language-csharp">public class User
{
    public string Name { get; set; }
    public string Email { get; set; }
    
    // Business logic
    public void UpdateProfile() { }
    
    // Database access
    public void SaveToDatabase() { }
    
    // Email sending
    public void SendEmail() { }
    
    // Logging
    public void LogActivity() { }
}</code></pre>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-green">
                <div class="card-body">
                  <h4>‚úÖ Good: Single Responsibility</h4>
                  <pre class="mb-0"><code class="language-csharp">public class User
{
    public string Name { get; set; }
    public string Email { get; set; }
}

public class UserService
{
    public void UpdateProfile(User user) { }
}

public class UserRepository
{
    public void Save(User user) { }
}

public class EmailService
{
    public void SendEmail(string to) { }
}

public class ActivityLogger
{
    public void Log(string activity) { }
}</code></pre>
                </div>
              </div>
            </div>
          </div>

          <h3 class="mt-4">2. Open/Closed Principle (OCP)</h3>
          <div class="callout">
            <strong>Principle:</strong> Software entities should be open for extension but closed for modification.
          </div>
          
          <div class="row g-3 mt-3">
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-red">
                <div class="card-body">
                  <h4>‚ùå Bad: Modification Required</h4>
                  <pre class="mb-0"><code class="language-csharp">public class DiscountCalculator
{
    public decimal Calculate(
        decimal amount, 
        string customerType)
    {
        if (customerType == "Regular")
            return amount * 0.9m;
        else if (customerType == "VIP")
            return amount * 0.8m;
        else if (customerType == "Gold")
            return amount * 0.7m;
        
        return amount;
    }
}</code></pre>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-green">
                <div class="card-body">
                  <h4>‚úÖ Good: Extension via Inheritance</h4>
                  <pre class="mb-0"><code class="language-csharp">public abstract class Customer
{
    public abstract decimal GetDiscount(
        decimal amount);
}

public class RegularCustomer : Customer
{
    public override decimal GetDiscount(
        decimal amount)
    {
        return amount * 0.9m;
    }
}

public class VIPCustomer : Customer
{
    public override decimal GetDiscount(
        decimal amount)
    {
        return amount * 0.8m;
    }
}</code></pre>
                </div>
              </div>
            </div>
          </div>

          <h3 class="mt-4">3. Liskov Substitution Principle (LSP)</h3>
          <div class="callout">
            <strong>Principle:</strong> Objects of a derived class should be able to replace objects of the base class without affecting correctness.
          </div>
          
          <div class="code-tabs mt-3">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" data-bs-toggle="tab" data-bs-target="#lsp-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" data-bs-toggle="tab" data-bs-target="#lsp-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="lsp-csharp" role="tabpanel">
                <pre class="syntax-highlighted" data-language="C#"><code class="language-csharp">// Good: Derived class maintains base class behavior
public class Rectangle
{
    public virtual int Width { get; set; }
    public virtual int Height { get; set; }
    
    public virtual int CalculateArea()
    {
        return Width * Height;
    }
}

// Square should NOT inherit from Rectangle (violates LSP)
// Because setting Width affects Height and vice versa
// Instead, both should inherit from a common Shape base class

public abstract class Shape
{
    public abstract int CalculateArea();
}

public class Rectangle : Shape
{
    public int Width { get; set; }
    public int Height { get; set; }
    
    public override int CalculateArea()
    {
        return Width * Height;
    }
}

public class Square : Shape
{
    public int Side { get; set; }
    
    public override int CalculateArea()
    {
        return Side * Side;
    }
}</code></pre>
              </div>
              <div class="tab-pane fade" id="lsp-java" role="tabpanel">
                <pre class="syntax-highlighted" data-language="Java"><code class="language-java">// Good: Derived class maintains base class behavior
public class Rectangle {
    private int width;
    private int height;
    
    public int getWidth() { return width; }
    public void setWidth(int width) { this.width = width; }
    public int getHeight() { return height; }
    public void setHeight(int height) { this.height = height; }
    
    public int calculateArea() {
        return width * height;
    }
}

// Square should NOT inherit from Rectangle (violates LSP)
// Because setting width affects height and vice versa
// Instead, both should inherit from a common Shape base class

public abstract class Shape {
    public abstract int calculateArea();
}

public class Rectangle extends Shape {
    private int width;
    private int height;
    
    public int getWidth() { return width; }
    public void setWidth(int width) { this.width = width; }
    public int getHeight() { return height; }
    public void setHeight(int height) { this.height = height; }
    
    @Override
    public int calculateArea() {
        return width * height;
    }
}

public class Square extends Shape {
    private int side;
    
    public int getSide() { return side; }
    public void setSide(int side) { this.side = side; }
    
    @Override
    public int calculateArea() {
        return side * side;
    }
}</code></pre>
              </div>
            </div>
          </div>

          <h3 class="mt-4">4. Interface Segregation Principle (ISP)</h3>
          <div class="callout">
            <strong>Principle:</strong> Clients should not be forced to depend on interfaces they don't use. Many specific interfaces are better than one general-purpose interface.
          </div>
          
          <div class="row g-3 mt-3">
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-red">
                <div class="card-body">
                  <h4>‚ùå Bad: Fat Interface</h4>
                  <pre class="mb-0"><code class="language-csharp">public interface IWorker
{
    void Work();
    void Eat();
    void Sleep();
    void GetPaid();
}

// Robot doesn't eat or sleep!
public class Robot : IWorker
{
    public void Work() { }
    public void GetPaid() { }
    
    // Forced to implement
    public void Eat() 
    { 
        throw new NotImplementedException(); 
    }
    public void Sleep() 
    { 
        throw new NotImplementedException(); 
    }
}</code></pre>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-green">
                <div class="card-body">
                  <h4>‚úÖ Good: Segregated Interfaces</h4>
                  <pre class="mb-0"><code class="language-csharp">public interface IWorkable
{
    void Work();
}

public interface IFeedable
{
    void Eat();
}

public interface ISleepable
{
    void Sleep();
}

public interface IPayable
{
    void GetPaid();
}

public class Human : IWorkable, 
    IFeedable, ISleepable, IPayable
{
    public void Work() { }
    public void Eat() { }
    public void Sleep() { }
    public void GetPaid() { }
}

public class Robot : IWorkable, IPayable
{
    public void Work() { }
    public void GetPaid() { }
}</code></pre>
                </div>
              </div>
            </div>
          </div>

          <h3 class="mt-4">5. Dependency Inversion Principle (DIP)</h3>
          <div class="callout">
            <strong>Principle:</strong> High-level modules should not depend on low-level modules. Both should depend on abstractions.
          </div>
          
          <div class="row g-3 mt-3">
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-red">
                <div class="card-body">
                  <h4>‚ùå Bad: Tight Coupling</h4>
                  <pre class="mb-0"><code class="language-csharp">public class EmailNotification
{
    public void Send(string message)
    {
        // Send email
    }
}

public class OrderProcessor
{
    private EmailNotification notifier;
    
    public OrderProcessor()
    {
        // Tightly coupled to EmailNotification
        notifier = new EmailNotification();
    }
    
    public void Process()
    {
        // Process order
        notifier.Send("Order processed");
    }
}</code></pre>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100 bg-gradient-green">
                <div class="card-body">
                  <h4>‚úÖ Good: Depend on Abstraction</h4>
                  <pre class="mb-0"><code class="language-csharp">public interface INotification
{
    void Send(string message);
}

public class EmailNotification : INotification
{
    public void Send(string message) { }
}

public class SMSNotification : INotification
{
    public void Send(string message) { }
}

public class OrderProcessor
{
    private INotification notifier;
    
    // Dependency injection
    public OrderProcessor(
        INotification notifier)
    {
        this.notifier = notifier;
    }
    
    public void Process()
    {
        // Process order
        notifier.Send("Order processed");
    }
}</code></pre>
                </div>
              </div>
            </div>
          </div>

          <h2 class="mt-5">General Best Practices</h2>
          
          <h3>1. Favor Composition Over Inheritance</h3>
          <p>Use composition (has-a) rather than inheritance (is-a) when possible to achieve flexibility.</p>
          
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" data-bs-toggle="tab" data-bs-target="#composition-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" data-bs-toggle="tab" data-bs-target="#composition-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="composition-csharp" role="tabpanel">
                <pre class="syntax-highlighted" data-language="C#"><code class="language-csharp">// Instead of inheritance
public class Car : Engine, Wheels, Seats { }  // ‚ùå Not possible/practical

// Use composition
public class Car
{
    private Engine engine;
    private List&lt;Wheel&gt; wheels;
    private List&lt;Seat&gt; seats;
    
    public Car()
    {
        engine = new Engine();
        wheels = new List&lt;Wheel&gt; { new Wheel(), new Wheel(), new Wheel(), new Wheel() };
        seats = new List&lt;Seat&gt; { new Seat(), new Seat(), new Seat(), new Seat() };
    }
    
    public void Start()
    {
        engine.Start();
    }
}</code></pre>
              </div>
              <div class="tab-pane fade" id="composition-java" role="tabpanel">
                <pre class="syntax-highlighted" data-language="Java"><code class="language-java">import java.util.ArrayList;
import java.util.List;

// Instead of inheritance
// public class Car extends Engine, Wheels, Seats { }  // ‚ùå Not possible (no multiple inheritance)

// Use composition
public class Car {
    private Engine engine;
    private List&lt;Wheel&gt; wheels;
    private List&lt;Seat&gt; seats;
    
    public Car() {
        engine = new Engine();
        wheels = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; 4; i++) {
            wheels.add(new Wheel());
        }
        seats = new ArrayList&lt;&gt;();
        for (int i = 0; i &lt; 4; i++) {
            seats.add(new Seat());
        }
    }
    
    public void start() {
        engine.start();
    }
}</code></pre>
              </div>
            </div>
          </div>

          <h3>2. Program to Interfaces, Not Implementations</h3>
          <p>Depend on abstractions rather than concrete classes.</p>
          
          <pre class="syntax-highlighted" data-language="C#"><code class="language-csharp">// ‚ùå Bad: Depend on concrete class
public class ReportGenerator
{
    private MySQLDatabase database;
    
    public ReportGenerator()
    {
        database = new MySQLDatabase();
    }
}

// ‚úÖ Good: Depend on interface
public class ReportGenerator
{
    private IDatabase database;
    
    public ReportGenerator(IDatabase database)
    {
        this.database = database;
    }
}</code></pre>

          <h3>3. Keep Classes Small and Focused</h3>
          <ul>
            <li>A class should fit on one screen (typically 200-300 lines max)</li>
            <li>If a class is too large, split it into smaller classes</li>
            <li>Each class should have a clear, single purpose</li>
          </ul>

          <h3>4. Use Meaningful Names</h3>
          <pre class="syntax-highlighted" data-language="C#"><code class="language-csharp">// ‚ùå Bad naming
public class Data
{
    public void Do() { }
    public int x;
}

// ‚úÖ Good naming
public class CustomerRepository
{
    public void SaveCustomer(Customer customer) { }
    public int totalCustomerCount;
}</code></pre>

          <h3>5. Encapsulate What Varies</h3>
          <p>Identify aspects that vary and separate them from what stays the same.</p>
          
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" data-bs-toggle="tab" data-bs-target="#encapsulate-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" data-bs-toggle="tab" data-bs-target="#encapsulate-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="encapsulate-csharp" role="tabpanel">
                <pre class="syntax-highlighted" data-language="C#"><code class="language-csharp">public class Product
{
    private decimal basePrice;
    private ITaxCalculator taxCalculator;  // What varies
    private IShippingCalculator shippingCalculator;  // What varies
    
    public decimal CalculateFinalPrice()
    {
        decimal tax = taxCalculator.Calculate(basePrice);
        decimal shipping = shippingCalculator.Calculate();
        return basePrice + tax + shipping;
    }
}</code></pre>
              </div>
              <div class="tab-pane fade" id="encapsulate-java" role="tabpanel">
                <pre class="syntax-highlighted" data-language="Java"><code class="language-java">public class Product {
    private double basePrice;
    private ITaxCalculator taxCalculator;  // What varies
    private IShippingCalculator shippingCalculator;  // What varies
    
    public Product(double basePrice, ITaxCalculator taxCalculator, 
                   IShippingCalculator shippingCalculator) {
        this.basePrice = basePrice;
        this.taxCalculator = taxCalculator;
        this.shippingCalculator = shippingCalculator;
    }
    
    public double calculateFinalPrice() {
        double tax = taxCalculator.calculate(basePrice);
        double shipping = shippingCalculator.calculate();
        return basePrice + tax + shipping;
    }
}</code></pre>
              </div>
            </div>
          </div>

          <h3>6. Don't Repeat Yourself (DRY)</h3>
          <p>Avoid code duplication. Extract common logic into reusable methods or classes.</p>
          
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" data-bs-toggle="tab" data-bs-target="#dry-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" data-bs-toggle="tab" data-bs-target="#dry-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="dry-csharp" role="tabpanel">
                <pre class="syntax-highlighted" data-language="C#"><code class="language-csharp">// ‚úÖ Good: Reusable validation
public class Validator
{
    public static bool IsValidEmail(string email)
    {
        return !string.IsNullOrEmpty(email) && email.Contains("@");
    }
}

public class UserService
{
    public void Register(string email)
    {
        if (!Validator.IsValidEmail(email))
            throw new ArgumentException("Invalid email");
        // Register user
    }
}

public class NewsletterService
{
    public void Subscribe(string email)
    {
        if (!Validator.IsValidEmail(email))
            throw new ArgumentException("Invalid email");
        // Subscribe
    }
}</code></pre>
              </div>
              <div class="tab-pane fade" id="dry-java" role="tabpanel">
                <pre class="syntax-highlighted" data-language="Java"><code class="language-java">// ‚úÖ Good: Reusable validation
public class Validator {
    public static boolean isValidEmail(String email) {
        return email != null && !email.isEmpty() && email.contains("@");
    }
}

public class UserService {
    public void register(String email) {
        if (!Validator.isValidEmail(email))
            throw new IllegalArgumentException("Invalid email");
        // Register user
    }
}

public class NewsletterService {
    public void subscribe(String email) {
        if (!Validator.isValidEmail(email))
            throw new IllegalArgumentException("Invalid email");
        // Subscribe
    }
}</code></pre>
              </div>
            </div>
          </div>

          <h3>7. Use Immutability Where Possible</h3>
          <p>Immutable objects are easier to reason about and thread-safe.</p>
          
          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" data-bs-toggle="tab" data-bs-target="#immutability-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" data-bs-toggle="tab" data-bs-target="#immutability-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="immutability-csharp" role="tabpanel">
                <pre class="syntax-highlighted" data-language="C#"><code class="language-csharp">public class Money
{
    public decimal Amount { get; }
    public string Currency { get; }
    
    public Money(decimal amount, string currency)
    {
        Amount = amount;
        Currency = currency;
    }
    
    // Returns new instance instead of modifying
    public Money Add(Money other)
    {
        if (Currency != other.Currency)
            throw new InvalidOperationException("Currency mismatch");
        
        return new Money(Amount + other.Amount, Currency);
    }
}</code></pre>
              </div>
              <div class="tab-pane fade" id="immutability-java" role="tabpanel">
                <pre class="syntax-highlighted" data-language="Java"><code class="language-java">public final class Money {
    private final double amount;
    private final String currency;
    
    public Money(double amount, String currency) {
        this.amount = amount;
        this.currency = currency;
    }
    
    public double getAmount() { return amount; }
    public String getCurrency() { return currency; }
    
    // Returns new instance instead of modifying
    public Money add(Money other) {
        if (!currency.equals(other.currency))
            throw new IllegalStateException("Currency mismatch");
        
        return new Money(amount + other.amount, currency);
    }
}</code></pre>
              </div>
            </div>
          </div>

          <h3>8. Design for Testability</h3>
          <ul>
            <li>Use dependency injection</li>
            <li>Avoid static methods and singletons</li>
            <li>Keep methods small and focused</li>
            <li>Avoid tight coupling</li>
          </ul>

          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" data-bs-toggle="tab" data-bs-target="#testability-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" data-bs-toggle="tab" data-bs-target="#testability-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="testability-csharp" role="tabpanel">
                <pre class="syntax-highlighted" data-language="C#"><code class="language-csharp">// ‚úÖ Testable design
public class OrderService
{
    private readonly IOrderRepository repository;
    private readonly IEmailService emailService;
    private readonly ILogger logger;
    
    // Constructor injection makes testing easy
    public OrderService(
        IOrderRepository repository, 
        IEmailService emailService,
        ILogger logger)
    {
        this.repository = repository;
        this.emailService = emailService;
        this.logger = logger;
    }
    
    public void PlaceOrder(Order order)
    {
        // Method is small and focused
        repository.Save(order);
        emailService.SendConfirmation(order.CustomerEmail);
        logger.LogInfo($"Order {order.Id} placed");
    }
}

// Easy to test with mocks
[Test]
public void PlaceOrder_ShouldSaveOrderAndSendEmail()
{
    // Arrange
    var mockRepo = new Mock&lt;IOrderRepository&gt;();
    var mockEmail = new Mock&lt;IEmailService&gt;();
    var mockLogger = new Mock&lt;ILogger&gt;();
    var service = new OrderService(mockRepo.Object, mockEmail.Object, mockLogger.Object);
    
    // Act
    service.PlaceOrder(new Order { Id = 1, CustomerEmail = "test@test.com" });
    
    // Assert
    mockRepo.Verify(r =&gt; r.Save(It.IsAny&lt;Order&gt;()), Times.Once);
    mockEmail.Verify(e =&gt; e.SendConfirmation("test@test.com"), Times.Once);
}</code></pre>
              </div>
              <div class="tab-pane fade" id="testability-java" role="tabpanel">
                <pre class="syntax-highlighted" data-language="Java"><code class="language-java">// ‚úÖ Testable design
public class OrderService {
    private final IOrderRepository repository;
    private final IEmailService emailService;
    private final ILogger logger;
    
    // Constructor injection makes testing easy
    public OrderService(
            IOrderRepository repository, 
            IEmailService emailService,
            ILogger logger) {
        this.repository = repository;
        this.emailService = emailService;
        this.logger = logger;
    }
    
    public void placeOrder(Order order) {
        // Method is small and focused
        repository.save(order);
        emailService.sendConfirmation(order.getCustomerEmail());
        logger.logInfo("Order " + order.getId() + " placed");
    }
}

// Easy to test with mocks (using Mockito)
import org.junit.jupiter.api.Test;
import org.mockito.Mockito;
import static org.mockito.Mockito.*;

@Test
public void placeOrder_shouldSaveOrderAndSendEmail() {
    // Arrange
    IOrderRepository mockRepo = mock(IOrderRepository.class);
    IEmailService mockEmail = mock(IEmailService.class);
    ILogger mockLogger = mock(ILogger.class);
    OrderService service = new OrderService(mockRepo, mockEmail, mockLogger);
    
    Order order = new Order();
    order.setId(1);
    order.setCustomerEmail("test@test.com");
    
    // Act
    service.placeOrder(order);
    
    // Assert
    verify(mockRepo, times(1)).save(any(Order.class));
    verify(mockEmail, times(1)).sendConfirmation("test@test.com");
}</code></pre>
              </div>
            </div>
          </div>

          <h3>9. Follow Law of Demeter (Principle of Least Knowledge)</h3>
          <p>An object should only talk to its immediate friends, not to strangers.</p>
          
          <pre class="syntax-highlighted" data-language="C#"><code class="language-csharp">// ‚ùå Bad: Too many dots (train wreck)
customer.GetAddress().GetCity().GetZipCode();

// ‚úÖ Good: Ask the object to do it
customer.GetZipCode();  // Internally handles the chain</code></pre>

          <h3>10. Use Exceptions Appropriately</h3>
          <ul>
            <li>Use exceptions for exceptional conditions, not control flow</li>
            <li>Create custom exceptions for specific error cases</li>
            <li>Document exceptions in method comments</li>
          </ul>

          <div class="code-tabs">
            <ul class="nav nav-tabs" role="tablist">
              <li class="nav-item" role="presentation">
                <button class="nav-link active" data-bs-toggle="tab" data-bs-target="#exceptions-csharp" type="button" role="tab">C#</button>
              </li>
              <li class="nav-item" role="presentation">
                <button class="nav-link" data-bs-toggle="tab" data-bs-target="#exceptions-java" type="button" role="tab">Java</button>
              </li>
            </ul>
            <div class="tab-content">
              <div class="tab-pane fade show active" id="exceptions-csharp" role="tabpanel">
                <pre class="syntax-highlighted" data-language="C#"><code class="language-csharp">public class InsufficientFundsException : Exception
{
    public decimal RequiredAmount { get; }
    public decimal AvailableAmount { get; }
    
    public InsufficientFundsException(decimal required, decimal available)
        : base($"Insufficient funds. Required: ${required}, Available: ${available}")
    {
        RequiredAmount = required;
        AvailableAmount = available;
    }
}

public class BankAccount
{
    public void Withdraw(decimal amount)
    {
        if (amount > Balance)
            throw new InsufficientFundsException(amount, Balance);
        
        Balance -= amount;
    }
}</code></pre>
              </div>
              <div class="tab-pane fade" id="exceptions-java" role="tabpanel">
                <pre class="syntax-highlighted" data-language="Java"><code class="language-java">public class InsufficientFundsException extends Exception {
    private double requiredAmount;
    private double availableAmount;
    
    public InsufficientFundsException(double required, double available) {
        super(String.format("Insufficient funds. Required: $%.2f, Available: $%.2f", 
                          required, available));
        this.requiredAmount = required;
        this.availableAmount = available;
    }
    
    public double getRequiredAmount() { return requiredAmount; }
    public double getAvailableAmount() { return availableAmount; }
}

public class BankAccount {
    private double balance;
    
    public void withdraw(double amount) throws InsufficientFundsException {
        if (amount > balance)
            throw new InsufficientFundsException(amount, balance);
        
        balance -= amount;
    }
    
    public double getBalance() { return balance; }
}</code></pre>
              </div>
            </div>
          </div>

          <h2 class="mt-5">Code Smells to Avoid</h2>
          <div class="row g-3">
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100">
                <div class="card-body">
                  <h3>üö® Common Code Smells</h3>
                  <ul>
                    <li><strong>God Class:</strong> Class that does too much</li>
                    <li><strong>Long Method:</strong> Method with too many lines</li>
                    <li><strong>Long Parameter List:</strong> Too many parameters</li>
                    <li><strong>Duplicate Code:</strong> Copy-pasted logic</li>
                    <li><strong>Dead Code:</strong> Unused code</li>
                    <li><strong>Comments:</strong> Excessive comments (code should be self-documenting)</li>
                    <li><strong>Magic Numbers:</strong> Unexplained numeric constants</li>
                    <li><strong>Tight Coupling:</strong> Classes too dependent on each other</li>
                  </ul>
                </div>
              </div>
            </div>
            <div class="col-md-6">
              <div class="card border-0 shadow-sm h-100">
                <div class="card-body">
                  <h3>‚ú® Refactoring Solutions</h3>
                  <ul>
                    <li><strong>Extract Class:</strong> Split god class</li>
                    <li><strong>Extract Method:</strong> Break down long methods</li>
                    <li><strong>Parameter Object:</strong> Group parameters</li>
                    <li><strong>Extract Method:</strong> Reuse common logic</li>
                    <li><strong>Delete:</strong> Remove unused code</li>
                    <li><strong>Rename:</strong> Use meaningful names</li>
                    <li><strong>Named Constants:</strong> Use const or enum</li>
                    <li><strong>Dependency Injection:</strong> Reduce coupling</li>
                  </ul>
                </div>
              </div>
            </div>
          </div>

          <h2 class="mt-5">Design Patterns Quick Reference</h2>
          <p>Common patterns that solve recurring OOP problems:</p>
          
          <table class="table table-bordered table-striped">
            <thead>
              <tr>
                <th>Pattern</th>
                <th>Category</th>
                <th>Purpose</th>
                <th>Use When</th>
              </tr>
            </thead>
            <tbody>
              <tr>
                <td><strong>Singleton</strong></td>
                <td>Creational</td>
                <td>Ensure only one instance exists</td>
                <td>Logging, configuration, caching</td>
              </tr>
              <tr>
                <td><strong>Factory</strong></td>
                <td>Creational</td>
                <td>Create objects without specifying exact class</td>
                <td>Object creation logic is complex</td>
              </tr>
              <tr>
                <td><strong>Strategy</strong></td>
                <td>Behavioral</td>
                <td>Define family of algorithms</td>
                <td>Multiple algorithms for same task</td>
              </tr>
              <tr>
                <td><strong>Observer</strong></td>
                <td>Behavioral</td>
                <td>Notify dependents of state changes</td>
                <td>Event-driven systems</td>
              </tr>
              <tr>
                <td><strong>Decorator</strong></td>
                <td>Structural</td>
                <td>Add behavior dynamically</td>
                <td>Extend functionality without inheritance</td>
              </tr>
              <tr>
                <td><strong>Adapter</strong></td>
                <td>Structural</td>
                <td>Make incompatible interfaces work together</td>
                <td>Integrate third-party code</td>
              </tr>
            </tbody>
          </table>

          <h2 class="mt-5">Final Checklist</h2>
          <div class="callout">
            <h4>Before Committing Your Code, Ask:</h4>
            <ul class="mb-0">
              <li>‚úì Does each class have a single, clear responsibility?</li>
              <li>‚úì Are my classes and methods small and focused?</li>
              <li>‚úì Have I avoided code duplication (DRY)?</li>
              <li>‚úì Am I using meaningful, self-documenting names?</li>
              <li>‚úì Are my classes properly encapsulated?</li>
              <li>‚úì Am I programming to interfaces where appropriate?</li>
              <li>‚úì Is my code testable with minimal mocking?</li>
              <li>‚úì Have I followed SOLID principles?</li>
              <li>‚úì Have I removed unused code and comments?</li>
              <li>‚úì Would another developer easily understand this code?</li>
            </ul>
          </div>

          <div class="callout mt-3">
            <strong>üéØ Remember:</strong> Good OOP design is about managing complexity. Write code that is easy to 
            understand, easy to change, and easy to test. Perfection is not the goal‚Äîclarity and maintainability are. 
            Start with simple designs and refactor as you learn more about the problem domain.
          </div>
        </section>

        <!-- Resources Section -->
        <section id="resources" role="article">
          <h1>üìö Resources</h1>
          <span class="badge">docs</span>
          <span class="badge">community</span>
          <span class="badge">links</span>
          
          <h2>Books</h2>
          <ul>
            <li><strong>Object-Oriented Analysis and Design with Applications</strong> by Grady Booch</li>
            <li><strong>Head First Object-Oriented Analysis and Design</strong> by Brett McLaughlin</li>
            <li><strong>Clean Code</strong> by Robert C. Martin</li>
            <li><strong>Design Patterns: Elements of Reusable Object-Oriented Software</strong> by Gang of Four</li>
          </ul>

          <h2>Online Resources</h2>
          <ul>
            <li><a href="https://refactoring.guru/design-patterns" target="_blank" rel="noopener">Refactoring Guru - Design Patterns</a></li>
            <li><a href="https://www.oodesign.com/" target="_blank" rel="noopener">Object-Oriented Design</a></li>
            <li><a href="https://sourcemaking.com/design_patterns" target="_blank" rel="noopener">SourceMaking - Design Patterns</a></li>
            <li><a href="https://learn.microsoft.com/en-us/dotnet/csharp/fundamentals/object-oriented/" target="_blank" rel="noopener">Microsoft - Object-Oriented Programming (C#)</a></li>
          </ul>

          <h2>Communities</h2>
          <ul>
            <li><strong>Stack Overflow:</strong> Q&A for OOP concepts and implementation</li>
            <li><strong>Reddit r/programming:</strong> Discussions on OOP best practices</li>
            <li><strong>Dev.to:</strong> Articles and tutorials on OOP</li>
          </ul>

          <hr />
          <div class="document-footer">
            <p>
              <strong>Last Updated:</strong> January 2026 | 
              <strong>Curated by:</strong> Murthy Vepa with ‚ù§Ô∏è | <strong>Powered by:</strong> GitHub Copilot
            </p>
          </div>
        </section>

       
        </div>
      </main>
    </div>
    
    <nav class="controls" role="navigation" aria-label="Pagination">
      <div class="btn-group" role="group">
        <button class="btn btn-outline-info btn-sm" id="prevBtn" title="Previous" aria-label="Previous concept">&nbsp;&lt;&nbsp;</button>
        <button class="btn btn-outline-info btn-sm" id="nextBtn" title="Next" aria-label="Next concept">&nbsp;&gt;&nbsp;</button>
      </div>
    </nav>
  </div>  <div class="offcanvas offcanvas-start" tabindex="-1" id="sidebarOffcanvas" aria-labelledby="sidebarLabel">
    <div class="offcanvas-header">
      <h5 class="offcanvas-title" id="sidebarLabel">Contents</h5>
      <button type="button" class="btn-close" data-bs-dismiss="offcanvas" aria-label="Close"></button>
    </div>
    <div class="offcanvas-body p-0">
      <ul class="list-group list-group-flush w-100" id="tocMobile"></ul>
    </div>
  </div>

  <script>
    // ---- Mermaid Initialization ----
    document.addEventListener('DOMContentLoaded', () => {
      if (window.mermaid) {
        window.mermaid.contentLoaded();
      }
    });

    // ---- Configuration ----
    const sectionConfig = [
      { id: "overview", title: "üìñ Overview", tags: ["intro", "overview", "basics"] },
      { id: "core-pillars", title: "üèõÔ∏è Four Pillars of OOP", tags: ["pillars", "fundamentals", "core"] },
      { id: "encapsulation", title: "Encapsulation", tags: ["pillar", "data-hiding", "access-modifiers"] },
      { id: "abstraction", title: "Abstraction", tags: ["pillar", "interfaces", "abstract-classes"] },
      { id: "inheritance", title: "Inheritance", tags: ["pillar", "reusability", "hierarchy"] },
      { id: "polymorphism", title: "Polymorphism", tags: ["pillar", "flexibility", "dynamic-binding"] },
      { id: "classes-objects", title: "üß± Classes and Objects", tags: ["basics", "blueprint", "instance"] },
      { id: "relationships", title: "üîó Object Relationships", tags: ["associations", "aggregation", "composition"] },
      { id: "association", title: "Association", tags: ["relationship", "has-a", "uses-a"] },
      { id: "aggregation", title: "Aggregation", tags: ["relationship", "whole-part", "weak"] },
      { id: "composition", title: "Composition", tags: ["relationship", "strong", "lifecycle"] },
      { id: "interfaces", title: "üìê Interfaces & Abstract Classes", tags: ["contracts", "abstraction", "polymorphism"] },
      { id: "access-modifiers", title: "üîí Access Modifiers", tags: ["visibility", "encapsulation", "security"] },
      { id: "static-members", title: "‚ö° Static vs Instance Members", tags: ["static", "class-level", "instance-level"] },
      { id: "constructors", title: "üèóÔ∏è Constructors & Destructors", tags: ["initialization", "cleanup", "lifecycle"] },
      { id: "method-overloading", title: "üîÑ Method Overloading", tags: ["polymorphism", "compile-time", "signature"] },
      { id: "method-overriding", title: "üéØ Method Overriding", tags: ["polymorphism", "runtime", "inheritance"] },
      { id: "best-practices", title: "‚ú® OOP Best Practices", tags: ["guidelines", "tips", "patterns"] },
      { id: "resources", title: "üìö Resources", tags: ["docs", "community", "links"] }
    ];

    // ---- State & rendering ----
    const state = {
      index: 0,
      filtered: sectionConfig.map((_, i) => i), // indices
    };

    const els = {
      toc: document.getElementById('toc'),
      tocMobile: document.getElementById('tocMobile'),
      prev: document.getElementById('prevBtn'),
      next: document.getElementById('nextBtn'),
      toggleSidebar: document.getElementById('toggleSidebar'),
      themeToggle: document.getElementById('themeToggle'),
      main: document.getElementById('main'),
      sidebar: document.querySelector('nav.sidebar'),
      sidebarOffcanvas: document.getElementById('sidebarOffcanvas')
    };

    function buildTOC(){
      // Clear both TOC lists
      els.toc.innerHTML = '';
      els.tocMobile.innerHTML = '';
      
      state.filtered.forEach((idx) => {
        const s = sectionConfig[idx];
        
        // Check if this is a sub-item (Four Pillars and Relationships)
        const isSubItem = ['encapsulation', 'abstraction', 'inheritance', 'polymorphism', 'association', 'aggregation', 'composition'].includes(s.id);
        
        // Desktop sidebar
        const liDesktop = document.createElement('li');
        liDesktop.className = isSubItem ? 'list-group-sub-item' : 'list-group-item';
        const aDesktop = document.createElement('a');
        aDesktop.href = `#${s.id}`;
        aDesktop.textContent = s.title;
        aDesktop.addEventListener('click', (e) => {
          e.preventDefault();
          navigateToId(s.id);
          closeSidebar();
        });
        liDesktop.appendChild(aDesktop);
        els.toc.appendChild(liDesktop);
        
        // Mobile offcanvas
        const liMobile = document.createElement('li');
        liMobile.className = isSubItem ? 'list-group-sub-item' : 'list-group-item';
        const aMobile = document.createElement('a');
        aMobile.href = `#${s.id}`;
        aMobile.textContent = s.title;
        aMobile.addEventListener('click', (e) => {
          e.preventDefault();
          navigateToId(s.id);
          closeSidebar();
        });
        liMobile.appendChild(aMobile);
        els.tocMobile.appendChild(liMobile);
      });
      highlightActiveTOC();
    }

    function setActiveByIndex(i){
      const ids = state.filtered.map(idx => sectionConfig[idx].id);
      document.querySelectorAll('section').forEach(s => s.classList.remove('active'));
      const id = ids[i];
      const active = document.getElementById(id);
      if (active){
        active.classList.add('active');
        active.setAttribute('tabindex', '-1');
        active.focus({preventScroll:true});
      }
      updateControls();
      highlightActiveTOC();
      updateURLHash(id);
    }

    function updateControls(){
      const count = state.filtered.length;
      els.prev.disabled = state.index <= 0;
      els.next.disabled = state.index >= count - 1;
    }

    function filterTOC(query){
      const q = query.trim().toLowerCase();
      state.filtered = sectionConfig
        .map((s, i) => ({s, i}))
        .filter(({s}) => s.title.toLowerCase().includes(q) || s.tags.some(t => t.toLowerCase().includes(q)))
        .map(({i}) => i);

      state.index = Math.min(state.index, Math.max(0, state.filtered.length - 1));
      buildTOC();
      setActiveByIndex(state.index);
    }

    function navigate(delta){
      const count = state.filtered.length;
      const nextIndex = Math.min(Math.max(state.index + delta, 0), count - 1);
      if (nextIndex !== state.index){
        state.index = nextIndex;
        setActiveByIndex(state.index);
        // Scroll content to top
        const contentEl = document.querySelector('.content');
        if (contentEl) contentEl.scrollTop = 0;
      }
    }

    function navigateToId(id){
      const idxInFiltered = state.filtered.findIndex(fi => sectionConfig[fi].id === id);
      if (idxInFiltered !== -1){
        state.index = idxInFiltered;
        setActiveByIndex(state.index);
        // Scroll content to top
        const contentEl = document.querySelector('.content');
        if (contentEl) contentEl.scrollTop = 0;
      } else {
        state.filtered = sectionConfig.map((_, i) => i);
        buildTOC();
        navigateToId(id);
      }
    }

    function updateURLHash(id){
      const url = new URL(window.location);
      url.hash = id;
      history.replaceState(null, '', url);
    }

    function highlightActiveTOC(){
      const ids = state.filtered.map(idx => sectionConfig[idx].id);
      const activeId = ids[state.index];
      // Highlight desktop sidebar
      els.toc.querySelectorAll('a').forEach(a => {
        const isActive = a.getAttribute('href') === `#${activeId}`;
        a.classList.toggle('active', isActive);
        // Also toggle active on parent li for sub-items
        if (a.parentElement.classList.contains('list-group-sub-item')) {
          a.parentElement.classList.toggle('active', isActive);
        }
      });
      // Highlight mobile offcanvas
      els.tocMobile.querySelectorAll('a').forEach(a => {
        const isActive = a.getAttribute('href') === `#${activeId}`;
        a.classList.toggle('active', isActive);
        // Also toggle active on parent li for sub-items
        if (a.parentElement.classList.contains('list-group-sub-item')) {
          a.parentElement.classList.toggle('active', isActive);
        }
      });
    }

    function openSidebar(){
      const offcanvas = new bootstrap.Offcanvas(document.getElementById('sidebarOffcanvas'));
      offcanvas.show();
    }
    function closeSidebar(){
      const offcanvasElement = document.getElementById('sidebarOffcanvas');
      const offcanvas = bootstrap.Offcanvas.getInstance(offcanvasElement);
      if(offcanvas) offcanvas.hide();
    }

    // ---- Events ----
    els.prev.addEventListener('click', () => navigate(-1));
    els.next.addEventListener('click', () => navigate(1));

    // Keyboard navigation
    window.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowLeft') navigate(-1);
      else if (e.key === 'ArrowRight') navigate(1);
      else if (e.key === 'Escape') closeSidebar();
    });

    // Deep linking on load/hash change
    window.addEventListener('hashchange', () => {
      const id = location.hash.replace('#','');
      if (id) navigateToId(id);
    });

    // Sidebar toggle (mobile)
    els.toggleSidebar.addEventListener('click', () => {
      openSidebar();
    });

    // Restore theme
    (function(){
      try {
        const saved = localStorage.getItem('concepts-theme');
        if (saved) { 
          document.documentElement.setAttribute('data-theme', saved);
          els.themeToggle.textContent = saved === 'light' ? 'üåó' : 'üåô';
        }
      } catch {}
    })();

    // Initial render
    buildTOC();
    
    // Navigate to hash if present, otherwise show first section
    const initialId = location.hash.replace('#','');
    if (initialId){ 
    navigateToId(initialId); 
    } else {
    setActiveByIndex(0);
    // Scroll content to top on initial load
    const contentEl = document.querySelector('.content');
    if (contentEl) contentEl.scrollTop = 0;
    }

  </script>
  <!-- Bootstrap JS -->
  <script src="https://cdn.jsdelivr.net/npm/bootstrap@5.3.0/dist/js/bootstrap.bundle.min.js"></script>
</body>
</html>